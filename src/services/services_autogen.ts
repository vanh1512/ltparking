//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined , cancelToken?: CancelToken | undefined): Promise<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsTenantAvailable(_response);
        });
    }

    protected processIsTenantAvailable(response: AxiosResponse): Promise<IsTenantAvailableOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IsTenantAvailableOutput.fromJS(resultData200.result);
            return Promise.resolve<IsTenantAvailableOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined , cancelToken?: CancelToken | undefined): Promise<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<RegisterOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegisterOutput.fromJS(resultData200.result);
            return Promise.resolve<RegisterOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegisterOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterMember(_response);
        });
    }

    protected processRegisterMember(response: AxiosResponse): Promise<RegisterOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegisterOutput.fromJS(resultData200.result);
            return Promise.resolve<RegisterOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegisterOutput>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPasswordViaEmail(email: string | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/ForgotPasswordViaEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processForgotPasswordViaEmail(_response);
        });
    }

    protected processForgotPasswordViaEmail(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param token (optional) 
     * @param email (optional) 
     * @param password (optional) 
     * @return Success
     */
    resetPasswordViaEmail(token: string | undefined, email: string | undefined, password: string | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPasswordViaEmail?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPasswordViaEmail(_response);
        });
    }

    protected processResetPasswordViaEmail(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class ApplicationExtService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param app_search (optional) 
     * @return Success
     */
    getAll(app_search: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/GetAll?";
        if (app_search === null)
            throw new Error("The parameter 'app_search' cannot be null.");
        else if (app_search !== undefined)
            url_ += "app_search=" + encodeURIComponent("" + app_search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ApplicationExtDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApplicationExtInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ApplicationExtDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateApplicationExtInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ApplicationExtDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class AuditLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param impersonatorUserId (optional) 
     * @param exception (optional) 
     * @param browserInfo (optional) 
     * @param clientName (optional) 
     * @param clientIpAddress (optional) 
     * @param userId (optional) 
     * @param methodName (optional) 
     * @param serviceName (optional) 
     * @param skipCount (optional) 
     * @param maxValue (optional) 
     * @return Success
     */
    getAll(impersonatorUserId: number | undefined, exception: string | undefined, browserInfo: string | undefined, clientName: string | undefined, clientIpAddress: string | undefined, userId: number | undefined, methodName: string | undefined, serviceName: string | undefined, skipCount: number | undefined, maxValue: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuditLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAll?";
        if (impersonatorUserId === null)
            throw new Error("The parameter 'impersonatorUserId' cannot be null.");
        else if (impersonatorUserId !== undefined)
            url_ += "ImpersonatorUserId=" + encodeURIComponent("" + impersonatorUserId) + "&";
        if (exception === null)
            throw new Error("The parameter 'exception' cannot be null.");
        else if (exception !== undefined)
            url_ += "Exception=" + encodeURIComponent("" + exception) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (clientName === null)
            throw new Error("The parameter 'clientName' cannot be null.");
        else if (clientName !== undefined)
            url_ += "ClientName=" + encodeURIComponent("" + clientName) + "&";
        if (clientIpAddress === null)
            throw new Error("The parameter 'clientIpAddress' cannot be null.");
        else if (clientIpAddress !== undefined)
            url_ += "ClientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxValue === null)
            throw new Error("The parameter 'maxValue' cannot be null.");
        else if (maxValue !== undefined)
            url_ += "maxValue=" + encodeURIComponent("" + maxValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<AuditLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<AuditLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param au_lo_id (optional) 
     * @return Success
     */
    deleteAuditLog(au_lo_id: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/DeleteAuditLog?";
        if (au_lo_id === null)
            throw new Error("The parameter 'au_lo_id' cannot be null.");
        else if (au_lo_id !== undefined)
            au_lo_id && au_lo_id.forEach(item => { url_ += "au_lo_id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAuditLog(_response);
        });
    }

    protected processDeleteAuditLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteAllAuditLog(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/DeleteAllAuditLog";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllAuditLog(_response);
        });
    }

    protected processDeleteAllAuditLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthorizationMachineService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id_list (optional) 
     * @param us_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_id_list: number[] | undefined, us_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorizationMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/GetAll?";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (us_id_list === null)
            throw new Error("The parameter 'us_id_list' cannot be null.");
        else if (us_id_list !== undefined)
            us_id_list && us_id_list.forEach(item => { url_ += "us_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<AuthorizationMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorizationMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<AuthorizationMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorizationMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onGetMachineFromUsId(body: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/onGetMachineFromUsId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnGetMachineFromUsId(_response);
        });
    }

    protected processOnGetMachineFromUsId(response: AxiosResponse): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<number[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAuthorizationMachine(body: CreateAuthorizationMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/CreateAuthorizationMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAuthorizationMachine(_response);
        });
    }

    protected processCreateAuthorizationMachine(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAuthorizationMachine(body: UpdateAuthorizationMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorizationMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/UpdateAuthorizationMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAuthorizationMachine(_response);
        });
    }

    protected processUpdateAuthorizationMachine(response: AxiosResponse): Promise<AuthorizationMachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorizationMachineDto.fromJS(resultData200.result);
            return Promise.resolve<AuthorizationMachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorizationMachineDto>(null as any);
    }

    /**
     * @param au_ma_id (optional) 
     * @return Success
     */
    delete(au_ma_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/Delete?";
        if (au_ma_id === null)
            throw new Error("The parameter 'au_ma_id' cannot be null.");
        else if (au_ma_id !== undefined)
            url_ += "au_ma_id=" + encodeURIComponent("" + au_ma_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMulti(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/DeleteMulti?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMachine/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BillingService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param bi_code (optional) 
     * @param ma_id (optional) 
     * @param di_id (optional) 
     * @param bi_status (optional) 
     * @param bi_reconcile_status (optional) 
     * @param bi_required_refund (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(bi_code: string | undefined, ma_id: number | undefined, di_id: number | undefined, bi_status: EBillStatus | undefined, bi_reconcile_status: EBillReconcileStatus[] | undefined, bi_required_refund: EBillRequiredFund[] | undefined, start_date: Date | undefined, end_date: Date | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetAll?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (di_id === null)
            throw new Error("The parameter 'di_id' cannot be null.");
        else if (di_id !== undefined)
            url_ += "di_id=" + encodeURIComponent("" + di_id) + "&";
        if (bi_status === null)
            throw new Error("The parameter 'bi_status' cannot be null.");
        else if (bi_status !== undefined)
            url_ += "bi_status=" + encodeURIComponent("" + bi_status) + "&";
        if (bi_reconcile_status === null)
            throw new Error("The parameter 'bi_reconcile_status' cannot be null.");
        else if (bi_reconcile_status !== undefined)
            bi_reconcile_status && bi_reconcile_status.forEach(item => { url_ += "bi_reconcile_status=" + encodeURIComponent("" + item) + "&"; });
        if (bi_required_refund === null)
            throw new Error("The parameter 'bi_required_refund' cannot be null.");
        else if (bi_required_refund !== undefined)
            bi_required_refund && bi_required_refund.forEach(item => { url_ += "bi_required_refund=" + encodeURIComponent("" + item) + "&"; });
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }

    /**
     * @param listBillingId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingById(listBillingId: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetAllBillingById?";
        if (listBillingId === null)
            throw new Error("The parameter 'listBillingId' cannot be null.");
        else if (listBillingId !== undefined)
            listBillingId && listBillingId.forEach(item => { url_ += "listBillingId=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllBillingById(_response);
        });
    }

    protected processGetAllBillingById(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param bi_code (optional) 
     * @param ma_id (optional) 
     * @param di_id (optional) 
     * @param bi_status (optional) 
     * @param bi_reconcile_status (optional) 
     * @param bi_required_refund (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(us_id: number[] | undefined, bi_code: string | undefined, ma_id: number | undefined, di_id: number | undefined, bi_status: EBillStatus | undefined, bi_reconcile_status: EBillReconcileStatus[] | undefined, bi_required_refund: EBillRequiredFund[] | undefined, start_date: Date | undefined, end_date: Date | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetAllByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (di_id === null)
            throw new Error("The parameter 'di_id' cannot be null.");
        else if (di_id !== undefined)
            url_ += "di_id=" + encodeURIComponent("" + di_id) + "&";
        if (bi_status === null)
            throw new Error("The parameter 'bi_status' cannot be null.");
        else if (bi_status !== undefined)
            url_ += "bi_status=" + encodeURIComponent("" + bi_status) + "&";
        if (bi_reconcile_status === null)
            throw new Error("The parameter 'bi_reconcile_status' cannot be null.");
        else if (bi_reconcile_status !== undefined)
            bi_reconcile_status && bi_reconcile_status.forEach(item => { url_ += "bi_reconcile_status=" + encodeURIComponent("" + item) + "&"; });
        if (bi_required_refund === null)
            throw new Error("The parameter 'bi_required_refund' cannot be null.");
        else if (bi_required_refund !== undefined)
            bi_required_refund && bi_required_refund.forEach(item => { url_ += "bi_required_refund=" + encodeURIComponent("" + item) + "&"; });
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }
}

export class ConfigurationService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeUiTheme(_response);
        });
    }

    protected processChangeUiTheme(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DailyMonitoringService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    machineOutOfStockQuery(gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/MachineOutOfStockQuery?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMachineOutOfStockQuery(_response);
        });
    }

    protected processMachineOutOfStockQuery(response: AxiosResponse): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineOutOfStockQueryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    machineOutOfStockQueryAdmin(us_id: number[] | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/MachineOutOfStockQueryAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMachineOutOfStockQueryAdmin(_response);
        });
    }

    protected processMachineOutOfStockQueryAdmin(response: AxiosResponse): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineOutOfStockQueryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onQueryMachineOutOfStockQuery(body: Machine[] | undefined , cancelToken?: CancelToken | undefined): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/onQueryMachineOutOfStockQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnQueryMachineOutOfStockQuery(_response);
        });
    }

    protected processOnQueryMachineOutOfStockQuery(response: AxiosResponse): Promise<MachineOutOfStockQueryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineOutOfStockQueryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineOutOfStockQueryDtoPagedResultDto>(null as any);
    }

    /**
     * @param ma_id (optional) 
     * @param listIdMachineDetail (optional) 
     * @return Success
     */
    getAllMachineDetailOfListID(ma_id: number | undefined, listIdMachineDetail: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ProductDailyMonitoringDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/GetAllMachineDetailOfListID?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (listIdMachineDetail === null)
            throw new Error("The parameter 'listIdMachineDetail' cannot be null.");
        else if (listIdMachineDetail !== undefined)
            listIdMachineDetail && listIdMachineDetail.forEach(item => { url_ += "listIdMachineDetail=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllMachineDetailOfListID(_response);
        });
    }

    protected processGetAllMachineDetailOfListID(response: AxiosResponse): Promise<ProductDailyMonitoringDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDailyMonitoringDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ProductDailyMonitoringDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDailyMonitoringDtoPagedResultDto>(null as any);
    }

    /**
     * @param ma_networkStatus (optional) 
     * @param ma_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statusMonitoring(ma_networkStatus: MachineNetworkStatus | undefined, ma_status: MachineStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/StatusMonitoring?";
        if (ma_networkStatus === null)
            throw new Error("The parameter 'ma_networkStatus' cannot be null.");
        else if (ma_networkStatus !== undefined)
            url_ += "ma_networkStatus=" + encodeURIComponent("" + ma_networkStatus) + "&";
        if (ma_status === null)
            throw new Error("The parameter 'ma_status' cannot be null.");
        else if (ma_status !== undefined)
            url_ += "ma_status=" + encodeURIComponent("" + ma_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatusMonitoring(_response);
        });
    }

    protected processStatusMonitoring(response: AxiosResponse): Promise<MachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param ma_networkStatus (optional) 
     * @param ma_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statusMonitoringAdmin(us_id: number[] | undefined, ma_networkStatus: MachineNetworkStatus | undefined, ma_status: MachineStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/StatusMonitoringAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (ma_networkStatus === null)
            throw new Error("The parameter 'ma_networkStatus' cannot be null.");
        else if (ma_networkStatus !== undefined)
            url_ += "ma_networkStatus=" + encodeURIComponent("" + ma_networkStatus) + "&";
        if (ma_status === null)
            throw new Error("The parameter 'ma_status' cannot be null.");
        else if (ma_status !== undefined)
            url_ += "ma_status=" + encodeURIComponent("" + ma_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatusMonitoringAdmin(_response);
        });
    }

    protected processStatusMonitoringAdmin(response: AxiosResponse): Promise<MachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onQueryStatusMonitoring(body: Machine[] | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DailyMonitoring/onQueryStatusMonitoring";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnQueryStatusMonitoring(_response);
        });
    }

    protected processOnQueryStatusMonitoring(response: AxiosResponse): Promise<MachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDtoPagedResultDto>(null as any);
    }
}

export class DashboardService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getTrashBinDashboard(  cancelToken?: CancelToken | undefined): Promise<TrashBinDashBoardDto> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetTrashBinDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTrashBinDashboard(_response);
        });
    }

    protected processGetTrashBinDashboard(response: AxiosResponse): Promise<TrashBinDashBoardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrashBinDashBoardDto.fromJS(resultData200.result);
            return Promise.resolve<TrashBinDashBoardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrashBinDashBoardDto>(null as any);
    }

    /**
     * @return Success
     */
    notifyCashPaymentNotWorking(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/NotifyCashPaymentNotWorking";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNotifyCashPaymentNotWorking(_response);
        });
    }

    protected processNotifyCashPaymentNotWorking(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getDashboard(  cancelToken?: CancelToken | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: AxiosResponse): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardDto.fromJS(resultData200.result);
            return Promise.resolve<DashboardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardDto>(null as any);
    }

    /**
     * @param kindOfDay (optional) 
     * @param numberOfMachine (optional) 
     * @return Success
     */
    getDashboardChartProductMoneyAndQuantity(kindOfDay: number | undefined, numberOfMachine: number | undefined , cancelToken?: CancelToken | undefined): Promise<DashboardCombinationDto> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetDashboardChartProductMoneyAndQuantity?";
        if (kindOfDay === null)
            throw new Error("The parameter 'kindOfDay' cannot be null.");
        else if (kindOfDay !== undefined)
            url_ += "kindOfDay=" + encodeURIComponent("" + kindOfDay) + "&";
        if (numberOfMachine === null)
            throw new Error("The parameter 'numberOfMachine' cannot be null.");
        else if (numberOfMachine !== undefined)
            url_ += "numberOfMachine=" + encodeURIComponent("" + numberOfMachine) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardChartProductMoneyAndQuantity(_response);
        });
    }

    protected processGetDashboardChartProductMoneyAndQuantity(response: AxiosResponse): Promise<DashboardCombinationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardCombinationDto.fromJS(resultData200.result);
            return Promise.resolve<DashboardCombinationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardCombinationDto>(null as any);
    }
}

export class DiscountCodeService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param di_code (optional) 
     * @param di_quantity_max (optional) 
     * @param di_start_at (optional) 
     * @param di_end_at (optional) 
     * @param di_price_down (optional) 
     * @param di_price_up (optional) 
     * @param ma_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(di_code: string | undefined, di_quantity_max: number | undefined, di_start_at: Date | undefined, di_end_at: Date | undefined, di_price_down: number | undefined, di_price_up: number | undefined, ma_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DiscountCodeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/GetAll?";
        if (di_code === null)
            throw new Error("The parameter 'di_code' cannot be null.");
        else if (di_code !== undefined)
            url_ += "di_code=" + encodeURIComponent("" + di_code) + "&";
        if (di_quantity_max === null)
            throw new Error("The parameter 'di_quantity_max' cannot be null.");
        else if (di_quantity_max !== undefined)
            url_ += "di_quantity_max=" + encodeURIComponent("" + di_quantity_max) + "&";
        if (di_start_at === null)
            throw new Error("The parameter 'di_start_at' cannot be null.");
        else if (di_start_at !== undefined)
            url_ += "di_start_at=" + encodeURIComponent(di_start_at ? "" + di_start_at.toISOString() : "") + "&";
        if (di_end_at === null)
            throw new Error("The parameter 'di_end_at' cannot be null.");
        else if (di_end_at !== undefined)
            url_ += "di_end_at=" + encodeURIComponent(di_end_at ? "" + di_end_at.toISOString() : "") + "&";
        if (di_price_down === null)
            throw new Error("The parameter 'di_price_down' cannot be null.");
        else if (di_price_down !== undefined)
            url_ += "di_price_down=" + encodeURIComponent("" + di_price_down) + "&";
        if (di_price_up === null)
            throw new Error("The parameter 'di_price_up' cannot be null.");
        else if (di_price_up !== undefined)
            url_ += "di_price_up=" + encodeURIComponent("" + di_price_up) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DiscountCodeDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DiscountCodeDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DiscountCodeDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DiscountCodeDtoPagedResultDto>(null as any);
    }

    /**
     * @param di_code (optional) 
     * @param di_quantity_max (optional) 
     * @param di_start_at (optional) 
     * @param di_end_at (optional) 
     * @param di_price_down (optional) 
     * @param di_price_up (optional) 
     * @param ma_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllForAdmin(di_code: string | undefined, di_quantity_max: number | undefined, di_start_at: Date | undefined, di_end_at: Date | undefined, di_price_down: number | undefined, di_price_up: number | undefined, ma_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DiscountCodeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/GetAllForAdmin?";
        if (di_code === null)
            throw new Error("The parameter 'di_code' cannot be null.");
        else if (di_code !== undefined)
            url_ += "di_code=" + encodeURIComponent("" + di_code) + "&";
        if (di_quantity_max === null)
            throw new Error("The parameter 'di_quantity_max' cannot be null.");
        else if (di_quantity_max !== undefined)
            url_ += "di_quantity_max=" + encodeURIComponent("" + di_quantity_max) + "&";
        if (di_start_at === null)
            throw new Error("The parameter 'di_start_at' cannot be null.");
        else if (di_start_at !== undefined)
            url_ += "di_start_at=" + encodeURIComponent(di_start_at ? "" + di_start_at.toISOString() : "") + "&";
        if (di_end_at === null)
            throw new Error("The parameter 'di_end_at' cannot be null.");
        else if (di_end_at !== undefined)
            url_ += "di_end_at=" + encodeURIComponent(di_end_at ? "" + di_end_at.toISOString() : "") + "&";
        if (di_price_down === null)
            throw new Error("The parameter 'di_price_down' cannot be null.");
        else if (di_price_down !== undefined)
            url_ += "di_price_down=" + encodeURIComponent("" + di_price_down) + "&";
        if (di_price_up === null)
            throw new Error("The parameter 'di_price_up' cannot be null.");
        else if (di_price_up !== undefined)
            url_ += "di_price_up=" + encodeURIComponent("" + di_price_up) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForAdmin(_response);
        });
    }

    protected processGetAllForAdmin(response: AxiosResponse): Promise<DiscountCodeDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DiscountCodeDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DiscountCodeDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DiscountCodeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDiscountCode(body: CreateDiscountCodeInput | undefined , cancelToken?: CancelToken | undefined): Promise<DiscountCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/CreateDiscountCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDiscountCode(_response);
        });
    }

    protected processCreateDiscountCode(response: AxiosResponse): Promise<DiscountCodeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DiscountCodeDto.fromJS(resultData200.result);
            return Promise.resolve<DiscountCodeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DiscountCodeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListDiscountCode(body: CreateDiscountCodeInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<DiscountCodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/CreateListDiscountCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListDiscountCode(_response);
        });
    }

    protected processCreateListDiscountCode(response: AxiosResponse): Promise<DiscountCodeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DiscountCodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DiscountCodeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DiscountCodeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDiscountCode(body: UpdateDiscountCodeInput | undefined , cancelToken?: CancelToken | undefined): Promise<DiscountCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/UpdateDiscountCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDiscountCode(_response);
        });
    }

    protected processUpdateDiscountCode(response: AxiosResponse): Promise<DiscountCodeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DiscountCodeDto.fromJS(resultData200.result);
            return Promise.resolve<DiscountCodeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DiscountCodeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeActivate(_response);
        });
    }

    protected processDeActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DownloadFilesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    downloadFileDocument(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/DownloadFiles/downloadFileDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFileDocument(_response);
        });
    }

    protected processDownloadFileDocument(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DrinkService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param dr_search (optional) 
     * @param su_id (optional) 
     * @param dr_price_down (optional) 
     * @param dr_price_up (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(dr_search: string | undefined, su_id: number | undefined, dr_price_down: number | undefined, dr_price_up: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DrinkDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Drink/GetAll?";
        if (dr_search === null)
            throw new Error("The parameter 'dr_search' cannot be null.");
        else if (dr_search !== undefined)
            url_ += "dr_search=" + encodeURIComponent("" + dr_search) + "&";
        if (su_id === null)
            throw new Error("The parameter 'su_id' cannot be null.");
        else if (su_id !== undefined)
            url_ += "su_id=" + encodeURIComponent("" + su_id) + "&";
        if (dr_price_down === null)
            throw new Error("The parameter 'dr_price_down' cannot be null.");
        else if (dr_price_down !== undefined)
            url_ += "dr_price_down=" + encodeURIComponent("" + dr_price_down) + "&";
        if (dr_price_up === null)
            throw new Error("The parameter 'dr_price_up' cannot be null.");
        else if (dr_price_up !== undefined)
            url_ += "dr_price_up=" + encodeURIComponent("" + dr_price_up) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DrinkDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DrinkDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DrinkDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DrinkDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDrink(body: CreateDrinkInput | undefined , cancelToken?: CancelToken | undefined): Promise<DrinkDto> {
        let url_ = this.baseUrl + "/api/services/app/Drink/CreateDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDrink(_response);
        });
    }

    protected processCreateDrink(response: AxiosResponse): Promise<DrinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DrinkDto.fromJS(resultData200.result);
            return Promise.resolve<DrinkDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DrinkDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListDrink(body: ImportDrinkInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Drink/CreateListDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListDrink(_response);
        });
    }

    protected processCreateListDrink(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDrink(body: UpdateDrinkInput | undefined , cancelToken?: CancelToken | undefined): Promise<DrinkDto> {
        let url_ = this.baseUrl + "/api/services/app/Drink/UpdateDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDrink(_response);
        });
    }

    protected processUpdateDrink(response: AxiosResponse): Promise<DrinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DrinkDto.fromJS(resultData200.result);
            return Promise.resolve<DrinkDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DrinkDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Drink/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Drink/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Drink/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ExportRepositoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param re_id (optional) 
     * @param ma_id (optional) 
     * @param ex_re_code (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(re_id: number | undefined, ma_id: number | undefined, ex_re_code: string | undefined, start_date: Date | undefined, end_date: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ExportRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportRepository/GetAll?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (ex_re_code === null)
            throw new Error("The parameter 'ex_re_code' cannot be null.");
        else if (ex_re_code !== undefined)
            url_ += "ex_re_code=" + encodeURIComponent("" + ex_re_code) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ExportRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExportRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ExportRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateExportProduct(body: Importing | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ExportRepository/CreateOrUpdateExportProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrUpdateExportProduct(_response);
        });
    }

    protected processCreateOrUpdateExportProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class FileService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fi_name (optional) 
     * @param fi_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fi_name: string | undefined, fi_type: EComponentUpload | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/File/GetAll?";
        if (fi_name === null)
            throw new Error("The parameter 'fi_name' cannot be null.");
        else if (fi_name !== undefined)
            url_ += "fi_name=" + encodeURIComponent("" + fi_name) + "&";
        if (fi_type === null)
            throw new Error("The parameter 'fi_type' cannot be null.");
        else if (fi_type !== undefined)
            url_ += "fi_type=" + encodeURIComponent("" + fi_type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FileDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FileDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renameFile(body: RenameFileInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/File/RenameFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRenameFile(_response);
        });
    }

    protected processRenameFile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fileType (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFiles(fileType: number | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/File/CreateFiles?";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFiles(_response);
        });
    }

    protected processCreateFiles(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDto.fromJS(resultData200.result);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param fi_id (optional) 
     * @return Success
     */
    delete(fi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/File/Delete?";
        if (fi_id === null)
            throw new Error("The parameter 'fi_id' cannot be null.");
        else if (fi_id !== undefined)
            url_ += "fi_id=" + encodeURIComponent("" + fi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FileMediaService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fi_me_name (optional) 
     * @param ma_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fi_me_name: string | undefined, ma_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileMediaDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileMedia/GetAll?";
        if (fi_me_name === null)
            throw new Error("The parameter 'fi_me_name' cannot be null.");
        else if (fi_me_name !== undefined)
            url_ += "fi_me_name=" + encodeURIComponent("" + fi_me_name) + "&";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FileMediaDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileMediaDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FileMediaDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileMediaDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renameFile(body: RenameFileMediaInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FileMedia/RenameFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRenameFile(_response);
        });
    }

    protected processRenameFile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param ma_id (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFile(ma_id: number | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileMediaDto> {
        let url_ = this.baseUrl + "/api/services/app/FileMedia/CreateFile?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: AxiosResponse): Promise<FileMediaDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileMediaDto.fromJS(resultData200.result);
            return Promise.resolve<FileMediaDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileMediaDto>(null as any);
    }

    /**
     * @param fi_id (optional) 
     * @return Success
     */
    delete(fi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileMedia/Delete?";
        if (fi_id === null)
            throw new Error("The parameter 'fi_id' cannot be null.");
        else if (fi_id !== undefined)
            url_ += "fi_id=" + encodeURIComponent("" + fi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FreshDrinkService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fr_dr_search (optional) 
     * @param su_id (optional) 
     * @param fr_dr_price_down (optional) 
     * @param fr_dr_price_up (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fr_dr_search: string | undefined, su_id: number | undefined, fr_dr_price_down: number | undefined, fr_dr_price_up: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FreshDrinkDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/GetAll?";
        if (fr_dr_search === null)
            throw new Error("The parameter 'fr_dr_search' cannot be null.");
        else if (fr_dr_search !== undefined)
            url_ += "fr_dr_search=" + encodeURIComponent("" + fr_dr_search) + "&";
        if (su_id === null)
            throw new Error("The parameter 'su_id' cannot be null.");
        else if (su_id !== undefined)
            url_ += "su_id=" + encodeURIComponent("" + su_id) + "&";
        if (fr_dr_price_down === null)
            throw new Error("The parameter 'fr_dr_price_down' cannot be null.");
        else if (fr_dr_price_down !== undefined)
            url_ += "fr_dr_price_down=" + encodeURIComponent("" + fr_dr_price_down) + "&";
        if (fr_dr_price_up === null)
            throw new Error("The parameter 'fr_dr_price_up' cannot be null.");
        else if (fr_dr_price_up !== undefined)
            url_ += "fr_dr_price_up=" + encodeURIComponent("" + fr_dr_price_up) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FreshDrinkDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FreshDrinkDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FreshDrinkDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FreshDrinkDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreshDrink(body: CreateFreshDrinkInput | undefined , cancelToken?: CancelToken | undefined): Promise<FreshDrinkDto> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/CreateFreshDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFreshDrink(_response);
        });
    }

    protected processCreateFreshDrink(response: AxiosResponse): Promise<FreshDrinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FreshDrinkDto.fromJS(resultData200.result);
            return Promise.resolve<FreshDrinkDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FreshDrinkDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListFreshDrink(body: ImportFreshDrinkInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/CreateListFreshDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListFreshDrink(_response);
        });
    }

    protected processCreateListFreshDrink(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFreshDrink(body: UpdateFreshDrinkInput | undefined , cancelToken?: CancelToken | undefined): Promise<FreshDrinkDto> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/UpdateFreshDrink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFreshDrink(_response);
        });
    }

    protected processUpdateFreshDrink(response: AxiosResponse): Promise<FreshDrinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FreshDrinkDto.fromJS(resultData200.result);
            return Promise.resolve<FreshDrinkDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FreshDrinkDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FreshDrink/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class GroupMachineService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param gr_ma_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(gr_ma_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GroupMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/GetAll?";
        if (gr_ma_search === null)
            throw new Error("The parameter 'gr_ma_search' cannot be null.");
        else if (gr_ma_search !== undefined)
            url_ += "gr_ma_search=" + encodeURIComponent("" + gr_ma_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<GroupMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GroupMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_ma_search (optional) 
     * @param us_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(gr_ma_search: string | undefined, us_id: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GroupMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/GetAllByAdmin?";
        if (gr_ma_search === null)
            throw new Error("The parameter 'gr_ma_search' cannot be null.");
        else if (gr_ma_search !== undefined)
            url_ += "gr_ma_search=" + encodeURIComponent("" + gr_ma_search) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<GroupMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GroupMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGroupMachine(body: CreateGroupMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<GroupMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/CreateGroupMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateGroupMachine(_response);
        });
    }

    protected processCreateGroupMachine(response: AxiosResponse): Promise<GroupMachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupMachineDto.fromJS(resultData200.result);
            return Promise.resolve<GroupMachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupMachineDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGroupMachine(body: UpdateGroupMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<GroupMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/UpdateGroupMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateGroupMachine(_response);
        });
    }

    protected processUpdateGroupMachine(response: AxiosResponse): Promise<GroupMachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupMachineDto.fromJS(resultData200.result);
            return Promise.resolve<GroupMachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupMachineDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupMachine/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class GroupTrashbinService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param gr_tr_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(gr_tr_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GroupTrashbinDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/GetAll?";
        if (gr_tr_search === null)
            throw new Error("The parameter 'gr_tr_search' cannot be null.");
        else if (gr_tr_search !== undefined)
            url_ += "gr_tr_search=" + encodeURIComponent("" + gr_tr_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<GroupTrashbinDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupTrashbinDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GroupTrashbinDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupTrashbinDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGroupTrashbin(body: CreateGroupTrashbinInput | undefined , cancelToken?: CancelToken | undefined): Promise<GroupTrashbinDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/CreateGroupTrashbin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateGroupTrashbin(_response);
        });
    }

    protected processCreateGroupTrashbin(response: AxiosResponse): Promise<GroupTrashbinDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupTrashbinDto.fromJS(resultData200.result);
            return Promise.resolve<GroupTrashbinDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupTrashbinDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGroupTrashbin(body: UpdateGroupTrashbinInput | undefined , cancelToken?: CancelToken | undefined): Promise<GroupTrashbinDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/UpdateGroupTrashbin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateGroupTrashbin(_response);
        });
    }

    protected processUpdateGroupTrashbin(response: AxiosResponse): Promise<GroupTrashbinDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupTrashbinDto.fromJS(resultData200.result);
            return Promise.resolve<GroupTrashbinDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupTrashbinDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/GroupTrashbin/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class HandoverService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param handover_user (optional) 
     * @param receive_user (optional) 
     * @param ha_status (optional) 
     * @param ha_type (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(start_date: Date | undefined, end_date: Date | undefined, handover_user: number[] | undefined, receive_user: number[] | undefined, ha_status: EHandoverStatus | undefined, ha_type: EHandoverType | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<HandoverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Handover/GetAll?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (handover_user === null)
            throw new Error("The parameter 'handover_user' cannot be null.");
        else if (handover_user !== undefined)
            handover_user && handover_user.forEach(item => { url_ += "handover_user=" + encodeURIComponent("" + item) + "&"; });
        if (receive_user === null)
            throw new Error("The parameter 'receive_user' cannot be null.");
        else if (receive_user !== undefined)
            receive_user && receive_user.forEach(item => { url_ += "receive_user=" + encodeURIComponent("" + item) + "&"; });
        if (ha_status === null)
            throw new Error("The parameter 'ha_status' cannot be null.");
        else if (ha_status !== undefined)
            url_ += "ha_status=" + encodeURIComponent("" + ha_status) + "&";
        if (ha_type === null)
            throw new Error("The parameter 'ha_type' cannot be null.");
        else if (ha_type !== undefined)
            url_ += "ha_type=" + encodeURIComponent("" + ha_type) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<HandoverDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HandoverDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<HandoverDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HandoverDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createHandover(body: CreateHandoverInput | undefined , cancelToken?: CancelToken | undefined): Promise<HandoverDto> {
        let url_ = this.baseUrl + "/api/services/app/Handover/CreateHandover";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateHandover(_response);
        });
    }

    protected processCreateHandover(response: AxiosResponse): Promise<HandoverDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HandoverDto.fromJS(resultData200.result);
            return Promise.resolve<HandoverDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HandoverDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListHandover(body: CreateHandoverInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Handover/CreateListHandover";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListHandover(_response);
        });
    }

    protected processCreateListHandover(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateHandover(body: UpdateHandoverInput | undefined , cancelToken?: CancelToken | undefined): Promise<HandoverDto> {
        let url_ = this.baseUrl + "/api/services/app/Handover/UpdateHandover";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateHandover(_response);
        });
    }

    protected processUpdateHandover(response: AxiosResponse): Promise<HandoverDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HandoverDto.fromJS(resultData200.result);
            return Promise.resolve<HandoverDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HandoverDto>(null as any);
    }
}

export class HardwareService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id (optional) 
     * @param devID (optional) 
     * @return Success
     */
    addDevice(us_id: number | undefined, devID: string | undefined , cancelToken?: CancelToken | undefined): Promise<Machine> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/AddDevice?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddDevice(_response);
        });
    }

    protected processAddDevice(response: AxiosResponse): Promise<Machine> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Machine.fromJS(resultData200.result);
            return Promise.resolve<Machine>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Machine>(null as any);
    }

    /**
     * @param devId (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    uploadLogcat(devId: string | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/uploadLogcat?";
        if (devId === null)
            throw new Error("The parameter 'devId' cannot be null.");
        else if (devId !== undefined)
            url_ += "devId=" + encodeURIComponent("" + devId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadLogcat(_response);
        });
    }

    protected processUploadLogcat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pingToServer(body: PingToServerInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/pingToServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPingToServer(_response);
        });
    }

    protected processPingToServer(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reconcileCash(body: ReconcileCashInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/ReconcileCash";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconcileCash(_response);
        });
    }

    protected processReconcileCash(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loadProduct(body: LoadProductInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/LoadProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoadProduct(_response);
        });
    }

    protected processLoadProduct(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onGetListExportProduct(body: ProductExportDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<ProductExportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/onGetListExportProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnGetListExportProduct(_response);
        });
    }

    protected processOnGetListExportProduct(response: AxiosResponse): Promise<ProductExportDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductExportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProductExportDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductExportDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reportDevice(body: ReportDeviceInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/ReportDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportDevice(_response);
        });
    }

    protected processReportDevice(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMachineSoftLog(body: PingToServerInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/UpdateMachineSoftLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMachineSoftLog(_response);
        });
    }

    protected processUpdateMachineSoftLog(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getAllProducts(  cancelToken?: CancelToken | undefined): Promise<ProductDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/GetAllProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllProducts(_response);
        });
    }

    protected processGetAllProducts(response: AxiosResponse): Promise<ProductDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<ProductDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDtoListResultDto>(null as any);
    }

    /**
     * @param deviceID (optional) 
     * @return Success
     */
    getSlotsUpdateMachineDetail(deviceID: string | undefined , cancelToken?: CancelToken | undefined): Promise<UpdateMachineDetailSetting> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/GetSlotsUpdateMachineDetail?";
        if (deviceID === null)
            throw new Error("The parameter 'deviceID' cannot be null.");
        else if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSlotsUpdateMachineDetail(_response);
        });
    }

    protected processGetSlotsUpdateMachineDetail(response: AxiosResponse): Promise<UpdateMachineDetailSetting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateMachineDetailSetting.fromJS(resultData200.result);
            return Promise.resolve<UpdateMachineDetailSetting>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMachineDetailSetting>(null as any);
    }

    /**
     * @param deviceID (optional) 
     * @return Success
     */
    getLastestUpdateForUpgradeMachine(deviceID: string | undefined , cancelToken?: CancelToken | undefined): Promise<MachineSoftDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/GetLastestUpdateForUpgradeMachine?";
        if (deviceID === null)
            throw new Error("The parameter 'deviceID' cannot be null.");
        else if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLastestUpdateForUpgradeMachine(_response);
        });
    }

    protected processGetLastestUpdateForUpgradeMachine(response: AxiosResponse): Promise<MachineSoftDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineSoftDto.fromJS(resultData200.result);
            return Promise.resolve<MachineSoftDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineSoftDto>(null as any);
    }

    /**
     * @param deviceID (optional) 
     * @return Success
     */
    getAllFileMediaOfMachine(deviceID: string | undefined , cancelToken?: CancelToken | undefined): Promise<AttachmentItemListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/GetAllFileMediaOfMachine?";
        if (deviceID === null)
            throw new Error("The parameter 'deviceID' cannot be null.");
        else if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFileMediaOfMachine(_response);
        });
    }

    protected processGetAllFileMediaOfMachine(response: AxiosResponse): Promise<AttachmentItemListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttachmentItemListResultDto.fromJS(resultData200.result);
            return Promise.resolve<AttachmentItemListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentItemListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createQRPayment(body: CreateQRCodePaymentInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CreateQRPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateQRPayment(_response);
        });
    }

    protected processCreateQRPayment(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param bi_code (optional) 
     * @return Success
     */
    checkoutQRPayment(bi_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<CheckoutQRCodePaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CheckoutQRPayment?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckoutQRPayment(_response);
        });
    }

    protected processCheckoutQRPayment(response: AxiosResponse): Promise<CheckoutQRCodePaymentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckoutQRCodePaymentDto.fromJS(resultData200.result);
            return Promise.resolve<CheckoutQRCodePaymentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckoutQRCodePaymentDto>(null as any);
    }

    /**
     * @param bi_code (optional) 
     * @return Success
     */
    createRefundQRPayment(bi_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CreateRefundQRPayment?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRefundQRPayment(_response);
        });
    }

    protected processCreateRefundQRPayment(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param bi_code (optional) 
     * @return Success
     */
    checkRefundQRPayment(bi_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CheckRefundQRPayment?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckRefundQRPayment(_response);
        });
    }

    protected processCheckRefundQRPayment(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rifdPayment(body: CheckRifdPaymentInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckoutRifdPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/RifdPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRifdPayment(_response);
        });
    }

    protected processRifdPayment(response: AxiosResponse): Promise<CheckoutRifdPaymentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckoutRifdPaymentDto.fromJS(resultData200.result);
            return Promise.resolve<CheckoutRifdPaymentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckoutRifdPaymentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyCodeDiscount(body: CheckCodeDiscountInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplyDiscountDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/ApplyCodeDiscount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplyCodeDiscount(_response);
        });
    }

    protected processApplyCodeDiscount(response: AxiosResponse): Promise<ApplyDiscountDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplyDiscountDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<ApplyDiscountDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplyDiscountDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBilling(body: CreateBillingInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CreateBilling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBilling(_response);
        });
    }

    protected processCreateBilling(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRefund(body: CreateRefundInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CreateRefund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRefund(_response);
        });
    }

    protected processCreateRefund(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSwallowCashMachine(body: CreateSwallowCashMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/CreateSwallowCashMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSwallowCashMachine(_response);
        });
    }

    protected processCreateSwallowCashMachine(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePaymentBank(body: UpdatePaymentBankInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Hardware/UpdatePaymentBank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePaymentBank(_response);
        });
    }

    protected processUpdatePaymentBank(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class HardwareTrashbinService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param bi_code (optional) 
     * @param rf_code (optional) 
     * @return Success
     */
    ownAppPayment(bi_code: string | undefined, rf_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<CheckoutRifdPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/HardwareTrashbin/OwnAppPayment?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOwnAppPayment(_response);
        });
    }

    protected processOwnAppPayment(response: AxiosResponse): Promise<CheckoutRifdPaymentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckoutRifdPaymentDto.fromJS(resultData200.result);
            return Promise.resolve<CheckoutRifdPaymentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckoutRifdPaymentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPointToRFID(body: AddPointToRFIDInput | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/HardwareTrashbin/AddPointToRFID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPointToRFID(_response);
        });
    }

    protected processAddPointToRFID(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param rf_code (optional) 
     * @return Success
     */
    getRfidInforByRfidCode(rf_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/HardwareTrashbin/GetRfidInforByRfidCode?";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRfidInforByRfidCode(_response);
        });
    }

    protected processGetRfidInforByRfidCode(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }
}

export class HistoryMVPService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param payment_type (optional) 
     * @param bi_paid_status (optional) 
     * @param bi_code (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    chiTietGiaoDichTheoTungMay(payment_type: BillMethod | undefined, bi_paid_status: EPaidStatus | undefined, bi_code: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HistoryMVP/ChiTietGiaoDichTheoTungMay?";
        if (payment_type === null)
            throw new Error("The parameter 'payment_type' cannot be null.");
        else if (payment_type !== undefined)
            url_ += "payment_type=" + encodeURIComponent("" + payment_type) + "&";
        if (bi_paid_status === null)
            throw new Error("The parameter 'bi_paid_status' cannot be null.");
        else if (bi_paid_status !== undefined)
            url_ += "bi_paid_status=" + encodeURIComponent("" + bi_paid_status) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChiTietGiaoDichTheoTungMay(_response);
        });
    }

    protected processChiTietGiaoDichTheoTungMay(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param payment_type (optional) 
     * @param bi_paid_status (optional) 
     * @param bi_code (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    chiTietGiaoDichTheoTungMayAdmin(us_id: number[] | undefined, payment_type: BillMethod | undefined, bi_paid_status: EPaidStatus | undefined, bi_code: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HistoryMVP/ChiTietGiaoDichTheoTungMayAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (payment_type === null)
            throw new Error("The parameter 'payment_type' cannot be null.");
        else if (payment_type !== undefined)
            url_ += "payment_type=" + encodeURIComponent("" + payment_type) + "&";
        if (bi_paid_status === null)
            throw new Error("The parameter 'bi_paid_status' cannot be null.");
        else if (bi_paid_status !== undefined)
            url_ += "bi_paid_status=" + encodeURIComponent("" + bi_paid_status) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChiTietGiaoDichTheoTungMayAdmin(_response);
        });
    }

    protected processChiTietGiaoDichTheoTungMayAdmin(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }

    /**
     * @param re_status (optional) 
     * @param re_level (optional) 
     * @param bi_code (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    lichSuCanhBao(re_status: ReportStatus | undefined, re_level: ReportLevel | undefined, bi_code: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HistoryMVP/LichSuCanhBao?";
        if (re_status === null)
            throw new Error("The parameter 're_status' cannot be null.");
        else if (re_status !== undefined)
            url_ += "re_status=" + encodeURIComponent("" + re_status) + "&";
        if (re_level === null)
            throw new Error("The parameter 're_level' cannot be null.");
        else if (re_level !== undefined)
            url_ += "re_level=" + encodeURIComponent("" + re_level) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLichSuCanhBao(_response);
        });
    }

    protected processLichSuCanhBao(response: AxiosResponse): Promise<ReportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param re_status (optional) 
     * @param re_level (optional) 
     * @param bi_code (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    lichSuCanhBaoAdmin(us_id: number[] | undefined, re_status: ReportStatus | undefined, re_level: ReportLevel | undefined, bi_code: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HistoryMVP/LichSuCanhBaoAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (re_status === null)
            throw new Error("The parameter 're_status' cannot be null.");
        else if (re_status !== undefined)
            url_ += "re_status=" + encodeURIComponent("" + re_status) + "&";
        if (re_level === null)
            throw new Error("The parameter 're_level' cannot be null.");
        else if (re_level !== undefined)
            url_ += "re_level=" + encodeURIComponent("" + re_level) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLichSuCanhBaoAdmin(_response);
        });
    }

    protected processLichSuCanhBaoAdmin(response: AxiosResponse): Promise<ReportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportOfMachineDtoPagedResultDto>(null as any);
    }
}

export class HostSettingsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getAllSettings(  cancelToken?: CancelToken | undefined): Promise<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSettings(_response);
        });
    }

    protected processGetAllSettings(response: AxiosResponse): Promise<HostSettingsEditDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HostSettingsEditDto.fromJS(resultData200.result);
            return Promise.resolve<HostSettingsEditDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostSettingsEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAllSettings(_response);
        });
    }

    protected processUpdateAllSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTestEmail(_response);
        });
    }

    protected processSendTestEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnabledSocialLoginSettings(_response);
        });
    }

    protected processGetEnabledSocialLoginSettings(response: AxiosResponse): Promise<ExternalLoginSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalLoginSettingsDto.fromJS(resultData200.result);
            return Promise.resolve<ExternalLoginSettingsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginSettingsDto>(null as any);
    }
}

export class ImageProductService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param im_pr_name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(im_pr_name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ImageProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/GetAll?";
        if (im_pr_name === null)
            throw new Error("The parameter 'im_pr_name' cannot be null.");
        else if (im_pr_name !== undefined)
            url_ += "im_pr_name=" + encodeURIComponent("" + im_pr_name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ImageProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImageProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ImageProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImageProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param fileName (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFiles(fileName: string | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ImageProductDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/CreateFiles?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFiles(_response);
        });
    }

    protected processCreateFiles(response: AxiosResponse): Promise<ImageProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImageProductDto.fromJS(resultData200.result);
            return Promise.resolve<ImageProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImageProductDto>(null as any);
    }

    /**
     * @param fi_id (optional) 
     * @return Success
     */
    delete(fi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/Delete?";
        if (fi_id === null)
            throw new Error("The parameter 'fi_id' cannot be null.");
        else if (fi_id !== undefined)
            url_ += "fi_id=" + encodeURIComponent("" + fi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param fi_id_list (optional) 
     * @return Success
     */
    deleteMulti(fi_id_list: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/DeleteMulti?";
        if (fi_id_list === null)
            throw new Error("The parameter 'fi_id_list' cannot be null.");
        else if (fi_id_list !== undefined)
            fi_id_list && fi_id_list.forEach(item => { url_ += "fi_id_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renameFile(body: RenameFileInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ImageProduct/RenameFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRenameFile(_response);
        });
    }

    protected processRenameFile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ImportingService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id_list (optional) 
     * @param im_person_charge (optional) 
     * @param im_start_date (optional) 
     * @param im_end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_id_list: number[] | undefined, im_person_charge: string | undefined, im_start_date: Date | undefined, im_end_date: Date | undefined, gr_ma_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ImportingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Importing/GetAll?";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (im_person_charge === null)
            throw new Error("The parameter 'im_person_charge' cannot be null.");
        else if (im_person_charge !== undefined)
            url_ += "im_person_charge=" + encodeURIComponent("" + im_person_charge) + "&";
        if (im_start_date === null)
            throw new Error("The parameter 'im_start_date' cannot be null.");
        else if (im_start_date !== undefined)
            url_ += "im_start_date=" + encodeURIComponent(im_start_date ? "" + im_start_date.toISOString() : "") + "&";
        if (im_end_date === null)
            throw new Error("The parameter 'im_end_date' cannot be null.");
        else if (im_end_date !== undefined)
            url_ += "im_end_date=" + encodeURIComponent(im_end_date ? "" + im_end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ImportingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImportingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ImportingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportingDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param ma_id_list (optional) 
     * @param im_person_charge (optional) 
     * @param im_start_date (optional) 
     * @param im_end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllForAdmin(us_id: number[] | undefined, ma_id_list: number[] | undefined, im_person_charge: string | undefined, im_start_date: Date | undefined, im_end_date: Date | undefined, gr_ma_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ImportingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Importing/GetAllForAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (im_person_charge === null)
            throw new Error("The parameter 'im_person_charge' cannot be null.");
        else if (im_person_charge !== undefined)
            url_ += "im_person_charge=" + encodeURIComponent("" + im_person_charge) + "&";
        if (im_start_date === null)
            throw new Error("The parameter 'im_start_date' cannot be null.");
        else if (im_start_date !== undefined)
            url_ += "im_start_date=" + encodeURIComponent(im_start_date ? "" + im_start_date.toISOString() : "") + "&";
        if (im_end_date === null)
            throw new Error("The parameter 'im_end_date' cannot be null.");
        else if (im_end_date !== undefined)
            url_ += "im_end_date=" + encodeURIComponent(im_end_date ? "" + im_end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForAdmin(_response);
        });
    }

    protected processGetAllForAdmin(response: AxiosResponse): Promise<ImportingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImportingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ImportingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateImporting(body: UpdateImportingInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Importing/UpdateImporting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateImporting(_response);
        });
    }

    protected processUpdateImporting(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ImportRepositoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param im_re_code (optional) 
     * @param re_id (optional) 
     * @param us_id_import (optional) 
     * @param im_re_status (optional) 
     * @param su_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(im_re_code: string | undefined, re_id: number | undefined, us_id_import: number | undefined, im_re_status: EImportRepositoryStatus | undefined, su_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ImportRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ImportRepository/GetAll?";
        if (im_re_code === null)
            throw new Error("The parameter 'im_re_code' cannot be null.");
        else if (im_re_code !== undefined)
            url_ += "im_re_code=" + encodeURIComponent("" + im_re_code) + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (us_id_import === null)
            throw new Error("The parameter 'us_id_import' cannot be null.");
        else if (us_id_import !== undefined)
            url_ += "us_id_import=" + encodeURIComponent("" + us_id_import) + "&";
        if (im_re_status === null)
            throw new Error("The parameter 'im_re_status' cannot be null.");
        else if (im_re_status !== undefined)
            url_ += "im_re_status=" + encodeURIComponent("" + im_re_status) + "&";
        if (su_id_list === null)
            throw new Error("The parameter 'su_id_list' cannot be null.");
        else if (su_id_list !== undefined)
            su_id_list && su_id_list.forEach(item => { url_ += "su_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ImportRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImportRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ImportRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createImportRepository(body: CreateImportRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<ImportRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ImportRepository/CreateImportRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateImportRepository(_response);
        });
    }

    protected processCreateImportRepository(response: AxiosResponse): Promise<ImportRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImportRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<ImportRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportRepositoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateImportRepository(body: UpdateImportRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<ImportRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ImportRepository/UpdateImportRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateImportRepository(_response);
        });
    }

    protected processUpdateImportRepository(response: AxiosResponse): Promise<ImportRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ImportRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<ImportRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportRepositoryDto>(null as any);
    }

    /**
     * @param im_re_id (optional) 
     * @return Success
     */
    delete(im_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/ImportRepository/Delete?";
        if (im_re_id === null)
            throw new Error("The parameter 'im_re_id' cannot be null.");
        else if (im_re_id !== undefined)
            url_ += "im_re_id=" + encodeURIComponent("" + im_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param im_re_id_list (optional) 
     * @return Success
     */
    deleteMulti(im_re_id_list: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/ImportRepository/DeleteMulti?";
        if (im_re_id_list === null)
            throw new Error("The parameter 'im_re_id_list' cannot be null.");
        else if (im_re_id_list !== undefined)
            im_re_id_list && im_re_id_list.forEach(item => { url_ += "im_re_id_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LayoutService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param la_name (optional) 
     * @param la_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(la_name: string | undefined, la_type: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<LayoutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Layout/GetAll?";
        if (la_name === null)
            throw new Error("The parameter 'la_name' cannot be null.");
        else if (la_name !== undefined)
            url_ += "la_name=" + encodeURIComponent("" + la_name) + "&";
        if (la_type === null)
            throw new Error("The parameter 'la_type' cannot be null.");
        else if (la_type !== undefined)
            url_ += "la_type=" + encodeURIComponent("" + la_type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<LayoutDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LayoutDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<LayoutDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LayoutDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createLayout(body: CreateLayoutInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Layout/CreateLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateLayout(_response);
        });
    }

    protected processCreateLayout(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLayout(body: UpdateLayoutInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Layout/UpdateLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateLayout(_response);
        });
    }

    protected processUpdateLayout(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Layout/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMulti(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Layout/DeleteMulti?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Layout/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class LossRepositoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param lo_re_code (optional) 
     * @param us_id_import (optional) 
     * @param re_id (optional) 
     * @param lo_re_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(lo_re_code: string | undefined, us_id_import: number | undefined, re_id: number | undefined, lo_re_status: ELossRepositoryStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<LossRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/GetAll?";
        if (lo_re_code === null)
            throw new Error("The parameter 'lo_re_code' cannot be null.");
        else if (lo_re_code !== undefined)
            url_ += "lo_re_code=" + encodeURIComponent("" + lo_re_code) + "&";
        if (us_id_import === null)
            throw new Error("The parameter 'us_id_import' cannot be null.");
        else if (us_id_import !== undefined)
            url_ += "us_id_import=" + encodeURIComponent("" + us_id_import) + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (lo_re_status === null)
            throw new Error("The parameter 'lo_re_status' cannot be null.");
        else if (lo_re_status !== undefined)
            url_ += "lo_re_status=" + encodeURIComponent("" + lo_re_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<LossRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LossRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<LossRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LossRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param re_id (optional) 
     * @return Success
     */
    getAllProductInRepository(re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ProductAbstractDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/GetAllProductInRepository?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllProductInRepository(_response);
        });
    }

    protected processGetAllProductInRepository(response: AxiosResponse): Promise<ProductAbstractDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductAbstractDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ProductAbstractDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductAbstractDtoPagedResultDto>(null as any);
    }

    /**
     * @param lo_re_code (optional) 
     * @param us_id_import (optional) 
     * @param re_id (optional) 
     * @param lo_re_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(lo_re_code: string | undefined, us_id_import: number | undefined, re_id: number | undefined, lo_re_status: ELossRepositoryStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<LossRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/GetAllByAdmin?";
        if (lo_re_code === null)
            throw new Error("The parameter 'lo_re_code' cannot be null.");
        else if (lo_re_code !== undefined)
            url_ += "lo_re_code=" + encodeURIComponent("" + lo_re_code) + "&";
        if (us_id_import === null)
            throw new Error("The parameter 'us_id_import' cannot be null.");
        else if (us_id_import !== undefined)
            url_ += "us_id_import=" + encodeURIComponent("" + us_id_import) + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (lo_re_status === null)
            throw new Error("The parameter 'lo_re_status' cannot be null.");
        else if (lo_re_status !== undefined)
            url_ += "lo_re_status=" + encodeURIComponent("" + lo_re_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<LossRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LossRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<LossRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LossRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createLossRepository(body: CreateLossRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<LossRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/CreateLossRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateLossRepository(_response);
        });
    }

    protected processCreateLossRepository(response: AxiosResponse): Promise<LossRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LossRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<LossRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LossRepositoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLossRepository(body: UpdateLossRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<LossRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/UpdateLossRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateLossRepository(_response);
        });
    }

    protected processUpdateLossRepository(response: AxiosResponse): Promise<LossRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LossRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<LossRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LossRepositoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatus(body: ChangeStatusLossRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param lo_re_id (optional) 
     * @return Success
     */
    delete(lo_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/Delete?";
        if (lo_re_id === null)
            throw new Error("The parameter 'lo_re_id' cannot be null.");
        else if (lo_re_id !== undefined)
            url_ += "lo_re_id=" + encodeURIComponent("" + lo_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param lo_re_id_list (optional) 
     * @return Success
     */
    deleteMulti(lo_re_id_list: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/LossRepository/DeleteMulti?";
        if (lo_re_id_list === null)
            throw new Error("The parameter 'lo_re_id_list' cannot be null.");
        else if (lo_re_id_list !== undefined)
            lo_re_id_list && lo_re_id_list.forEach(item => { url_ += "lo_re_id_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MachineService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id_list (optional) 
     * @param gr_ma_id (optional) 
     * @param machineNetworkStatus (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_id_list: number[] | undefined, gr_ma_id: number | undefined, machineNetworkStatus: MachineNetworkStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/GetAll?";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (machineNetworkStatus === null)
            throw new Error("The parameter 'machineNetworkStatus' cannot be null.");
        else if (machineNetworkStatus !== undefined)
            url_ += "machineNetworkStatus=" + encodeURIComponent("" + machineNetworkStatus) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param devID (optional) 
     * @return Success
     */
    getAllLogCat(devID: string | undefined , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Machine/GetAllLogCat?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "DevID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLogCat(_response);
        });
    }

    protected processGetAllLogCat(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUserOwer(body: ChangeUserOwnerInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/ChangeUserOwer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeUserOwer(_response);
        });
    }

    protected processChangeUserOwer(response: AxiosResponse): Promise<MachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param ma_id_list (optional) 
     * @param gr_ma_id (optional) 
     * @param machineNetworkStatus (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(us_id: number[] | undefined, ma_id_list: number[] | undefined, gr_ma_id: number | undefined, machineNetworkStatus: MachineNetworkStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/GetAllByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (machineNetworkStatus === null)
            throw new Error("The parameter 'machineNetworkStatus' cannot be null.");
        else if (machineNetworkStatus !== undefined)
            url_ += "machineNetworkStatus=" + encodeURIComponent("" + machineNetworkStatus) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<MachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMachine(body: UpdateMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/UpdateMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMachine(_response);
        });
    }

    protected processUpdateMachine(response: AxiosResponse): Promise<MachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Machine/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param ma_lo_log_mapName (optional) 
     * @param ma_lo_log_from (optional) 
     * @param ma_lo_log_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLocationLogs(ma_id: number, ma_lo_log_mapName: string | undefined, ma_lo_log_from: Date | undefined, ma_lo_log_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineLocationLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/GetAllLocationLogs?";
        if (ma_id === undefined || ma_id === null)
            throw new Error("The parameter 'ma_id' must be defined and cannot be null.");
        else
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (ma_lo_log_mapName === null)
            throw new Error("The parameter 'ma_lo_log_mapName' cannot be null.");
        else if (ma_lo_log_mapName !== undefined)
            url_ += "ma_lo_log_mapName=" + encodeURIComponent("" + ma_lo_log_mapName) + "&";
        if (ma_lo_log_from === null)
            throw new Error("The parameter 'ma_lo_log_from' cannot be null.");
        else if (ma_lo_log_from !== undefined)
            url_ += "ma_lo_log_from=" + encodeURIComponent(ma_lo_log_from ? "" + ma_lo_log_from.toISOString() : "") + "&";
        if (ma_lo_log_to === null)
            throw new Error("The parameter 'ma_lo_log_to' cannot be null.");
        else if (ma_lo_log_to !== undefined)
            url_ += "ma_lo_log_to=" + encodeURIComponent(ma_lo_log_to ? "" + ma_lo_log_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLocationLogs(_response);
        });
    }

    protected processGetAllLocationLogs(response: AxiosResponse): Promise<MachineLocationLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineLocationLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineLocationLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineLocationLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMachineLocationLog(body: CreateMachineLocationLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineLocationLogDto> {
        let url_ = this.baseUrl + "/api/services/app/Machine/CreateMachineLocationLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMachineLocationLog(_response);
        });
    }

    protected processCreateMachineLocationLog(response: AxiosResponse): Promise<MachineLocationLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineLocationLogDto.fromJS(resultData200.result);
            return Promise.resolve<MachineLocationLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineLocationLogDto>(null as any);
    }
}

export class MachineDetailService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id (optional) 
     * @return Success
     */
    getAll(ma_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDetailDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineDetail/GetAll?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MachineDetailDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDetailDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDetailDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDetailDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMachineDetail(body: UpdateMachineDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineDetail/UpdateMachineDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMachineDetail(_response);
        });
    }

    protected processUpdateMachineDetail(response: AxiosResponse): Promise<MachineDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineDetailDto.fromJS(resultData200.result);
            return Promise.resolve<MachineDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineDetailDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateListMachineDetail(body: UpdateListMachineDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MachineDetail/UpdateListMachineDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateListMachineDetail(_response);
        });
    }

    protected processUpdateListMachineDetail(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class MachineLogsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param entities_id (optional) 
     * @param ma_lo_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(entities_id: number | undefined, ma_lo_type: MachineLogsType | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineLogsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineLogs/GetAll?";
        if (entities_id === null)
            throw new Error("The parameter 'entities_id' cannot be null.");
        else if (entities_id !== undefined)
            url_ += "entities_id=" + encodeURIComponent("" + entities_id) + "&";
        if (ma_lo_type === null)
            throw new Error("The parameter 'ma_lo_type' cannot be null.");
        else if (ma_lo_type !== undefined)
            url_ += "ma_lo_type=" + encodeURIComponent("" + ma_lo_type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MachineLogsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineLogsDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineLogsDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineLogsDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMachineLogs(body: CreateMachineLogsInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineLogsDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineLogs/CreateMachineLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMachineLogs(_response);
        });
    }

    protected processCreateMachineLogs(response: AxiosResponse): Promise<MachineLogsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineLogsDto.fromJS(resultData200.result);
            return Promise.resolve<MachineLogsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineLogsDto>(null as any);
    }
}

export class MachineSoftService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_so_version_name (optional) 
     * @param ma_so_version_code (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_so_version_name: string | undefined, ma_so_version_code: number | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineSoftDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineSoft/GetAll?";
        if (ma_so_version_name === null)
            throw new Error("The parameter 'ma_so_version_name' cannot be null.");
        else if (ma_so_version_name !== undefined)
            url_ += "ma_so_version_name=" + encodeURIComponent("" + ma_so_version_name) + "&";
        if (ma_so_version_code === null)
            throw new Error("The parameter 'ma_so_version_code' cannot be null.");
        else if (ma_so_version_code !== undefined)
            url_ += "ma_so_version_code=" + encodeURIComponent("" + ma_so_version_code) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MachineSoftDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineSoftDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineSoftDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineSoftDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMachineSoft(body: CreateMachineSoftInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineSoftDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineSoft/CreateMachineSoft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMachineSoft(_response);
        });
    }

    protected processCreateMachineSoft(response: AxiosResponse): Promise<MachineSoftDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineSoftDto.fromJS(resultData200.result);
            return Promise.resolve<MachineSoftDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineSoftDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMachineSoft(body: UpdateMachineSoftInput | undefined , cancelToken?: CancelToken | undefined): Promise<MachineSoftDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineSoft/UpdateMachineSoft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMachineSoft(_response);
        });
    }

    protected processUpdateMachineSoft(response: AxiosResponse): Promise<MachineSoftDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineSoftDto.fromJS(resultData200.result);
            return Promise.resolve<MachineSoftDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineSoftDto>(null as any);
    }
}

export class MachineSoftLogsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id (optional) 
     * @param ma_hardware_version_name (optional) 
     * @param ma_hardware_version_code (optional) 
     * @param ma_so_lo_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_id: number | undefined, ma_hardware_version_name: string | undefined, ma_hardware_version_code: number | undefined, ma_so_lo_status: EMachineSoftLogsStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MachineSoftLogsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MachineSoftLogs/GetAll?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (ma_hardware_version_name === null)
            throw new Error("The parameter 'ma_hardware_version_name' cannot be null.");
        else if (ma_hardware_version_name !== undefined)
            url_ += "ma_hardware_version_name=" + encodeURIComponent("" + ma_hardware_version_name) + "&";
        if (ma_hardware_version_code === null)
            throw new Error("The parameter 'ma_hardware_version_code' cannot be null.");
        else if (ma_hardware_version_code !== undefined)
            url_ += "ma_hardware_version_code=" + encodeURIComponent("" + ma_hardware_version_code) + "&";
        if (ma_so_lo_status === null)
            throw new Error("The parameter 'ma_so_lo_status' cannot be null.");
        else if (ma_so_lo_status !== undefined)
            url_ += "ma_so_lo_status=" + encodeURIComponent("" + ma_so_lo_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MachineSoftLogsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MachineSoftLogsDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MachineSoftLogsDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MachineSoftLogsDtoPagedResultDto>(null as any);
    }
}

export class MoMoPaymentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id (optional) 
     * @param tenantId (optional) 
     * @param us_id (optional) 
     * @param orderCode (optional) 
     * @param money (optional) 
     * @param body (optional) 
     * @return Success
     */
    createMoMoQRCode(ma_id: number | undefined, tenantId: number | undefined, us_id: number | undefined, orderCode: string | undefined, money: number | undefined, body: EPaymentFor | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/MoMoPayment/CreateMoMoQRCode?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (orderCode === null)
            throw new Error("The parameter 'orderCode' cannot be null.");
        else if (orderCode !== undefined)
            url_ += "orderCode=" + encodeURIComponent("" + orderCode) + "&";
        if (money === null)
            throw new Error("The parameter 'money' cannot be null.");
        else if (money !== undefined)
            url_ += "money=" + encodeURIComponent("" + money) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMoMoQRCode(_response);
        });
    }

    protected processCreateMoMoQRCode(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkOutMoMoOrder(body: PaymentBank | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentBank> {
        let url_ = this.baseUrl + "/api/services/app/MoMoPayment/CheckOutMoMoOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckOutMoMoOrder(_response);
        });
    }

    protected processCheckOutMoMoOrder(response: AxiosResponse): Promise<PaymentBank> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentBank.fromJS(resultData200.result);
            return Promise.resolve<PaymentBank>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentBank>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRefundMoMoOrder(body: PaymentBank | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/MoMoPayment/CreateRefundMoMoOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRefundMoMoOrder(_response);
        });
    }

    protected processCreateRefundMoMoOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkRefundMoMoOrder(body: PaymentBank | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/MoMoPayment/CheckRefundMoMoOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckRefundMoMoOrder(_response);
        });
    }

    protected processCheckRefundMoMoOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOrderID(input: { [key: string]: string; } | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/MoMoPayment/getOrderID?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderID(_response);
        });
    }

    protected processGetOrderID(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class NotificationService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getUserNotifications(skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PageResultNotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserNotifications(_response);
        });
    }

    protected processGetUserNotifications(response: AxiosResponse): Promise<PageResultNotificationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageResultNotificationDto.fromJS(resultData200.result);
            return Promise.resolve<PageResultNotificationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageResultNotificationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStateNotification(body: UpdateStateNotificationInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateStateNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStateNotification(_response);
        });
    }

    protected processUpdateStateNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param typeNotification (optional) 
     * @return Success
     */
    updateAllStateNotification(typeNotification: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateAllStateNotification?";
        if (typeNotification === null)
            throw new Error("The parameter 'typeNotification' cannot be null.");
        else if (typeNotification !== undefined)
            url_ += "TypeNotification=" + encodeURIComponent("" + typeNotification) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAllStateNotification(_response);
        });
    }

    protected processUpdateAllStateNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class OrganizationUnitService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getOrganizationUnits(  cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnits(_response);
        });
    }

    protected processGetOrganizationUnits(response: AxiosResponse): Promise<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnitUsers(_response);
        });
    }

    protected processGetOrganizationUnitUsers(response: AxiosResponse): Promise<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitUserListDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitUserListDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitRoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnitRoles(_response);
        });
    }

    protected processGetOrganizationUnitRoles(response: AxiosResponse): Promise<OrganizationUnitRoleListDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitRoleListDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitRoleListDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitRoleListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrganizationUnit(_response);
        });
    }

    protected processCreateOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrganizationUnit(_response);
        });
    }

    protected processUpdateOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMoveOrganizationUnit(_response);
        });
    }

    protected processMoveOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteOrganizationUnit(_response);
        });
    }

    protected processDeleteOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveUserFromOrganizationUnit(_response);
        });
    }

    protected processRemoveUserFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveRoleFromOrganizationUnit(_response);
        });
    }

    protected processRemoveRoleFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUsersToOrganizationUnit(_response);
        });
    }

    protected processAddUsersToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddRolesToOrganizationUnit(_response);
        });
    }

    protected processAddRolesToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined , cancelToken?: CancelToken | undefined): Promise<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: AxiosResponse): Promise<NameValueDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NameValueDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<NameValueDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameValueDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindRoles(_response);
        });
    }

    protected processFindRoles(response: AxiosResponse): Promise<NameValueDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NameValueDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<NameValueDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameValueDtoPagedResultDto>(null as any);
    }
}

export class PaymentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param input (optional) 
     * @return Success
     */
    vCBPayment(input: { [key: string]: string; } | undefined , cancelToken?: CancelToken | undefined): Promise<HttpContext> {
        let url_ = this.baseUrl + "/api/services/app/Payment/VCBPayment?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVCBPayment(_response);
        });
    }

    protected processVCBPayment(response: AxiosResponse): Promise<HttpContext> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HttpContext.fromJS(resultData200.result);
            return Promise.resolve<HttpContext>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HttpContext>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    vNPayPayment(body: VNPayPaymentInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/VNPayPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVNPayPayment(_response);
        });
    }

    protected processVNPayPayment(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moMoPayment(body: { [key: string]: string; } | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/MoMoPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMoMoPayment(_response);
        });
    }

    protected processMoMoPayment(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param tenant_id (optional) 
     * @param us_id_login (optional) 
     * @param ma_code (optional) 
     * @param money (optional) 
     * @param method (optional) 
     * @return Success
     */
    testNotification(tenant_id: number | undefined, us_id_login: number | undefined, ma_code: string | undefined, money: number | undefined, method: BillMethod | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/TestNotification?";
        if (tenant_id === null)
            throw new Error("The parameter 'tenant_id' cannot be null.");
        else if (tenant_id !== undefined)
            url_ += "tenant_id=" + encodeURIComponent("" + tenant_id) + "&";
        if (us_id_login === null)
            throw new Error("The parameter 'us_id_login' cannot be null.");
        else if (us_id_login !== undefined)
            url_ += "us_id_login=" + encodeURIComponent("" + us_id_login) + "&";
        if (ma_code === null)
            throw new Error("The parameter 'ma_code' cannot be null.");
        else if (ma_code !== undefined)
            url_ += "ma_code=" + encodeURIComponent("" + ma_code) + "&";
        if (money === null)
            throw new Error("The parameter 'money' cannot be null.");
        else if (money !== undefined)
            url_ += "money=" + encodeURIComponent("" + money) + "&";
        if (method === null)
            throw new Error("The parameter 'method' cannot be null.");
        else if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTestNotification(_response);
        });
    }

    protected processTestNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class PaymentBankService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param bi_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param pa_ba_status (optional) 
     * @param pa_ba_bankId (optional) 
     * @param pa_ba_created_from (optional) 
     * @param pa_ba_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(bi_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, pa_ba_status: EPaymentStatus | undefined, pa_ba_bankId: EBank | undefined, pa_ba_created_from: Date | undefined, pa_ba_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentBank/GetAll?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (pa_ba_status === null)
            throw new Error("The parameter 'pa_ba_status' cannot be null.");
        else if (pa_ba_status !== undefined)
            url_ += "pa_ba_status=" + encodeURIComponent("" + pa_ba_status) + "&";
        if (pa_ba_bankId === null)
            throw new Error("The parameter 'pa_ba_bankId' cannot be null.");
        else if (pa_ba_bankId !== undefined)
            url_ += "pa_ba_bankId=" + encodeURIComponent("" + pa_ba_bankId) + "&";
        if (pa_ba_created_from === null)
            throw new Error("The parameter 'pa_ba_created_from' cannot be null.");
        else if (pa_ba_created_from !== undefined)
            url_ += "pa_ba_created_from=" + encodeURIComponent(pa_ba_created_from ? "" + pa_ba_created_from.toISOString() : "") + "&";
        if (pa_ba_created_to === null)
            throw new Error("The parameter 'pa_ba_created_to' cannot be null.");
        else if (pa_ba_created_to !== undefined)
            url_ += "pa_ba_created_to=" + encodeURIComponent(pa_ba_created_to ? "" + pa_ba_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PaymentBankDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentBankDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PaymentBankDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentBankDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param bi_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param pa_ba_status (optional) 
     * @param pa_ba_bankId (optional) 
     * @param pa_ba_created_from (optional) 
     * @param pa_ba_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(us_id: number[] | undefined, bi_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, pa_ba_status: EPaymentStatus | undefined, pa_ba_bankId: EBank | undefined, pa_ba_created_from: Date | undefined, pa_ba_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentBank/GetAllByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (pa_ba_status === null)
            throw new Error("The parameter 'pa_ba_status' cannot be null.");
        else if (pa_ba_status !== undefined)
            url_ += "pa_ba_status=" + encodeURIComponent("" + pa_ba_status) + "&";
        if (pa_ba_bankId === null)
            throw new Error("The parameter 'pa_ba_bankId' cannot be null.");
        else if (pa_ba_bankId !== undefined)
            url_ += "pa_ba_bankId=" + encodeURIComponent("" + pa_ba_bankId) + "&";
        if (pa_ba_created_from === null)
            throw new Error("The parameter 'pa_ba_created_from' cannot be null.");
        else if (pa_ba_created_from !== undefined)
            url_ += "pa_ba_created_from=" + encodeURIComponent(pa_ba_created_from ? "" + pa_ba_created_from.toISOString() : "") + "&";
        if (pa_ba_created_to === null)
            throw new Error("The parameter 'pa_ba_created_to' cannot be null.");
        else if (pa_ba_created_to !== undefined)
            url_ += "pa_ba_created_to=" + encodeURIComponent(pa_ba_created_to ? "" + pa_ba_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<PaymentBankDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentBankDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PaymentBankDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentBankDtoPagedResultDto>(null as any);
    }
}

export class ProductService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pr_name (optional) 
     * @param pr_is_active (optional) 
     * @param su_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pr_name: string | undefined, pr_is_active: number | undefined, su_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetAll?";
        if (pr_name === null)
            throw new Error("The parameter 'pr_name' cannot be null.");
        else if (pr_name !== undefined)
            url_ += "pr_name=" + encodeURIComponent("" + pr_name) + "&";
        if (pr_is_active === null)
            throw new Error("The parameter 'pr_is_active' cannot be null.");
        else if (pr_is_active !== undefined)
            url_ += "pr_is_active=" + encodeURIComponent("" + pr_is_active) + "&";
        if (su_id_list === null)
            throw new Error("The parameter 'su_id_list' cannot be null.");
        else if (su_id_list !== undefined)
            su_id_list && su_id_list.forEach(item => { url_ += "su_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductInput | undefined , cancelToken?: CancelToken | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: AxiosResponse): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDto.fromJS(resultData200.result);
            return Promise.resolve<ProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListProduct(body: CreateProductInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateListProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListProduct(_response);
        });
    }

    protected processCreateListProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductInput | undefined , cancelToken?: CancelToken | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: AxiosResponse): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDto.fromJS(resultData200.result);
            return Promise.resolve<ProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activeOrDeactive(body: ActiveOrDeactiveProductInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Product/ActiveOrDeactive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActiveOrDeactive(_response);
        });
    }

    protected processActiveOrDeactive(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ReconcileService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param rec_from (optional) 
     * @param rec_to (optional) 
     * @param us_is_list (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllReconcileCashByAdmin(gr_ma_id: number | undefined, ma_id_list: number[] | undefined, rec_from: Date | undefined, rec_to: Date | undefined, us_is_list: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllReconcileCashByAdmin?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rec_from === null)
            throw new Error("The parameter 'rec_from' cannot be null.");
        else if (rec_from !== undefined)
            url_ += "rec_from=" + encodeURIComponent(rec_from ? "" + rec_from.toISOString() : "") + "&";
        if (rec_to === null)
            throw new Error("The parameter 'rec_to' cannot be null.");
        else if (rec_to !== undefined)
            url_ += "rec_to=" + encodeURIComponent(rec_to ? "" + rec_to.toISOString() : "") + "&";
        if (us_is_list === null)
            throw new Error("The parameter 'us_is_list' cannot be null.");
        else if (us_is_list !== undefined)
            us_is_list && us_is_list.forEach(item => { url_ += "us_is_list=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllReconcileCashByAdmin(_response);
        });
    }

    protected processGetAllReconcileCashByAdmin(response: AxiosResponse): Promise<ReconcileDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeReasonAndStatusReconcile(body: ChangeReasonAndStatusReconcileInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ChangeReasonAndStatusReconcile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeReasonAndStatusReconcile(_response);
        });
    }

    protected processChangeReasonAndStatusReconcile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeReasonAndStatusReconcileOfExcel(body: ChangeReasonAndStatusReconcileInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ChangeReasonAndStatusReconcileOfExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeReasonAndStatusReconcileOfExcel(_response);
        });
    }

    protected processChangeReasonAndStatusReconcileOfExcel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param rec_id (optional) 
     * @return Success
     */
    confirmReconcile(rec_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ConfirmReconcile?";
        if (rec_id === null)
            throw new Error("The parameter 'rec_id' cannot be null.");
        else if (rec_id !== undefined)
            url_ += "rec_id=" + encodeURIComponent("" + rec_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmReconcile(_response);
        });
    }

    protected processConfirmReconcile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReconcile(body: UpdateReconcileInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/UpdateReconcile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateReconcile(_response);
        });
    }

    protected processUpdateReconcile(response: AxiosResponse): Promise<ReconcileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmMultiReconcile(body: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ConfirmMultiReconcile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmMultiReconcile(_response);
        });
    }

    protected processConfirmMultiReconcile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param recb_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBankReconcile(start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, recb_status: EReconcileStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllBankReconcile?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (recb_status === null)
            throw new Error("The parameter 'recb_status' cannot be null.");
        else if (recb_status !== undefined)
            url_ += "recb_status=" + encodeURIComponent("" + recb_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllBankReconcile(_response);
        });
    }

    protected processGetAllBankReconcile(response: AxiosResponse): Promise<ReconcileBankDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileBankDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileBankDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileBankDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id_list (optional) 
     * @param rec_month (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param recb_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBankReconcileByAdmin(us_id_list: number[] | undefined, rec_month: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, recb_status: EReconcileStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllBankReconcileByAdmin?";
        if (us_id_list === null)
            throw new Error("The parameter 'us_id_list' cannot be null.");
        else if (us_id_list !== undefined)
            us_id_list && us_id_list.forEach(item => { url_ += "us_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rec_month === null)
            throw new Error("The parameter 'rec_month' cannot be null.");
        else if (rec_month !== undefined)
            url_ += "rec_month=" + encodeURIComponent("" + rec_month) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (recb_status === null)
            throw new Error("The parameter 'recb_status' cannot be null.");
        else if (recb_status !== undefined)
            url_ += "recb_status=" + encodeURIComponent("" + recb_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllBankReconcileByAdmin(_response);
        });
    }

    protected processGetAllBankReconcileByAdmin(response: AxiosResponse): Promise<ReconcileBankDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileBankDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileBankDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileBankDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reconcileBank(body: ReconcileBankInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ReconcileBank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconcileBank(_response);
        });
    }

    protected processReconcileBank(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param recb_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRFIDReconcile(start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, recb_status: EReconcileStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllRFIDReconcile?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (recb_status === null)
            throw new Error("The parameter 'recb_status' cannot be null.");
        else if (recb_status !== undefined)
            url_ += "recb_status=" + encodeURIComponent("" + recb_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRFIDReconcile(_response);
        });
    }

    protected processGetAllRFIDReconcile(response: AxiosResponse): Promise<ReconcileBankDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileBankDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileBankDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileBankDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id_list (optional) 
     * @param rec_month (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param recb_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRFIDReconcileByAdmin(us_id_list: number[] | undefined, rec_month: string | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, recb_status: EReconcileStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileRFIDDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllRFIDReconcileByAdmin?";
        if (us_id_list === null)
            throw new Error("The parameter 'us_id_list' cannot be null.");
        else if (us_id_list !== undefined)
            us_id_list && us_id_list.forEach(item => { url_ += "us_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rec_month === null)
            throw new Error("The parameter 'rec_month' cannot be null.");
        else if (rec_month !== undefined)
            url_ += "rec_month=" + encodeURIComponent("" + rec_month) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (recb_status === null)
            throw new Error("The parameter 'recb_status' cannot be null.");
        else if (recb_status !== undefined)
            url_ += "recb_status=" + encodeURIComponent("" + recb_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRFIDReconcileByAdmin(_response);
        });
    }

    protected processGetAllRFIDReconcileByAdmin(response: AxiosResponse): Promise<ReconcileRFIDDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileRFIDDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileRFIDDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileRFIDDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reconcileRFID(body: ReconcileRFIDInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ReconcileRFID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconcileRFID(_response);
        });
    }

    protected processReconcileRFID(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param su_id_list (optional) 
     * @param rec_month (optional) 
     * @param rec_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupplierDebtReconcile(su_id_list: number[] | undefined, rec_month: string | undefined, rec_status: EReconcileStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileSupplierDebtDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/GetAllSupplierDebtReconcile?";
        if (su_id_list === null)
            throw new Error("The parameter 'su_id_list' cannot be null.");
        else if (su_id_list !== undefined)
            su_id_list && su_id_list.forEach(item => { url_ += "su_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rec_month === null)
            throw new Error("The parameter 'rec_month' cannot be null.");
        else if (rec_month !== undefined)
            url_ += "rec_month=" + encodeURIComponent("" + rec_month) + "&";
        if (rec_status === null)
            throw new Error("The parameter 'rec_status' cannot be null.");
        else if (rec_status !== undefined)
            url_ += "rec_status=" + encodeURIComponent("" + rec_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSupplierDebtReconcile(_response);
        });
    }

    protected processGetAllSupplierDebtReconcile(response: AxiosResponse): Promise<ReconcileSupplierDebtDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileSupplierDebtDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileSupplierDebtDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileSupplierDebtDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reconcileSupplierDebt(body: ReconcileSupplierDebtInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ReconcileSupplierDebt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconcileSupplierDebt(_response);
        });
    }

    protected processReconcileSupplierDebt(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeReasonAndStatusReconcileOfSupplierDebtExcel(body: ChangeReasonAndStatusReconcileInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/ChangeReasonAndStatusReconcileOfSupplierDebtExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeReasonAndStatusReconcileOfSupplierDebtExcel(_response);
        });
    }

    protected processChangeReasonAndStatusReconcileOfSupplierDebtExcel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteReconcileSupplierDebt(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Reconcile/DeleteReconcileSupplierDebt?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteReconcileSupplierDebt(_response);
        });
    }

    protected processDeleteReconcileSupplierDebt(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ReconcileLogsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param rec_lo_code (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLogs(rec_lo_code: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReconcileLogsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReconcileLogs/GetAllLogs?";
        if (rec_lo_code === null)
            throw new Error("The parameter 'rec_lo_code' cannot be null.");
        else if (rec_lo_code !== undefined)
            url_ += "rec_lo_code=" + encodeURIComponent("" + rec_lo_code) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLogs(_response);
        });
    }

    protected processGetAllLogs(response: AxiosResponse): Promise<ReconcileLogsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReconcileLogsDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReconcileLogsDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReconcileLogsDtoPagedResultDto>(null as any);
    }
}

export class RefundService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ref_reason_type (optional) 
     * @param ref_status (optional) 
     * @param ref_refund_type (optional) 
     * @param bi_code (optional) 
     * @param ref_namebank (optional) 
     * @param ref_from (optional) 
     * @param ref_to (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ref_reason_type: ERefundReasonType | undefined, ref_status: ERefundStatus | undefined, ref_refund_type: BillMethod | undefined, bi_code: string | undefined, ref_namebank: string | undefined, ref_from: Date | undefined, ref_to: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RefundDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Refund/GetAll?";
        if (ref_reason_type === null)
            throw new Error("The parameter 'ref_reason_type' cannot be null.");
        else if (ref_reason_type !== undefined)
            url_ += "ref_reason_type=" + encodeURIComponent("" + ref_reason_type) + "&";
        if (ref_status === null)
            throw new Error("The parameter 'ref_status' cannot be null.");
        else if (ref_status !== undefined)
            url_ += "ref_status=" + encodeURIComponent("" + ref_status) + "&";
        if (ref_refund_type === null)
            throw new Error("The parameter 'ref_refund_type' cannot be null.");
        else if (ref_refund_type !== undefined)
            url_ += "ref_refund_type=" + encodeURIComponent("" + ref_refund_type) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (ref_namebank === null)
            throw new Error("The parameter 'ref_namebank' cannot be null.");
        else if (ref_namebank !== undefined)
            url_ += "ref_namebank=" + encodeURIComponent("" + ref_namebank) + "&";
        if (ref_from === null)
            throw new Error("The parameter 'ref_from' cannot be null.");
        else if (ref_from !== undefined)
            url_ += "ref_from=" + encodeURIComponent(ref_from ? "" + ref_from.toISOString() : "") + "&";
        if (ref_to === null)
            throw new Error("The parameter 'ref_to' cannot be null.");
        else if (ref_to !== undefined)
            url_ += "ref_to=" + encodeURIComponent(ref_to ? "" + ref_to.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RefundDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RefundDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id_list (optional) 
     * @param ref_reason_type (optional) 
     * @param ref_status (optional) 
     * @param ref_refund_type (optional) 
     * @param bi_code (optional) 
     * @param ref_namebank (optional) 
     * @param ref_from (optional) 
     * @param ref_to (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(us_id_list: number[] | undefined, ref_reason_type: ERefundReasonType | undefined, ref_status: ERefundStatus | undefined, ref_refund_type: BillMethod | undefined, bi_code: string | undefined, ref_namebank: string | undefined, ref_from: Date | undefined, ref_to: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RefundDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Refund/GetAllByAdmin?";
        if (us_id_list === null)
            throw new Error("The parameter 'us_id_list' cannot be null.");
        else if (us_id_list !== undefined)
            us_id_list && us_id_list.forEach(item => { url_ += "us_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (ref_reason_type === null)
            throw new Error("The parameter 'ref_reason_type' cannot be null.");
        else if (ref_reason_type !== undefined)
            url_ += "ref_reason_type=" + encodeURIComponent("" + ref_reason_type) + "&";
        if (ref_status === null)
            throw new Error("The parameter 'ref_status' cannot be null.");
        else if (ref_status !== undefined)
            url_ += "ref_status=" + encodeURIComponent("" + ref_status) + "&";
        if (ref_refund_type === null)
            throw new Error("The parameter 'ref_refund_type' cannot be null.");
        else if (ref_refund_type !== undefined)
            url_ += "ref_refund_type=" + encodeURIComponent("" + ref_refund_type) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (ref_namebank === null)
            throw new Error("The parameter 'ref_namebank' cannot be null.");
        else if (ref_namebank !== undefined)
            url_ += "ref_namebank=" + encodeURIComponent("" + ref_namebank) + "&";
        if (ref_from === null)
            throw new Error("The parameter 'ref_from' cannot be null.");
        else if (ref_from !== undefined)
            url_ += "ref_from=" + encodeURIComponent(ref_from ? "" + ref_from.toISOString() : "") + "&";
        if (ref_to === null)
            throw new Error("The parameter 'ref_to' cannot be null.");
        else if (ref_to !== undefined)
            url_ += "ref_to=" + encodeURIComponent(ref_to ? "" + ref_to.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<RefundDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RefundDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRefund(body: UpdateRefundInput | undefined , cancelToken?: CancelToken | undefined): Promise<RefundDto> {
        let url_ = this.baseUrl + "/api/services/app/Refund/UpdateRefund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRefund(_response);
        });
    }

    protected processUpdateRefund(response: AxiosResponse): Promise<RefundDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundDto.fromJS(resultData200.result);
            return Promise.resolve<RefundDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    setError(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<RefundDto> {
        let url_ = this.baseUrl + "/api/services/app/Refund/SetError?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetError(_response);
        });
    }

    protected processSetError(response: AxiosResponse): Promise<RefundDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundDto.fromJS(resultData200.result);
            return Promise.resolve<RefundDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundDto>(null as any);
    }
}

export class ReportOfMachineService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param re_status (optional) 
     * @param re_level (optional) 
     * @param re_code (optional) 
     * @param bi_code (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @return Success
     */
    getAll(re_status: ReportStatus | undefined, re_level: ReportLevel | undefined, re_code: string | undefined, bi_code: string | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ReportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportOfMachine/GetAll?";
        if (re_status === null)
            throw new Error("The parameter 're_status' cannot be null.");
        else if (re_status !== undefined)
            url_ += "re_status=" + encodeURIComponent("" + re_status) + "&";
        if (re_level === null)
            throw new Error("The parameter 're_level' cannot be null.");
        else if (re_level !== undefined)
            url_ += "re_level=" + encodeURIComponent("" + re_level) + "&";
        if (re_code === null)
            throw new Error("The parameter 're_code' cannot be null.");
        else if (re_code !== undefined)
            url_ += "re_code=" + encodeURIComponent("" + re_code) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ReportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param re_status (optional) 
     * @param re_level (optional) 
     * @param re_code (optional) 
     * @param bi_code (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @return Success
     */
    getAllByAdmin(us_id: number[] | undefined, re_status: ReportStatus | undefined, re_level: ReportLevel | undefined, re_code: string | undefined, bi_code: string | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ReportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportOfMachine/GetAllByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (re_status === null)
            throw new Error("The parameter 're_status' cannot be null.");
        else if (re_status !== undefined)
            url_ += "re_status=" + encodeURIComponent("" + re_status) + "&";
        if (re_level === null)
            throw new Error("The parameter 're_level' cannot be null.");
        else if (re_level !== undefined)
            url_ += "re_level=" + encodeURIComponent("" + re_level) + "&";
        if (re_code === null)
            throw new Error("The parameter 're_code' cannot be null.");
        else if (re_code !== undefined)
            url_ += "re_code=" + encodeURIComponent("" + re_code) + "&";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<ReportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReportOfMachine(body: UpdateReportOfMachineInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReportOfMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportOfMachine/UpdateReportOfMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateReportOfMachine(_response);
        });
    }

    protected processUpdateReportOfMachine(response: AxiosResponse): Promise<ReportOfMachineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportOfMachineDto.fromJS(resultData200.result);
            return Promise.resolve<ReportOfMachineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportOfMachineDto>(null as any);
    }
}

export class RepositoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getAll(  cancelToken?: CancelToken | undefined): Promise<RepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Repository/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id_operator (optional) 
     * @return Success
     */
    getAllByAdmin(us_id_operator: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<RepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Repository/GetAllByAdmin?";
        if (us_id_operator === null)
            throw new Error("The parameter 'us_id_operator' cannot be null.");
        else if (us_id_operator !== undefined)
            us_id_operator && us_id_operator.forEach(item => { url_ += "us_id_operator=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<RepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRepository(body: CreateRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Repository/CreateRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRepository(_response);
        });
    }

    protected processCreateRepository(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRepositoryDetail(body: CreateRepositoryDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Repository/CreateRepositoryDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRepositoryDetail(_response);
        });
    }

    protected processCreateRepositoryDetail(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRepository(body: UpdateRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Repository/UpdateRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRepository(_response);
        });
    }

    protected processUpdateRepository(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Repository/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param re_id (optional) 
     * @return Success
     */
    getRepositoryByUsIdAndReCode(us_id: number | undefined, re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/services/app/Repository/GetRepositoryByUsIdAndReCode?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRepositoryByUsIdAndReCode(_response);
        });
    }

    protected processGetRepositoryByUsIdAndReCode(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @return Success
     */
    getRepositoryByUsId(us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/services/app/Repository/GetRepositoryByUsId?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRepositoryByUsId(_response);
        });
    }

    protected processGetRepositoryByUsId(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class RepositoryDetailService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param re_id (optional) 
     * @return Success
     */
    getAll(re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<RepositoryDetailDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RepositoryDetail/GetAll?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RepositoryDetailDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RepositoryDetailDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RepositoryDetailDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RepositoryDetailDtoPagedResultDto>(null as any);
    }
}

export class RfidService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param rf_code (optional) 
     * @param rf_is_active (optional) 
     * @param rf_created_from (optional) 
     * @param rf_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(rf_code: string | undefined, rf_is_active: boolean | undefined, rf_created_from: Date | undefined, rf_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/GetAll?";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        if (rf_is_active === null)
            throw new Error("The parameter 'rf_is_active' cannot be null.");
        else if (rf_is_active !== undefined)
            url_ += "rf_is_active=" + encodeURIComponent("" + rf_is_active) + "&";
        if (rf_created_from === null)
            throw new Error("The parameter 'rf_created_from' cannot be null.");
        else if (rf_created_from !== undefined)
            url_ += "rf_created_from=" + encodeURIComponent(rf_created_from ? "" + rf_created_from.toISOString() : "") + "&";
        if (rf_created_to === null)
            throw new Error("The parameter 'rf_created_to' cannot be null.");
        else if (rf_created_to !== undefined)
            url_ += "rf_created_to=" + encodeURIComponent(rf_created_to ? "" + rf_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RfidDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRfidInput | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: CreateRfidInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateList(_response);
        });
    }

    protected processCreateList(response: AxiosResponse): Promise<RfidDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RfidDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RfidDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeOwner(body: ChangeOwnerRfidInput | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeOwner(_response);
        });
    }

    protected processChangeOwner(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param us_id_owner (optional) 
     * @return Success
     */
    changeOwnerAll(us_id_owner: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeOwnerAll?";
        if (us_id_owner === null)
            throw new Error("The parameter 'us_id_owner' cannot be null.");
        else if (us_id_owner !== undefined)
            url_ += "us_id_owner=" + encodeURIComponent("" + us_id_owner) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeOwnerAll(_response);
        });
    }

    protected processChangeOwnerAll(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeMoney(body: ChangeMoneyRfidInput | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeMoney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeMoney(_response);
        });
    }

    protected processChangeMoney(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param rf_money_current (optional) 
     * @return Success
     */
    changeMoneyAll(rf_money_current: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeMoneyAll?";
        if (rf_money_current === null)
            throw new Error("The parameter 'rf_money_current' cannot be null.");
        else if (rf_money_current !== undefined)
            url_ += "rf_money_current=" + encodeURIComponent("" + rf_money_current) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeMoneyAll(_response);
        });
    }

    protected processChangeMoneyAll(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatus(body: UpdateStatusRfidInput | undefined , cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @return Success
     */
    changeStatusAll(  cancelToken?: CancelToken | undefined): Promise<RfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/ChangeStatusAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatusAll(_response);
        });
    }

    protected processChangeStatusAll(response: AxiosResponse): Promise<RfidDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidDto.fromJS(resultData200.result);
            return Promise.resolve<RfidDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAllForUser(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/DeleteAllForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllForUser(_response);
        });
    }

    protected processDeleteAllForUser(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteAllForAdmin(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/DeleteAllForAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllForAdmin(_response);
        });
    }

    protected processDeleteAllForAdmin(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createQrCodeForReChargeRfidMoney(body: RechargeMoneyInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/CreateQrCodeForReChargeRfidMoney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateQrCodeForReChargeRfidMoney(_response);
        });
    }

    protected processCreateQrCodeForReChargeRfidMoney(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param rf_code (optional) 
     * @return Success
     */
    checkoutQRPayment(rf_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<CheckoutQRCodePaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfid/CheckoutQRPayment?";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckoutQRPayment(_response);
        });
    }

    protected processCheckoutQRPayment(response: AxiosResponse): Promise<CheckoutQRCodePaymentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckoutQRCodePaymentDto.fromJS(resultData200.result);
            return Promise.resolve<CheckoutQRCodePaymentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckoutQRCodePaymentDto>(null as any);
    }
}

export class RfidLogsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param rf_lo_action (optional) 
     * @param rf_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param rf_lo_created_from (optional) 
     * @param rf_lo_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLogs(rf_lo_action: ERIFDAction[] | undefined, rf_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, rf_lo_created_from: Date | undefined, rf_lo_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RfidLogs/GetAllLogs?";
        if (rf_lo_action === null)
            throw new Error("The parameter 'rf_lo_action' cannot be null.");
        else if (rf_lo_action !== undefined)
            rf_lo_action && rf_lo_action.forEach(item => { url_ += "rf_lo_action=" + encodeURIComponent("" + item) + "&"; });
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rf_lo_created_from === null)
            throw new Error("The parameter 'rf_lo_created_from' cannot be null.");
        else if (rf_lo_created_from !== undefined)
            url_ += "rf_lo_created_from=" + encodeURIComponent(rf_lo_created_from ? "" + rf_lo_created_from.toISOString() : "") + "&";
        if (rf_lo_created_to === null)
            throw new Error("The parameter 'rf_lo_created_to' cannot be null.");
        else if (rf_lo_created_to !== undefined)
            url_ += "rf_lo_created_to=" + encodeURIComponent(rf_lo_created_to ? "" + rf_lo_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLogs(_response);
        });
    }

    protected processGetAllLogs(response: AxiosResponse): Promise<RfidLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RfidLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param rf_lo_action (optional) 
     * @param rf_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param rf_lo_created_from (optional) 
     * @param rf_lo_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLogsByAdmin(us_id: number[] | undefined, rf_lo_action: ERIFDAction[] | undefined, rf_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, rf_lo_created_from: Date | undefined, rf_lo_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RfidLogs/GetAllLogsByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (rf_lo_action === null)
            throw new Error("The parameter 'rf_lo_action' cannot be null.");
        else if (rf_lo_action !== undefined)
            rf_lo_action && rf_lo_action.forEach(item => { url_ += "rf_lo_action=" + encodeURIComponent("" + item) + "&"; });
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rf_lo_created_from === null)
            throw new Error("The parameter 'rf_lo_created_from' cannot be null.");
        else if (rf_lo_created_from !== undefined)
            url_ += "rf_lo_created_from=" + encodeURIComponent(rf_lo_created_from ? "" + rf_lo_created_from.toISOString() : "") + "&";
        if (rf_lo_created_to === null)
            throw new Error("The parameter 'rf_lo_created_to' cannot be null.");
        else if (rf_lo_created_to !== undefined)
            url_ += "rf_lo_created_to=" + encodeURIComponent(rf_lo_created_to ? "" + rf_lo_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLogsByAdmin(_response);
        });
    }

    protected processGetAllLogsByAdmin(response: AxiosResponse): Promise<RfidLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RfidLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param bi_paid_status (optional) 
     * @param rf_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param rf_lo_created_from (optional) 
     * @param rf_lo_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPaymentLogs(bi_paid_status: EPaidStatus | undefined, rf_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, rf_lo_created_from: Date | undefined, rf_lo_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RfidLogs/GetAllPaymentLogs?";
        if (bi_paid_status === null)
            throw new Error("The parameter 'bi_paid_status' cannot be null.");
        else if (bi_paid_status !== undefined)
            url_ += "bi_paid_status=" + encodeURIComponent("" + bi_paid_status) + "&";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rf_lo_created_from === null)
            throw new Error("The parameter 'rf_lo_created_from' cannot be null.");
        else if (rf_lo_created_from !== undefined)
            url_ += "rf_lo_created_from=" + encodeURIComponent(rf_lo_created_from ? "" + rf_lo_created_from.toISOString() : "") + "&";
        if (rf_lo_created_to === null)
            throw new Error("The parameter 'rf_lo_created_to' cannot be null.");
        else if (rf_lo_created_to !== undefined)
            url_ += "rf_lo_created_to=" + encodeURIComponent(rf_lo_created_to ? "" + rf_lo_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPaymentLogs(_response);
        });
    }

    protected processGetAllPaymentLogs(response: AxiosResponse): Promise<RfidLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RfidLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param bi_paid_status (optional) 
     * @param rf_code (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param rf_lo_created_from (optional) 
     * @param rf_lo_created_to (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPaymentLogsByAdmin(bi_paid_status: EPaidStatus | undefined, rf_code: string | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, rf_lo_created_from: Date | undefined, rf_lo_created_to: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RfidLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RfidLogs/GetAllPaymentLogsByAdmin?";
        if (bi_paid_status === null)
            throw new Error("The parameter 'bi_paid_status' cannot be null.");
        else if (bi_paid_status !== undefined)
            url_ += "bi_paid_status=" + encodeURIComponent("" + bi_paid_status) + "&";
        if (rf_code === null)
            throw new Error("The parameter 'rf_code' cannot be null.");
        else if (rf_code !== undefined)
            url_ += "rf_code=" + encodeURIComponent("" + rf_code) + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (rf_lo_created_from === null)
            throw new Error("The parameter 'rf_lo_created_from' cannot be null.");
        else if (rf_lo_created_from !== undefined)
            url_ += "rf_lo_created_from=" + encodeURIComponent(rf_lo_created_from ? "" + rf_lo_created_from.toISOString() : "") + "&";
        if (rf_lo_created_to === null)
            throw new Error("The parameter 'rf_lo_created_to' cannot be null.");
        else if (rf_lo_created_to !== undefined)
            url_ += "rf_lo_created_to=" + encodeURIComponent(rf_lo_created_to ? "" + rf_lo_created_to.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPaymentLogsByAdmin(_response);
        });
    }

    protected processGetAllPaymentLogsByAdmin(response: AxiosResponse): Promise<RfidLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RfidLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RfidLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RfidLogDtoPagedResultDto>(null as any);
    }
}

export class RoleService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined , cancelToken?: CancelToken | undefined): Promise<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<RoleListDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleListDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleListDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(  cancelToken?: CancelToken | undefined): Promise<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<PermissionDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PermissionDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PermissionDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleForEdit(_response);
        });
    }

    protected processGetRoleForEdit(response: AxiosResponse): Promise<GetRoleForEditOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRoleForEditOutput.fromJS(resultData200.result);
            return Promise.resolve<GetRoleForEditOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RoleDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoPagedResultDto>(null as any);
    }
}

export class SessionService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(  cancelToken?: CancelToken | undefined): Promise<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentLoginInformations(_response);
        });
    }

    protected processGetCurrentLoginInformations(response: AxiosResponse): Promise<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200.result);
            return Promise.resolve<GetCurrentLoginInformationsOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCurrentLoginInformationsOutput>(null as any);
    }
}

export class StatisticStorageMVPService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param dr_type (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfMachine(dr_type: DrinkType | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfMachine?";
        if (dr_type === null)
            throw new Error("The parameter 'dr_type' cannot be null.");
        else if (dr_type !== undefined)
            url_ += "dr_type=" + encodeURIComponent("" + dr_type) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfMachine(_response);
        });
    }

    protected processStatisticBillingOfMachine(response: AxiosResponse): Promise<StatisticBillingOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param dr_type (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfMachineByAdmin(us_id: number[] | undefined, dr_type: DrinkType | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfMachineByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (dr_type === null)
            throw new Error("The parameter 'dr_type' cannot be null.");
        else if (dr_type !== undefined)
            url_ += "dr_type=" + encodeURIComponent("" + dr_type) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfMachineByAdmin(_response);
        });
    }

    protected processStatisticBillingOfMachineByAdmin(response: AxiosResponse): Promise<StatisticBillingOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param low_price (optional) 
     * @param high_price (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfDrinkProduct(low_price: number | undefined, high_price: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfDrinkProduct?";
        if (low_price === null)
            throw new Error("The parameter 'low_price' cannot be null.");
        else if (low_price !== undefined)
            url_ += "low_price=" + encodeURIComponent("" + low_price) + "&";
        if (high_price === null)
            throw new Error("The parameter 'high_price' cannot be null.");
        else if (high_price !== undefined)
            url_ += "high_price=" + encodeURIComponent("" + high_price) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfDrinkProduct(_response);
        });
    }

    protected processStatisticBillingOfDrinkProduct(response: AxiosResponse): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param low_price (optional) 
     * @param high_price (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfDrinkProductByAdmin(us_id: number[] | undefined, low_price: number | undefined, high_price: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfDrinkProductByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (low_price === null)
            throw new Error("The parameter 'low_price' cannot be null.");
        else if (low_price !== undefined)
            url_ += "low_price=" + encodeURIComponent("" + low_price) + "&";
        if (high_price === null)
            throw new Error("The parameter 'high_price' cannot be null.");
        else if (high_price !== undefined)
            url_ += "high_price=" + encodeURIComponent("" + high_price) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfDrinkProductByAdmin(_response);
        });
    }

    protected processStatisticBillingOfDrinkProductByAdmin(response: AxiosResponse): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param low_price (optional) 
     * @param high_price (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfFreshDrinkProduct(low_price: number | undefined, high_price: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfFreshDrinkProduct?";
        if (low_price === null)
            throw new Error("The parameter 'low_price' cannot be null.");
        else if (low_price !== undefined)
            url_ += "low_price=" + encodeURIComponent("" + low_price) + "&";
        if (high_price === null)
            throw new Error("The parameter 'high_price' cannot be null.");
        else if (high_price !== undefined)
            url_ += "high_price=" + encodeURIComponent("" + high_price) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfFreshDrinkProduct(_response);
        });
    }

    protected processStatisticBillingOfFreshDrinkProduct(response: AxiosResponse): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param low_price (optional) 
     * @param high_price (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfFreshDrinkProductByAdmin(us_id: number[] | undefined, low_price: number | undefined, high_price: number | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfFreshDrinkProductByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (low_price === null)
            throw new Error("The parameter 'low_price' cannot be null.");
        else if (low_price !== undefined)
            url_ += "low_price=" + encodeURIComponent("" + low_price) + "&";
        if (high_price === null)
            throw new Error("The parameter 'high_price' cannot be null.");
        else if (high_price !== undefined)
            url_ += "high_price=" + encodeURIComponent("" + high_price) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfFreshDrinkProductByAdmin(_response);
        });
    }

    protected processStatisticBillingOfFreshDrinkProductByAdmin(response: AxiosResponse): Promise<StatisticBillingOfProductDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param product_name_list (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfProductWithMachine(product_name_list: string[] | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductWithMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfProductWithMachine?";
        if (product_name_list === null)
            throw new Error("The parameter 'product_name_list' cannot be null.");
        else if (product_name_list !== undefined)
            product_name_list && product_name_list.forEach(item => { url_ += "product_name_list=" + encodeURIComponent("" + item) + "&"; });
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfProductWithMachine(_response);
        });
    }

    protected processStatisticBillingOfProductWithMachine(response: AxiosResponse): Promise<StatisticBillingOfProductWithMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductWithMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductWithMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductWithMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param product_name_list (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticBillingOfProductWithMachineByAdmin(us_id: number[] | undefined, product_name_list: string[] | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBillingOfProductWithMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfProductWithMachineByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (product_name_list === null)
            throw new Error("The parameter 'product_name_list' cannot be null.");
        else if (product_name_list !== undefined)
            product_name_list && product_name_list.forEach(item => { url_ += "product_name_list=" + encodeURIComponent("" + item) + "&"; });
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfProductWithMachineByAdmin(_response);
        });
    }

    protected processStatisticBillingOfProductWithMachineByAdmin(response: AxiosResponse): Promise<StatisticBillingOfProductWithMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBillingOfProductWithMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBillingOfProductWithMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBillingOfProductWithMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    statisticBillingOfQuyTieuDungXanh(  cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticBillingOfQuyTieuDungXanh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBillingOfQuyTieuDungXanh(_response);
        });
    }

    protected processStatisticBillingOfQuyTieuDungXanh(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticImportOfMachine(start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticImportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticImportOfMachine?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticImportOfMachine(_response);
        });
    }

    protected processStatisticImportOfMachine(response: AxiosResponse): Promise<StatisticImportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticImportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticImportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticImportOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    statisticImportOfMachineByAdmin(us_id: number[] | undefined, start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticImportOfMachineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/StatisticImportOfMachineByAdmin?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            us_id && us_id.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticImportOfMachineByAdmin(_response);
        });
    }

    protected processStatisticImportOfMachineByAdmin(response: AxiosResponse): Promise<StatisticImportOfMachineDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticImportOfMachineDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticImportOfMachineDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticImportOfMachineDtoPagedResultDto>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param re_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeHangHoaKho1May(start_date: Date | undefined, end_date: Date | undefined, re_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeHangHoaKho1MayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeHangHoaKho1May?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeHangHoaKho1May(_response);
        });
    }

    protected processThongKeHangHoaKho1May(response: AxiosResponse): Promise<ThongKeHangHoaKho1MayDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeHangHoaKho1MayDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeHangHoaKho1MayDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeHangHoaKho1MayDtoPagedResultDto>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param re_id (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeHangHoaKhoNhieuMay(start_date: Date | undefined, end_date: Date | undefined, re_id: number | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeKhoNhieuMayDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeHangHoaKhoNhieuMay?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeHangHoaKhoNhieuMay(_response);
        });
    }

    protected processThongKeHangHoaKhoNhieuMay(response: AxiosResponse): Promise<ThongKeKhoNhieuMayDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeKhoNhieuMayDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeKhoNhieuMayDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeKhoNhieuMayDto>(null as any);
    }

    /**
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param gr_ma_id (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    thongKeNuotTien(start_date: Date | undefined, end_date: Date | undefined, gr_ma_id: number | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeNuotTienDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeNuotTien?";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeNuotTien(_response);
        });
    }

    protected processThongKeNuotTien(response: AxiosResponse): Promise<ThongKeNuotTienDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeNuotTienDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeNuotTienDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeNuotTienDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_ma_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeTongQuanDoanhSoTheoNhomMay(gr_ma_id: number | undefined, start_date: Date | undefined, end_date: Date | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeTongQuanDoanhSoTheoNhomMay?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeTongQuanDoanhSoTheoNhomMay(_response);
        });
    }

    protected processThongKeTongQuanDoanhSoTheoNhomMay(response: AxiosResponse): Promise<ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_ma_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeTongQuanDoanhSoTheoMay(gr_ma_id: number | undefined, start_date: Date | undefined, end_date: Date | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeTongQuanDoanhSoTheoMay?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeTongQuanDoanhSoTheoMay(_response);
        });
    }

    protected processThongKeTongQuanDoanhSoTheoMay(response: AxiosResponse): Promise<ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_ma_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeTongQuanDoanhSoTheoSanPham(gr_ma_id: number | undefined, start_date: Date | undefined, end_date: Date | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeTongQuanDoanhSoTheoSanPham?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeTongQuanDoanhSoTheoSanPham(_response);
        });
    }

    protected processThongKeTongQuanDoanhSoTheoSanPham(response: AxiosResponse): Promise<ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_ma_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param ma_id_list (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @return Success
     */
    thongKeTongQuanDoanhSoTheoLoaiHinhThanhToan(gr_ma_id: number | undefined, start_date: Date | undefined, end_date: Date | undefined, ma_id_list: number[] | undefined, fieldSort: string | undefined, sort: SORT | undefined , cancelToken?: CancelToken | undefined): Promise<ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageMVP/ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToan?";
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processThongKeTongQuanDoanhSoTheoLoaiHinhThanhToan(_response);
        });
    }

    protected processThongKeTongQuanDoanhSoTheoLoaiHinhThanhToan(response: AxiosResponse): Promise<ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto>(null as any);
    }
}

export class SupplierService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param su_search (optional) 
     * @param su_is_active (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(su_search: string | undefined, su_is_active: boolean | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/GetAll?";
        if (su_search === null)
            throw new Error("The parameter 'su_search' cannot be null.");
        else if (su_search !== undefined)
            url_ += "su_search=" + encodeURIComponent("" + su_search) + "&";
        if (su_is_active === null)
            throw new Error("The parameter 'su_is_active' cannot be null.");
        else if (su_is_active !== undefined)
            url_ += "su_is_active=" + encodeURIComponent("" + su_is_active) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<SupplierDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSupplier(body: CreateSupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/CreateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSupplier(_response);
        });
    }

    protected processCreateSupplier(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListSupplier(body: CreateSupplierInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/CreateListSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListSupplier(_response);
        });
    }

    protected processCreateListSupplier(response: AxiosResponse): Promise<SupplierDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SupplierDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSupplier(body: UpdateSupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/UpdateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSupplier(_response);
        });
    }

    protected processUpdateSupplier(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activeOrDeactive(body: ActiveOrDeactiveSupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/ActiveOrDeactive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActiveOrDeactive(_response);
        });
    }

    protected processActiveOrDeactive(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paySupplierDebt(body: PaySupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/PaySupplierDebt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaySupplierDebt(_response);
        });
    }

    protected processPaySupplierDebt(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class TenantService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TenantDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }
}

export class TokenAuthService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param username (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    adminLoginWithoutPassword(username: string | undefined, tenantId: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AdminLoginWithoutPassword?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminLoginWithoutPassword(_response);
        });
    }

    protected processAdminLoginWithoutPassword(response: AxiosResponse): Promise<AuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<AuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultModel>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @return Success
     */
    adminLoginUserWithoutPassword(us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AdminLoginUserWithoutPassword?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminLoginUserWithoutPassword(_response);
        });
    }

    protected processAdminLoginUserWithoutPassword(response: AxiosResponse): Promise<AuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<AuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined , cancelToken?: CancelToken | undefined): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<AuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateForTrashBin(body: AuthenticateModelForTrashBin | undefined , cancelToken?: CancelToken | undefined): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateForTrashBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticateForTrashBin(_response);
        });
    }

    protected processAuthenticateForTrashBin(response: AxiosResponse): Promise<AuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<AuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hardwareAuthenticate(body: HardwareAuthenticateModel | undefined , cancelToken?: CancelToken | undefined): Promise<HardwareAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/HardwareAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHardwareAuthenticate(_response);
        });
    }

    protected processHardwareAuthenticate(response: AxiosResponse): Promise<HardwareAuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HardwareAuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<HardwareAuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HardwareAuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginProviderInfoModelListResultDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExternalAuthenticationProviders(_response);
        });
    }

    protected processGetExternalAuthenticationProviders(response: AxiosResponse): Promise<ExternalLoginProviderInfoModelListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalLoginProviderInfoModelListResultDto.fromJS(resultData200.result);
            return Promise.resolve<ExternalLoginProviderInfoModelListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginProviderInfoModelListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined , cancelToken?: CancelToken | undefined): Promise<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalAuthenticate(_response);
        });
    }

    protected processExternalAuthenticate(response: AxiosResponse): Promise<ExternalAuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<ExternalAuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalAuthenticateResultModel>(null as any);
    }
}

export class TranferRepositoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param re_id (optional) 
     * @param tr_re_code (optional) 
     * @param tr_re_status (optional) 
     * @param re_id_transfer (optional) 
     * @param re_id_receiver (optional) 
     * @param tr_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(re_id: number | undefined, tr_re_code: string | undefined, tr_re_status: ETranferRepositoryStatus | undefined, re_id_transfer: number | undefined, re_id_receiver: number | undefined, tr_status: ETranferStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TranferRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/GetAll?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (tr_re_code === null)
            throw new Error("The parameter 'tr_re_code' cannot be null.");
        else if (tr_re_code !== undefined)
            url_ += "tr_re_code=" + encodeURIComponent("" + tr_re_code) + "&";
        if (tr_re_status === null)
            throw new Error("The parameter 'tr_re_status' cannot be null.");
        else if (tr_re_status !== undefined)
            url_ += "tr_re_status=" + encodeURIComponent("" + tr_re_status) + "&";
        if (re_id_transfer === null)
            throw new Error("The parameter 're_id_transfer' cannot be null.");
        else if (re_id_transfer !== undefined)
            url_ += "re_id_transfer=" + encodeURIComponent("" + re_id_transfer) + "&";
        if (re_id_receiver === null)
            throw new Error("The parameter 're_id_receiver' cannot be null.");
        else if (re_id_receiver !== undefined)
            url_ += "re_id_receiver=" + encodeURIComponent("" + re_id_receiver) + "&";
        if (tr_status === null)
            throw new Error("The parameter 'tr_status' cannot be null.");
        else if (tr_status !== undefined)
            url_ += "tr_status=" + encodeURIComponent("" + tr_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TranferRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranferRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TranferRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranferRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param re_id (optional) 
     * @param tr_re_code (optional) 
     * @param tr_re_status (optional) 
     * @param re_id_transfer (optional) 
     * @param re_id_receiver (optional) 
     * @param tr_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAdmin(re_id: number | undefined, tr_re_code: string | undefined, tr_re_status: ETranferRepositoryStatus | undefined, re_id_transfer: number | undefined, re_id_receiver: number | undefined, tr_status: ETranferStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TranferRepositoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/GetAllAdmin?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        if (tr_re_code === null)
            throw new Error("The parameter 'tr_re_code' cannot be null.");
        else if (tr_re_code !== undefined)
            url_ += "tr_re_code=" + encodeURIComponent("" + tr_re_code) + "&";
        if (tr_re_status === null)
            throw new Error("The parameter 'tr_re_status' cannot be null.");
        else if (tr_re_status !== undefined)
            url_ += "tr_re_status=" + encodeURIComponent("" + tr_re_status) + "&";
        if (re_id_transfer === null)
            throw new Error("The parameter 're_id_transfer' cannot be null.");
        else if (re_id_transfer !== undefined)
            url_ += "re_id_transfer=" + encodeURIComponent("" + re_id_transfer) + "&";
        if (re_id_receiver === null)
            throw new Error("The parameter 're_id_receiver' cannot be null.");
        else if (re_id_receiver !== undefined)
            url_ += "re_id_receiver=" + encodeURIComponent("" + re_id_receiver) + "&";
        if (tr_status === null)
            throw new Error("The parameter 'tr_status' cannot be null.");
        else if (tr_status !== undefined)
            url_ += "tr_status=" + encodeURIComponent("" + tr_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAdmin(_response);
        });
    }

    protected processGetAllAdmin(response: AxiosResponse): Promise<TranferRepositoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranferRepositoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TranferRepositoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranferRepositoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTranferRepository(body: CreateTranferRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<TranferRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/CreateTranferRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTranferRepository(_response);
        });
    }

    protected processCreateTranferRepository(response: AxiosResponse): Promise<TranferRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranferRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<TranferRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranferRepositoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTranferRepository(body: UpdateTranferRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<TranferRepositoryDto> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/UpdateTranferRepository";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTranferRepository(_response);
        });
    }

    protected processUpdateTranferRepository(response: AxiosResponse): Promise<TranferRepositoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranferRepositoryDto.fromJS(resultData200.result);
            return Promise.resolve<TranferRepositoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranferRepositoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatus(body: ChangeStatusTranferRepositoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param tr_re_id (optional) 
     * @return Success
     */
    confirmStatus(tr_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/ConfirmStatus?";
        if (tr_re_id === null)
            throw new Error("The parameter 'tr_re_id' cannot be null.");
        else if (tr_re_id !== undefined)
            url_ += "tr_re_id=" + encodeURIComponent("" + tr_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmStatus(_response);
        });
    }

    protected processConfirmStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param tr_re_id (optional) 
     * @return Success
     */
    receiptProduct(tr_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/ReceiptProduct?";
        if (tr_re_id === null)
            throw new Error("The parameter 'tr_re_id' cannot be null.");
        else if (tr_re_id !== undefined)
            url_ += "tr_re_id=" + encodeURIComponent("" + tr_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiptProduct(_response);
        });
    }

    protected processReceiptProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param tr_re_id (optional) 
     * @return Success
     */
    delete(tr_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/TranferRepository/Delete?";
        if (tr_re_id === null)
            throw new Error("The parameter 'tr_re_id' cannot be null.");
        else if (tr_re_id !== undefined)
            url_ += "tr_re_id=" + encodeURIComponent("" + tr_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TrashBinService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param tr_name (optional) 
     * @param gr_tr_id (optional) 
     * @param deviceMAC (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param tr_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(tr_name: string | undefined, gr_tr_id: number | undefined, deviceMAC: string | undefined, start_date: Date | undefined, end_date: Date | undefined, tr_type: ETrashType[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TrashBinDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrashBin/GetAll?";
        if (tr_name === null)
            throw new Error("The parameter 'tr_name' cannot be null.");
        else if (tr_name !== undefined)
            url_ += "tr_name=" + encodeURIComponent("" + tr_name) + "&";
        if (gr_tr_id === null)
            throw new Error("The parameter 'gr_tr_id' cannot be null.");
        else if (gr_tr_id !== undefined)
            url_ += "gr_tr_id=" + encodeURIComponent("" + gr_tr_id) + "&";
        if (deviceMAC === null)
            throw new Error("The parameter 'deviceMAC' cannot be null.");
        else if (deviceMAC !== undefined)
            url_ += "deviceMAC=" + encodeURIComponent("" + deviceMAC) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (tr_type === null)
            throw new Error("The parameter 'tr_type' cannot be null.");
        else if (tr_type !== undefined)
            tr_type && tr_type.forEach(item => { url_ += "tr_type=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TrashBinDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrashBinDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TrashBinDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrashBinDtoPagedResultDto>(null as any);
    }

    /**
     * @param gr_tr_id (optional) 
     * @param start_date (optional) 
     * @param end_date (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTrashBinLogs(tr_id: number, gr_tr_id: number | undefined, start_date: Date | undefined, end_date: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TrashBinLogsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrashBin/GetAllTrashBinLogs?";
        if (tr_id === undefined || tr_id === null)
            throw new Error("The parameter 'tr_id' must be defined and cannot be null.");
        else
            url_ += "tr_id=" + encodeURIComponent("" + tr_id) + "&";
        if (gr_tr_id === null)
            throw new Error("The parameter 'gr_tr_id' cannot be null.");
        else if (gr_tr_id !== undefined)
            url_ += "gr_tr_id=" + encodeURIComponent("" + gr_tr_id) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (end_date === null)
            throw new Error("The parameter 'end_date' cannot be null.");
        else if (end_date !== undefined)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTrashBinLogs(_response);
        });
    }

    protected processGetAllTrashBinLogs(response: AxiosResponse): Promise<TrashBinLogsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrashBinLogsDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TrashBinLogsDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrashBinLogsDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTrashBin(body: CreateTrashBinInput | undefined , cancelToken?: CancelToken | undefined): Promise<TrashBinDto> {
        let url_ = this.baseUrl + "/api/services/app/TrashBin/CreateTrashBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTrashBin(_response);
        });
    }

    protected processCreateTrashBin(response: AxiosResponse): Promise<TrashBinDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrashBinDto.fromJS(resultData200.result);
            return Promise.resolve<TrashBinDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrashBinDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrashBin(body: UpdateTrashBinInput | undefined , cancelToken?: CancelToken | undefined): Promise<TrashBinDto> {
        let url_ = this.baseUrl + "/api/services/app/TrashBin/UpdateTrashBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTrashBin(_response);
        });
    }

    protected processUpdateTrashBin(response: AxiosResponse): Promise<TrashBinDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrashBinDto.fromJS(resultData200.result);
            return Promise.resolve<TrashBinDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrashBinDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TrashBin/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class UserService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<UserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<UserDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAvataUser(body: UpdateAvataInput | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateAvataUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAvataUser(_response);
        });
    }

    protected processUpdateAvataUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword2(body: UpdatePassword2Input | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword2(_response);
        });
    }

    protected processChangePassword2(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword2(body: UpdatePassword2Input | undefined , cancelToken?: CancelToken | undefined): Promise<CheckPassword2Output> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckPassword2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPassword2(_response);
        });
    }

    protected processCheckPassword2(response: AxiosResponse): Promise<CheckPassword2Output> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckPassword2Output.fromJS(resultData200.result);
            return Promise.resolve<CheckPassword2Output>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckPassword2Output>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPasswordUser(body: UpdatePassword2Input | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckPasswordUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPasswordUser(_response);
        });
    }

    protected processCheckPasswordUser(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeActivate(_response);
        });
    }

    protected processDeActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(  cancelToken?: CancelToken | undefined): Promise<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<RoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeLanguage(_response);
        });
    }

    protected processChangeLanguage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }
}

export class VNPAYPaymentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id (optional) 
     * @param tenantId (optional) 
     * @param us_id (optional) 
     * @param orderCode (optional) 
     * @param money (optional) 
     * @param body (optional) 
     * @return Success
     */
    createVNPayQRCode(ma_id: number | undefined, tenantId: number | undefined, us_id: number | undefined, orderCode: string | undefined, money: number | undefined, body: EPaymentFor | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/VNPAYPayment/CreateVNPayQRCode?";
        if (ma_id === null)
            throw new Error("The parameter 'ma_id' cannot be null.");
        else if (ma_id !== undefined)
            url_ += "ma_id=" + encodeURIComponent("" + ma_id) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (orderCode === null)
            throw new Error("The parameter 'orderCode' cannot be null.");
        else if (orderCode !== undefined)
            url_ += "orderCode=" + encodeURIComponent("" + orderCode) + "&";
        if (money === null)
            throw new Error("The parameter 'money' cannot be null.");
        else if (money !== undefined)
            url_ += "money=" + encodeURIComponent("" + money) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateVNPayQRCode(_response);
        });
    }

    protected processCreateVNPayQRCode(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkOutVNPayOrder(body: PaymentBank | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentBank> {
        let url_ = this.baseUrl + "/api/services/app/VNPAYPayment/CheckOutVNPayOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckOutVNPayOrder(_response);
        });
    }

    protected processCheckOutVNPayOrder(response: AxiosResponse): Promise<PaymentBank> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentBank.fromJS(resultData200.result);
            return Promise.resolve<PaymentBank>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentBank>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refundVNPAYOrder(body: PaymentBank | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/VNPAYPayment/RefundVNPAYOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundVNPAYOrder(_response);
        });
    }

    protected processRefundVNPAYOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param code (optional) 
     * @param message (optional) 
     * @param msgType (optional) 
     * @param txnId (optional) 
     * @param qrTrace (optional) 
     * @param bankCode (optional) 
     * @param mobile (optional) 
     * @param accountNo (optional) 
     * @param amount (optional) 
     * @param payDate (optional) 
     * @param masterMerCode (optional) 
     * @param merchantCode (optional) 
     * @param terminalId (optional) 
     * @param addData (optional) 
     * @param checksum (optional) 
     * @param ccy (optional) 
     * @param address (optional) 
     * @param secretKey (optional) 
     * @param calcChecksum (optional) 
     * @return Success
     */
    getTxnID(code: string | undefined, message: string | undefined, msgType: string | undefined, txnId: string | undefined, qrTrace: string | undefined, bankCode: string | undefined, mobile: string | undefined, accountNo: string | undefined, amount: string | undefined, payDate: string | undefined, masterMerCode: string | undefined, merchantCode: string | undefined, terminalId: string | undefined, addData: AddDataItem[] | undefined, checksum: string | undefined, ccy: string | undefined, address: string | undefined, secretKey: string | undefined, calcChecksum: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/VNPAYPayment/getTxnID?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (msgType === null)
            throw new Error("The parameter 'msgType' cannot be null.");
        else if (msgType !== undefined)
            url_ += "MsgType=" + encodeURIComponent("" + msgType) + "&";
        if (txnId === null)
            throw new Error("The parameter 'txnId' cannot be null.");
        else if (txnId !== undefined)
            url_ += "TxnId=" + encodeURIComponent("" + txnId) + "&";
        if (qrTrace === null)
            throw new Error("The parameter 'qrTrace' cannot be null.");
        else if (qrTrace !== undefined)
            url_ += "QrTrace=" + encodeURIComponent("" + qrTrace) + "&";
        if (bankCode === null)
            throw new Error("The parameter 'bankCode' cannot be null.");
        else if (bankCode !== undefined)
            url_ += "BankCode=" + encodeURIComponent("" + bankCode) + "&";
        if (mobile === null)
            throw new Error("The parameter 'mobile' cannot be null.");
        else if (mobile !== undefined)
            url_ += "Mobile=" + encodeURIComponent("" + mobile) + "&";
        if (accountNo === null)
            throw new Error("The parameter 'accountNo' cannot be null.");
        else if (accountNo !== undefined)
            url_ += "AccountNo=" + encodeURIComponent("" + accountNo) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (payDate === null)
            throw new Error("The parameter 'payDate' cannot be null.");
        else if (payDate !== undefined)
            url_ += "PayDate=" + encodeURIComponent("" + payDate) + "&";
        if (masterMerCode === null)
            throw new Error("The parameter 'masterMerCode' cannot be null.");
        else if (masterMerCode !== undefined)
            url_ += "MasterMerCode=" + encodeURIComponent("" + masterMerCode) + "&";
        if (merchantCode === null)
            throw new Error("The parameter 'merchantCode' cannot be null.");
        else if (merchantCode !== undefined)
            url_ += "MerchantCode=" + encodeURIComponent("" + merchantCode) + "&";
        if (terminalId === null)
            throw new Error("The parameter 'terminalId' cannot be null.");
        else if (terminalId !== undefined)
            url_ += "TerminalId=" + encodeURIComponent("" + terminalId) + "&";
        if (addData === null)
            throw new Error("The parameter 'addData' cannot be null.");
        else if (addData !== undefined)
            addData && addData.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AddData[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (checksum === null)
            throw new Error("The parameter 'checksum' cannot be null.");
        else if (checksum !== undefined)
            url_ += "Checksum=" + encodeURIComponent("" + checksum) + "&";
        if (ccy === null)
            throw new Error("The parameter 'ccy' cannot be null.");
        else if (ccy !== undefined)
            url_ += "Ccy=" + encodeURIComponent("" + ccy) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (secretKey === null)
            throw new Error("The parameter 'secretKey' cannot be null.");
        else if (secretKey !== undefined)
            url_ += "SecretKey=" + encodeURIComponent("" + secretKey) + "&";
        if (calcChecksum === null)
            throw new Error("The parameter 'calcChecksum' cannot be null.");
        else if (calcChecksum !== undefined)
            url_ += "calcChecksum=" + encodeURIComponent("" + calcChecksum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTxnID(_response);
        });
    }

    protected processGetTxnID(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class WebhookEventService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<WebhookEvent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WebhookEvent.fromJS(resultData200.result);
            return Promise.resolve<WebhookEvent>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WebhookEvent>(null as any);
    }
}

export class WebhookSendAttemptService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSendAttemptsOutputPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSendAttempts(_response);
        });
    }

    protected processGetAllSendAttempts(response: AxiosResponse): Promise<GetAllSendAttemptsOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSendAttemptsOutputPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSendAttemptsOutputPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSendAttemptsOutputPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSendAttemptsOfWebhookEventOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(_response);
        });
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: AxiosResponse): Promise<GetAllSendAttemptsOfWebhookEventOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSendAttemptsOfWebhookEventOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSendAttemptsOfWebhookEventOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSendAttemptsOfWebhookEventOutputListResultDto>(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId === null)
            throw new Error("The parameter 'sendAttemptId' cannot be null.");
        else if (sendAttemptId !== undefined)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResend(_response);
        });
    }

    protected processResend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WebhookSubscriptionService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    publishTestWebhook(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishTestWebhook(_response);
        });
    }

    protected processPublishTestWebhook(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(  cancelToken?: CancelToken | undefined): Promise<GetAllSubscriptionsOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSubscriptions(_response);
        });
    }

    protected processGetAllSubscriptions(response: AxiosResponse): Promise<GetAllSubscriptionsOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSubscriptionsOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | undefined , cancelToken?: CancelToken | undefined): Promise<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscription(_response);
        });
    }

    protected processGetSubscription(response: AxiosResponse): Promise<WebhookSubscription> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WebhookSubscription.fromJS(resultData200.result);
            return Promise.resolve<WebhookSubscription>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WebhookSubscription>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSubscription(_response);
        });
    }

    protected processAddSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSubscription(_response);
        });
    }

    protected processUpdateSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWebhookSubscription(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/DeleteWebhookSubscription?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteWebhookSubscription(_response);
        });
    }

    protected processDeleteWebhookSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateWebhookSubscription(_response);
        });
    }

    protected processActivateWebhookSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSubscribed(_response);
        });
    }

    protected processIsSubscribed(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSubscriptionsOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(_response);
        });
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: AxiosResponse): Promise<GetAllSubscriptionsOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSubscriptionsOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(  cancelToken?: CancelToken | undefined): Promise<GetAllAvailableWebhooksOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAvailableWebhooks(_response);
        });
    }

    protected processGetAllAvailableWebhooks(response: AxiosResponse): Promise<GetAllAvailableWebhooksOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllAvailableWebhooksOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllAvailableWebhooksOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllAvailableWebhooksOutputListResultDto>(null as any);
    }
}

export class WithdrawService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ma_id_list (optional) 
     * @param gr_ma_id (optional) 
     * @param wi_payment_type (optional) 
     * @param wi_start_date (optional) 
     * @param wi_end_date (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ma_id_list: number[] | undefined, gr_ma_id: number | undefined, wi_payment_type: BillMethod | undefined, wi_start_date: Date | undefined, wi_end_date: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<WithdrawDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Withdraw/GetAll?";
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (wi_payment_type === null)
            throw new Error("The parameter 'wi_payment_type' cannot be null.");
        else if (wi_payment_type !== undefined)
            url_ += "wi_payment_type=" + encodeURIComponent("" + wi_payment_type) + "&";
        if (wi_start_date === null)
            throw new Error("The parameter 'wi_start_date' cannot be null.");
        else if (wi_start_date !== undefined)
            url_ += "wi_start_date=" + encodeURIComponent(wi_start_date ? "" + wi_start_date.toISOString() : "") + "&";
        if (wi_end_date === null)
            throw new Error("The parameter 'wi_end_date' cannot be null.");
        else if (wi_end_date !== undefined)
            url_ += "wi_end_date=" + encodeURIComponent(wi_end_date ? "" + wi_end_date.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<WithdrawDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<WithdrawDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id_list (optional) 
     * @param ma_id_list (optional) 
     * @param gr_ma_id (optional) 
     * @param wi_payment_type (optional) 
     * @param wi_start_date (optional) 
     * @param wi_end_date (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByAdmin(us_id_list: number[] | undefined, ma_id_list: number[] | undefined, gr_ma_id: number | undefined, wi_payment_type: BillMethod | undefined, wi_start_date: Date | undefined, wi_end_date: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<WithdrawDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Withdraw/GetAllByAdmin?";
        if (us_id_list === null)
            throw new Error("The parameter 'us_id_list' cannot be null.");
        else if (us_id_list !== undefined)
            us_id_list && us_id_list.forEach(item => { url_ += "us_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (ma_id_list === null)
            throw new Error("The parameter 'ma_id_list' cannot be null.");
        else if (ma_id_list !== undefined)
            ma_id_list && ma_id_list.forEach(item => { url_ += "ma_id_list=" + encodeURIComponent("" + item) + "&"; });
        if (gr_ma_id === null)
            throw new Error("The parameter 'gr_ma_id' cannot be null.");
        else if (gr_ma_id !== undefined)
            url_ += "gr_ma_id=" + encodeURIComponent("" + gr_ma_id) + "&";
        if (wi_payment_type === null)
            throw new Error("The parameter 'wi_payment_type' cannot be null.");
        else if (wi_payment_type !== undefined)
            url_ += "wi_payment_type=" + encodeURIComponent("" + wi_payment_type) + "&";
        if (wi_start_date === null)
            throw new Error("The parameter 'wi_start_date' cannot be null.");
        else if (wi_start_date !== undefined)
            url_ += "wi_start_date=" + encodeURIComponent(wi_start_date ? "" + wi_start_date.toISOString() : "") + "&";
        if (wi_end_date === null)
            throw new Error("The parameter 'wi_end_date' cannot be null.");
        else if (wi_end_date !== undefined)
            url_ += "wi_end_date=" + encodeURIComponent(wi_end_date ? "" + wi_end_date.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByAdmin(_response);
        });
    }

    protected processGetAllByAdmin(response: AxiosResponse): Promise<WithdrawDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<WithdrawDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWithdrawBank(body: CreateWithdrawBankInput | undefined , cancelToken?: CancelToken | undefined): Promise<WithdrawDto> {
        let url_ = this.baseUrl + "/api/services/app/Withdraw/CreateWithdrawBank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateWithdrawBank(_response);
        });
    }

    protected processCreateWithdrawBank(response: AxiosResponse): Promise<WithdrawDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDto.fromJS(resultData200.result);
            return Promise.resolve<WithdrawDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWithdrawCash(body: CreateWithdrawCashInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Withdraw/CreateWithdrawCash";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateWithdrawCash(_response);
        });
    }

    protected processCreateWithdrawCash(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ActivateWebhookSubscriptionInput {
        const json = this.toJSON();
        let result = new ActivateWebhookSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class ActiveOrDeactiveProductInput implements IActiveOrDeactiveProductInput {
    pr_id!: number;
    pr_is_active!: number;

    constructor(data?: IActiveOrDeactiveProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_id = _data["pr_id"];
            this.pr_is_active = _data["pr_is_active"];
        }
    }

    static fromJS(data: any): ActiveOrDeactiveProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveOrDeactiveProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_id"] = this.pr_id;
        data["pr_is_active"] = this.pr_is_active;
        return data;
    }

    clone(): ActiveOrDeactiveProductInput {
        const json = this.toJSON();
        let result = new ActiveOrDeactiveProductInput();
        result.init(json);
        return result;
    }
}

export interface IActiveOrDeactiveProductInput {
    pr_id: number;
    pr_is_active: number;
}

export class ActiveOrDeactiveSupplierInput implements IActiveOrDeactiveSupplierInput {
    su_id!: number;
    su_is_active!: number;

    constructor(data?: IActiveOrDeactiveSupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_is_active = _data["su_is_active"];
        }
    }

    static fromJS(data: any): ActiveOrDeactiveSupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveOrDeactiveSupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_is_active"] = this.su_is_active;
        return data;
    }

    clone(): ActiveOrDeactiveSupplierInput {
        const json = this.toJSON();
        let result = new ActiveOrDeactiveSupplierInput();
        result.init(json);
        return result;
    }
}

export interface IActiveOrDeactiveSupplierInput {
    su_id: number;
    su_is_active: number;
}

export class AddDataItem implements IAddDataItem {
    merchantType!: string | undefined;
    serviceCode!: string | undefined;
    masterMerCode!: string | undefined;
    merchantCode!: string | undefined;
    terminalId!: string | undefined;
    productId!: string | undefined;
    amount!: string | undefined;
    ccy!: string | undefined;
    qty!: string | undefined;
    note!: string | undefined;

    constructor(data?: IAddDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantType = _data["merchantType"];
            this.serviceCode = _data["serviceCode"];
            this.masterMerCode = _data["masterMerCode"];
            this.merchantCode = _data["merchantCode"];
            this.terminalId = _data["terminalId"];
            this.productId = _data["productId"];
            this.amount = _data["amount"];
            this.ccy = _data["ccy"];
            this.qty = _data["qty"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): AddDataItem {
        data = typeof data === 'object' ? data : {};
        let result = new AddDataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantType"] = this.merchantType;
        data["serviceCode"] = this.serviceCode;
        data["masterMerCode"] = this.masterMerCode;
        data["merchantCode"] = this.merchantCode;
        data["terminalId"] = this.terminalId;
        data["productId"] = this.productId;
        data["amount"] = this.amount;
        data["ccy"] = this.ccy;
        data["qty"] = this.qty;
        data["note"] = this.note;
        return data;
    }

    clone(): AddDataItem {
        const json = this.toJSON();
        let result = new AddDataItem();
        result.init(json);
        return result;
    }
}

export interface IAddDataItem {
    merchantType: string | undefined;
    serviceCode: string | undefined;
    masterMerCode: string | undefined;
    merchantCode: string | undefined;
    terminalId: string | undefined;
    productId: string | undefined;
    amount: string | undefined;
    ccy: string | undefined;
    qty: string | undefined;
    note: string | undefined;
}

export class AddPointToRFIDInput implements IAddPointToRFIDInput {
    trashWeight!: number;
    deviceMAC!: string | undefined;
    rf_code!: string | undefined;
    tr_lat!: number;
    tr_lng!: number;

    constructor(data?: IAddPointToRFIDInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trashWeight = _data["trashWeight"];
            this.deviceMAC = _data["deviceMAC"];
            this.rf_code = _data["rf_code"];
            this.tr_lat = _data["tr_lat"];
            this.tr_lng = _data["tr_lng"];
        }
    }

    static fromJS(data: any): AddPointToRFIDInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddPointToRFIDInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trashWeight"] = this.trashWeight;
        data["deviceMAC"] = this.deviceMAC;
        data["rf_code"] = this.rf_code;
        data["tr_lat"] = this.tr_lat;
        data["tr_lng"] = this.tr_lng;
        return data;
    }

    clone(): AddPointToRFIDInput {
        const json = this.toJSON();
        let result = new AddPointToRFIDInput();
        result.init(json);
        return result;
    }
}

export interface IAddPointToRFIDInput {
    trashWeight: number;
    deviceMAC: string | undefined;
    rf_code: string | undefined;
    tr_lat: number;
    tr_lng: number;
}

export enum AddressFamily {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _21 = 21,
    _22 = 22,
    _23 = 23,
    _24 = 24,
    _25 = 25,
    _26 = 26,
    _28 = 28,
    _29 = 29,
    _65536 = 65536,
    _65537 = 65537,
    __1 = -1,
}

export class ApplicationExtDto implements IApplicationExtDto {
    ap_id!: number;
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: IApplicationExtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_id = _data["ap_id"];
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): ApplicationExtDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationExtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_id"] = this.ap_id;
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): ApplicationExtDto {
        const json = this.toJSON();
        let result = new ApplicationExtDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationExtDto {
    ap_id: number;
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class ApplicationExtDtoListResultDto implements IApplicationExtDtoListResultDto {
    items!: ApplicationExtDto[] | undefined;

    constructor(data?: IApplicationExtDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationExtDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationExtDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationExtDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplicationExtDtoListResultDto {
        const json = this.toJSON();
        let result = new ApplicationExtDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationExtDtoListResultDto {
    items: ApplicationExtDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: Date;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: Date;
    features: { [key: string]: boolean; } | undefined;
}

export class ApplyDiscountDto implements IApplyDiscountDto {
    di_id!: number;
    di_code!: string | undefined;
    di_price!: number;
    di_desc!: string | undefined;

    constructor(data?: IApplyDiscountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.di_id = _data["di_id"];
            this.di_code = _data["di_code"];
            this.di_price = _data["di_price"];
            this.di_desc = _data["di_desc"];
        }
    }

    static fromJS(data: any): ApplyDiscountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyDiscountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["di_id"] = this.di_id;
        data["di_code"] = this.di_code;
        data["di_price"] = this.di_price;
        data["di_desc"] = this.di_desc;
        return data;
    }

    clone(): ApplyDiscountDto {
        const json = this.toJSON();
        let result = new ApplyDiscountDto();
        result.init(json);
        return result;
    }
}

export interface IApplyDiscountDto {
    di_id: number;
    di_code: string | undefined;
    di_price: number;
    di_desc: string | undefined;
}

export class ApplyDiscountDtoListResultDto implements IApplyDiscountDtoListResultDto {
    items!: ApplyDiscountDto[] | undefined;

    constructor(data?: IApplyDiscountDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplyDiscountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplyDiscountDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyDiscountDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplyDiscountDtoListResultDto {
        const json = this.toJSON();
        let result = new ApplyDiscountDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IApplyDiscountDtoListResultDto {
    items: ApplyDiscountDto[] | undefined;
}

export class AsnEncodedData implements IAsnEncodedData {
    oid!: Oid;
    rawData!: string | undefined;

    constructor(data?: IAsnEncodedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"] ? Oid.fromJS(_data["oid"]) : <any>undefined;
            this.rawData = _data["rawData"];
        }
    }

    static fromJS(data: any): AsnEncodedData {
        data = typeof data === 'object' ? data : {};
        let result = new AsnEncodedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        data["rawData"] = this.rawData;
        return data;
    }

    clone(): AsnEncodedData {
        const json = this.toJSON();
        let result = new AsnEncodedData();
        result.init(json);
        return result;
    }
}

export interface IAsnEncodedData {
    oid: Oid;
    rawData: string | undefined;
}

export class Assembly implements IAssembly {
    readonly definedTypes!: TypeInfo[] | undefined;
    readonly exportedTypes!: Type[] | undefined;
    readonly codeBase!: string | undefined;
    entryPoint!: MethodInfo;
    readonly fullName!: string | undefined;
    readonly imageRuntimeVersion!: string | undefined;
    readonly isDynamic!: boolean;
    readonly location!: string | undefined;
    readonly reflectionOnly!: boolean;
    readonly isCollectible!: boolean;
    readonly isFullyTrusted!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly escapedCodeBase!: string | undefined;
    manifestModule!: Module;
    readonly modules!: Module[] | undefined;
    readonly globalAssemblyCache!: boolean;
    readonly hostContext!: number;
    securityRuleSet!: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }

    clone(): Assembly {
        const json = this.toJSON();
        let result = new Assembly();
        result.init(json);
        return result;
    }
}

export interface IAssembly {
    definedTypes: TypeInfo[] | undefined;
    exportedTypes: Type[] | undefined;
    codeBase: string | undefined;
    entryPoint: MethodInfo;
    fullName: string | undefined;
    imageRuntimeVersion: string | undefined;
    isDynamic: boolean;
    location: string | undefined;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    escapedCodeBase: string | undefined;
    manifestModule: Module;
    modules: Module[] | undefined;
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class AsymmetricAlgorithm implements IAsymmetricAlgorithm {
    keySize!: number;
    readonly legalKeySizes!: KeySizes[] | undefined;
    readonly signatureAlgorithm!: string | undefined;
    readonly keyExchangeAlgorithm!: string | undefined;

    constructor(data?: IAsymmetricAlgorithm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keySize = _data["keySize"];
            if (Array.isArray(_data["legalKeySizes"])) {
                (<any>this).legalKeySizes = [] as any;
                for (let item of _data["legalKeySizes"])
                    (<any>this).legalKeySizes!.push(KeySizes.fromJS(item));
            }
            (<any>this).signatureAlgorithm = _data["signatureAlgorithm"];
            (<any>this).keyExchangeAlgorithm = _data["keyExchangeAlgorithm"];
        }
    }

    static fromJS(data: any): AsymmetricAlgorithm {
        data = typeof data === 'object' ? data : {};
        let result = new AsymmetricAlgorithm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keySize"] = this.keySize;
        if (Array.isArray(this.legalKeySizes)) {
            data["legalKeySizes"] = [];
            for (let item of this.legalKeySizes)
                data["legalKeySizes"].push(item.toJSON());
        }
        data["signatureAlgorithm"] = this.signatureAlgorithm;
        data["keyExchangeAlgorithm"] = this.keyExchangeAlgorithm;
        return data;
    }

    clone(): AsymmetricAlgorithm {
        const json = this.toJSON();
        let result = new AsymmetricAlgorithm();
        result.init(json);
        return result;
    }
}

export interface IAsymmetricAlgorithm {
    keySize: number;
    legalKeySizes: KeySizes[] | undefined;
    signatureAlgorithm: string | undefined;
    keyExchangeAlgorithm: string | undefined;
}

export class AttachmentItem implements IAttachmentItem {
    id!: number;
    key!: string | undefined;
    md5!: string | undefined;
    ext!: string | undefined;
    type!: ETypeFileMedia;
    isdelete!: boolean;

    constructor(data?: IAttachmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.md5 = _data["md5"];
            this.ext = _data["ext"];
            this.type = _data["type"];
            this.isdelete = _data["isdelete"];
        }
    }

    static fromJS(data: any): AttachmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["md5"] = this.md5;
        data["ext"] = this.ext;
        data["type"] = this.type;
        data["isdelete"] = this.isdelete;
        return data;
    }

    clone(): AttachmentItem {
        const json = this.toJSON();
        let result = new AttachmentItem();
        result.init(json);
        return result;
    }
}

export interface IAttachmentItem {
    id: number;
    key: string | undefined;
    md5: string | undefined;
    ext: string | undefined;
    type: ETypeFileMedia;
    isdelete: boolean;
}

export class AttachmentItemListResultDto implements IAttachmentItemListResultDto {
    items!: AttachmentItem[] | undefined;

    constructor(data?: IAttachmentItemListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttachmentItemListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentItemListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AttachmentItemListResultDto {
        const json = this.toJSON();
        let result = new AttachmentItemListResultDto();
        result.init(json);
        return result;
    }
}

export interface IAttachmentItemListResultDto {
    items: AttachmentItem[] | undefined;
}

export class AuditLogDto implements IAuditLogDto {
    id!: number;
    impersonatorUserId!: number | undefined;
    exception!: string | undefined;
    browserInfo!: string | undefined;
    clientName!: string | undefined;
    clientIpAddress!: string | undefined;
    executionDuration!: number;
    executionTime!: Date;
    userId!: number | undefined;
    methodName!: string | undefined;
    serviceName!: string | undefined;
    parameters!: string | undefined;
    customData!: string | undefined;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.exception = _data["exception"];
            this.browserInfo = _data["browserInfo"];
            this.clientName = _data["clientName"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.executionDuration = _data["executionDuration"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.methodName = _data["methodName"];
            this.serviceName = _data["serviceName"];
            this.parameters = _data["parameters"];
            this.customData = _data["customData"];
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["exception"] = this.exception;
        data["browserInfo"] = this.browserInfo;
        data["clientName"] = this.clientName;
        data["clientIpAddress"] = this.clientIpAddress;
        data["executionDuration"] = this.executionDuration;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["methodName"] = this.methodName;
        data["serviceName"] = this.serviceName;
        data["parameters"] = this.parameters;
        data["customData"] = this.customData;
        return data;
    }

    clone(): AuditLogDto {
        const json = this.toJSON();
        let result = new AuditLogDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogDto {
    id: number;
    impersonatorUserId: number | undefined;
    exception: string | undefined;
    browserInfo: string | undefined;
    clientName: string | undefined;
    clientIpAddress: string | undefined;
    executionDuration: number;
    executionTime: Date;
    userId: number | undefined;
    methodName: string | undefined;
    serviceName: string | undefined;
    parameters: string | undefined;
    customData: string | undefined;
}

export class AuditLogDtoPagedResultDto implements IAuditLogDtoPagedResultDto {
    items!: AuditLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuditLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuditLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AuditLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogDtoPagedResultDto {
    items: AuditLogDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;
    tenantId!: number | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    tenantId: number | undefined;
}

export class AuthenticateModelForTrashBin implements IAuthenticateModelForTrashBin {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;
    tenantName!: string | undefined;
    deviceID!: string | undefined;
    deviceMAC!: string | undefined;

    constructor(data?: IAuthenticateModelForTrashBin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.tenantName = _data["tenantName"];
            this.deviceID = _data["deviceID"];
            this.deviceMAC = _data["deviceMAC"];
        }
    }

    static fromJS(data: any): AuthenticateModelForTrashBin {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModelForTrashBin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["tenantName"] = this.tenantName;
        data["deviceID"] = this.deviceID;
        data["deviceMAC"] = this.deviceMAC;
        return data;
    }

    clone(): AuthenticateModelForTrashBin {
        const json = this.toJSON();
        let result = new AuthenticateModelForTrashBin();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModelForTrashBin {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    tenantName: string | undefined;
    deviceID: string | undefined;
    deviceMAC: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    tenantId: number | undefined;
}

export class AuthorizationMachineDto implements IAuthorizationMachineDto {
    au_ma_id!: number;
    us_id_is_authorized!: number;
    ma_id!: number;
    au_ma_is_deleted!: boolean;
    au_ma_type!: EAuthorizationMachineType;
    au_ma_created_at!: Date;
    au_ma_updated_at!: Date;
    au_ma_deleted_at!: Date | undefined;

    constructor(data?: IAuthorizationMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_ma_id = _data["au_ma_id"];
            this.us_id_is_authorized = _data["us_id_is_authorized"];
            this.ma_id = _data["ma_id"];
            this.au_ma_is_deleted = _data["au_ma_is_deleted"];
            this.au_ma_type = _data["au_ma_type"];
            this.au_ma_created_at = _data["au_ma_created_at"] ? new Date(_data["au_ma_created_at"].toString()) : <any>undefined;
            this.au_ma_updated_at = _data["au_ma_updated_at"] ? new Date(_data["au_ma_updated_at"].toString()) : <any>undefined;
            this.au_ma_deleted_at = _data["au_ma_deleted_at"] ? new Date(_data["au_ma_deleted_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthorizationMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizationMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_ma_id"] = this.au_ma_id;
        data["us_id_is_authorized"] = this.us_id_is_authorized;
        data["ma_id"] = this.ma_id;
        data["au_ma_is_deleted"] = this.au_ma_is_deleted;
        data["au_ma_type"] = this.au_ma_type;
        data["au_ma_created_at"] = this.au_ma_created_at ? this.au_ma_created_at.toISOString() : <any>undefined;
        data["au_ma_updated_at"] = this.au_ma_updated_at ? this.au_ma_updated_at.toISOString() : <any>undefined;
        data["au_ma_deleted_at"] = this.au_ma_deleted_at ? this.au_ma_deleted_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): AuthorizationMachineDto {
        const json = this.toJSON();
        let result = new AuthorizationMachineDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorizationMachineDto {
    au_ma_id: number;
    us_id_is_authorized: number;
    ma_id: number;
    au_ma_is_deleted: boolean;
    au_ma_type: EAuthorizationMachineType;
    au_ma_created_at: Date;
    au_ma_updated_at: Date;
    au_ma_deleted_at: Date | undefined;
}

export class AuthorizationMachineDtoPagedResultDto implements IAuthorizationMachineDtoPagedResultDto {
    items!: AuthorizationMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuthorizationMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuthorizationMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuthorizationMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizationMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AuthorizationMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuthorizationMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorizationMachineDtoPagedResultDto {
    items: AuthorizationMachineDto[] | undefined;
    totalCount: number;
}

export enum BillMethod {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class Billing implements IBilling {
    id!: number;
    readonly bi_id!: number;
    bi_code!: string | undefined;
    ma_id!: number;
    entities_id_arr!: string | undefined;
    bi_remain_money!: number;
    bi_method_payment!: BillMethod;
    bi_cash_received!: number;
    bi_qr_received!: number;
    bi_rifd_received!: number;
    bi_quantity_vending!: number;
    bi_quantity_refill!: number;
    bi_money_must_payment!: number;
    bi_money_original!: number;
    di_id!: number;
    bi_paid_status!: EPaidStatus;
    bi_status!: EBillStatus;
    bi_required_refund!: EBillRequiredFund;
    bi_reconcile_status!: EBillReconcileStatus;
    bi_reconcile_reason!: string | undefined;
    bi_reconcile_at!: Date | undefined;
    total_cash_all_billing_before!: number;
    bi_code_before!: string | undefined;
    bi_created_at!: Date;
    tenantId!: number;
    listRefunds!: Refund[] | undefined;
    listBillingProduct!: BillingProduct[] | undefined;
    machine!: Machine;

    constructor(data?: IBilling) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).bi_id = _data["bi_id"];
            this.bi_code = _data["bi_code"];
            this.ma_id = _data["ma_id"];
            this.entities_id_arr = _data["entities_id_arr"];
            this.bi_remain_money = _data["bi_remain_money"];
            this.bi_method_payment = _data["bi_method_payment"];
            this.bi_cash_received = _data["bi_cash_received"];
            this.bi_qr_received = _data["bi_qr_received"];
            this.bi_rifd_received = _data["bi_rifd_received"];
            this.bi_quantity_vending = _data["bi_quantity_vending"];
            this.bi_quantity_refill = _data["bi_quantity_refill"];
            this.bi_money_must_payment = _data["bi_money_must_payment"];
            this.bi_money_original = _data["bi_money_original"];
            this.di_id = _data["di_id"];
            this.bi_paid_status = _data["bi_paid_status"];
            this.bi_status = _data["bi_status"];
            this.bi_required_refund = _data["bi_required_refund"];
            this.bi_reconcile_status = _data["bi_reconcile_status"];
            this.bi_reconcile_reason = _data["bi_reconcile_reason"];
            this.bi_reconcile_at = _data["bi_reconcile_at"] ? new Date(_data["bi_reconcile_at"].toString()) : <any>undefined;
            this.total_cash_all_billing_before = _data["total_cash_all_billing_before"];
            this.bi_code_before = _data["bi_code_before"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["listRefunds"])) {
                this.listRefunds = [] as any;
                for (let item of _data["listRefunds"])
                    this.listRefunds!.push(Refund.fromJS(item));
            }
            if (Array.isArray(_data["listBillingProduct"])) {
                this.listBillingProduct = [] as any;
                for (let item of _data["listBillingProduct"])
                    this.listBillingProduct!.push(BillingProduct.fromJS(item));
            }
            this.machine = _data["machine"] ? Machine.fromJS(_data["machine"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Billing {
        data = typeof data === 'object' ? data : {};
        let result = new Billing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bi_id"] = this.bi_id;
        data["bi_code"] = this.bi_code;
        data["ma_id"] = this.ma_id;
        data["entities_id_arr"] = this.entities_id_arr;
        data["bi_remain_money"] = this.bi_remain_money;
        data["bi_method_payment"] = this.bi_method_payment;
        data["bi_cash_received"] = this.bi_cash_received;
        data["bi_qr_received"] = this.bi_qr_received;
        data["bi_rifd_received"] = this.bi_rifd_received;
        data["bi_quantity_vending"] = this.bi_quantity_vending;
        data["bi_quantity_refill"] = this.bi_quantity_refill;
        data["bi_money_must_payment"] = this.bi_money_must_payment;
        data["bi_money_original"] = this.bi_money_original;
        data["di_id"] = this.di_id;
        data["bi_paid_status"] = this.bi_paid_status;
        data["bi_status"] = this.bi_status;
        data["bi_required_refund"] = this.bi_required_refund;
        data["bi_reconcile_status"] = this.bi_reconcile_status;
        data["bi_reconcile_reason"] = this.bi_reconcile_reason;
        data["bi_reconcile_at"] = this.bi_reconcile_at ? this.bi_reconcile_at.toISOString() : <any>undefined;
        data["total_cash_all_billing_before"] = this.total_cash_all_billing_before;
        data["bi_code_before"] = this.bi_code_before;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.listRefunds)) {
            data["listRefunds"] = [];
            for (let item of this.listRefunds)
                data["listRefunds"].push(item.toJSON());
        }
        if (Array.isArray(this.listBillingProduct)) {
            data["listBillingProduct"] = [];
            for (let item of this.listBillingProduct)
                data["listBillingProduct"].push(item.toJSON());
        }
        data["machine"] = this.machine ? this.machine.toJSON() : <any>undefined;
        return data;
    }

    clone(): Billing {
        const json = this.toJSON();
        let result = new Billing();
        result.init(json);
        return result;
    }
}

export interface IBilling {
    id: number;
    bi_id: number;
    bi_code: string | undefined;
    ma_id: number;
    entities_id_arr: string | undefined;
    bi_remain_money: number;
    bi_method_payment: BillMethod;
    bi_cash_received: number;
    bi_qr_received: number;
    bi_rifd_received: number;
    bi_quantity_vending: number;
    bi_quantity_refill: number;
    bi_money_must_payment: number;
    bi_money_original: number;
    di_id: number;
    bi_paid_status: EPaidStatus;
    bi_status: EBillStatus;
    bi_required_refund: EBillRequiredFund;
    bi_reconcile_status: EBillReconcileStatus;
    bi_reconcile_reason: string | undefined;
    bi_reconcile_at: Date | undefined;
    total_cash_all_billing_before: number;
    bi_code_before: string | undefined;
    bi_created_at: Date;
    tenantId: number;
    listRefunds: Refund[] | undefined;
    listBillingProduct: BillingProduct[] | undefined;
    machine: Machine;
}

export class BillingDto implements IBillingDto {
    bi_id!: number;
    bi_code!: string | undefined;
    ma_id!: number;
    gr_ma_name!: string | undefined;
    entities_id_arr!: ItemBillingEntity[] | undefined;
    bi_remain_money!: number;
    bi_method_payment!: number;
    bi_nr_refill!: number;
    bi_cash_received!: number;
    bi_qr_received!: number;
    bi_rifd_received!: number;
    bi_quantity_vending!: number;
    bi_quantity_refill!: number;
    bi_money_must_payment!: number;
    bi_money_original!: number;
    bi_required_refund!: EBillRequiredFund;
    bi_reconcile_status!: EBillReconcileStatus;
    bi_reconcile_reason!: string | undefined;
    bi_reconcile_at!: Date | undefined;
    di_id!: number;
    bi_status!: EBillStatus;
    bi_paid_status!: EPaidStatus;
    bi_created_at!: Date;
    total_cash_all_billing_before!: number;
    listRefunds!: RefundDto[] | undefined;
    listBillingProduct!: BillingProduct[] | undefined;
    totalMoneyRefunds!: number;
    machine!: MachineAbstractDto;

    constructor(data?: IBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_id = _data["bi_id"];
            this.bi_code = _data["bi_code"];
            this.ma_id = _data["ma_id"];
            this.gr_ma_name = _data["gr_ma_name"];
            if (Array.isArray(_data["entities_id_arr"])) {
                this.entities_id_arr = [] as any;
                for (let item of _data["entities_id_arr"])
                    this.entities_id_arr!.push(ItemBillingEntity.fromJS(item));
            }
            this.bi_remain_money = _data["bi_remain_money"];
            this.bi_method_payment = _data["bi_method_payment"];
            this.bi_nr_refill = _data["bi_nr_refill"];
            this.bi_cash_received = _data["bi_cash_received"];
            this.bi_qr_received = _data["bi_qr_received"];
            this.bi_rifd_received = _data["bi_rifd_received"];
            this.bi_quantity_vending = _data["bi_quantity_vending"];
            this.bi_quantity_refill = _data["bi_quantity_refill"];
            this.bi_money_must_payment = _data["bi_money_must_payment"];
            this.bi_money_original = _data["bi_money_original"];
            this.bi_required_refund = _data["bi_required_refund"];
            this.bi_reconcile_status = _data["bi_reconcile_status"];
            this.bi_reconcile_reason = _data["bi_reconcile_reason"];
            this.bi_reconcile_at = _data["bi_reconcile_at"] ? new Date(_data["bi_reconcile_at"].toString()) : <any>undefined;
            this.di_id = _data["di_id"];
            this.bi_status = _data["bi_status"];
            this.bi_paid_status = _data["bi_paid_status"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
            this.total_cash_all_billing_before = _data["total_cash_all_billing_before"];
            if (Array.isArray(_data["listRefunds"])) {
                this.listRefunds = [] as any;
                for (let item of _data["listRefunds"])
                    this.listRefunds!.push(RefundDto.fromJS(item));
            }
            if (Array.isArray(_data["listBillingProduct"])) {
                this.listBillingProduct = [] as any;
                for (let item of _data["listBillingProduct"])
                    this.listBillingProduct!.push(BillingProduct.fromJS(item));
            }
            this.totalMoneyRefunds = _data["totalMoneyRefunds"];
            this.machine = _data["machine"] ? MachineAbstractDto.fromJS(_data["machine"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_id"] = this.bi_id;
        data["bi_code"] = this.bi_code;
        data["ma_id"] = this.ma_id;
        data["gr_ma_name"] = this.gr_ma_name;
        if (Array.isArray(this.entities_id_arr)) {
            data["entities_id_arr"] = [];
            for (let item of this.entities_id_arr)
                data["entities_id_arr"].push(item.toJSON());
        }
        data["bi_remain_money"] = this.bi_remain_money;
        data["bi_method_payment"] = this.bi_method_payment;
        data["bi_nr_refill"] = this.bi_nr_refill;
        data["bi_cash_received"] = this.bi_cash_received;
        data["bi_qr_received"] = this.bi_qr_received;
        data["bi_rifd_received"] = this.bi_rifd_received;
        data["bi_quantity_vending"] = this.bi_quantity_vending;
        data["bi_quantity_refill"] = this.bi_quantity_refill;
        data["bi_money_must_payment"] = this.bi_money_must_payment;
        data["bi_money_original"] = this.bi_money_original;
        data["bi_required_refund"] = this.bi_required_refund;
        data["bi_reconcile_status"] = this.bi_reconcile_status;
        data["bi_reconcile_reason"] = this.bi_reconcile_reason;
        data["bi_reconcile_at"] = this.bi_reconcile_at ? this.bi_reconcile_at.toISOString() : <any>undefined;
        data["di_id"] = this.di_id;
        data["bi_status"] = this.bi_status;
        data["bi_paid_status"] = this.bi_paid_status;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        data["total_cash_all_billing_before"] = this.total_cash_all_billing_before;
        if (Array.isArray(this.listRefunds)) {
            data["listRefunds"] = [];
            for (let item of this.listRefunds)
                data["listRefunds"].push(item.toJSON());
        }
        if (Array.isArray(this.listBillingProduct)) {
            data["listBillingProduct"] = [];
            for (let item of this.listBillingProduct)
                data["listBillingProduct"].push(item.toJSON());
        }
        data["totalMoneyRefunds"] = this.totalMoneyRefunds;
        data["machine"] = this.machine ? this.machine.toJSON() : <any>undefined;
        return data;
    }

    clone(): BillingDto {
        const json = this.toJSON();
        let result = new BillingDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDto {
    bi_id: number;
    bi_code: string | undefined;
    ma_id: number;
    gr_ma_name: string | undefined;
    entities_id_arr: ItemBillingEntity[] | undefined;
    bi_remain_money: number;
    bi_method_payment: number;
    bi_nr_refill: number;
    bi_cash_received: number;
    bi_qr_received: number;
    bi_rifd_received: number;
    bi_quantity_vending: number;
    bi_quantity_refill: number;
    bi_money_must_payment: number;
    bi_money_original: number;
    bi_required_refund: EBillRequiredFund;
    bi_reconcile_status: EBillReconcileStatus;
    bi_reconcile_reason: string | undefined;
    bi_reconcile_at: Date | undefined;
    di_id: number;
    bi_status: EBillStatus;
    bi_paid_status: EPaidStatus;
    bi_created_at: Date;
    total_cash_all_billing_before: number;
    listRefunds: RefundDto[] | undefined;
    listBillingProduct: BillingProduct[] | undefined;
    totalMoneyRefunds: number;
    machine: MachineAbstractDto;
}

export class BillingDtoPagedResultDto implements IBillingDtoPagedResultDto {
    items!: BillingDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBillingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BillingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BillingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BillingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BillingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDtoPagedResultDto {
    items: BillingDto[] | undefined;
    totalCount: number;
}

export class BillingProduct implements IBillingProduct {
    id!: number;
    readonly bi_pr_id!: number;
    slot_id!: number;
    pr_price!: number;
    bi_pr_status!: EBillingProductStatus;
    bi_id!: number;
    bi_method!: BillMethod;
    pr_id!: number;
    bi_pr_created_at!: Date;
    tenantId!: number;
    billing!: Billing;
    product!: Product;

    constructor(data?: IBillingProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).bi_pr_id = _data["bi_pr_id"];
            this.slot_id = _data["slot_id"];
            this.pr_price = _data["pr_price"];
            this.bi_pr_status = _data["bi_pr_status"];
            this.bi_id = _data["bi_id"];
            this.bi_method = _data["bi_method"];
            this.pr_id = _data["pr_id"];
            this.bi_pr_created_at = _data["bi_pr_created_at"] ? new Date(_data["bi_pr_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.billing = _data["billing"] ? Billing.fromJS(_data["billing"]) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BillingProduct {
        data = typeof data === 'object' ? data : {};
        let result = new BillingProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bi_pr_id"] = this.bi_pr_id;
        data["slot_id"] = this.slot_id;
        data["pr_price"] = this.pr_price;
        data["bi_pr_status"] = this.bi_pr_status;
        data["bi_id"] = this.bi_id;
        data["bi_method"] = this.bi_method;
        data["pr_id"] = this.pr_id;
        data["bi_pr_created_at"] = this.bi_pr_created_at ? this.bi_pr_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }

    clone(): BillingProduct {
        const json = this.toJSON();
        let result = new BillingProduct();
        result.init(json);
        return result;
    }
}

export interface IBillingProduct {
    id: number;
    bi_pr_id: number;
    slot_id: number;
    pr_price: number;
    bi_pr_status: EBillingProductStatus;
    bi_id: number;
    bi_method: BillMethod;
    pr_id: number;
    bi_pr_created_at: Date;
    tenantId: number;
    billing: Billing;
    product: Product;
}

export class BooleanResultDto implements IBooleanResultDto {
    result!: boolean;

    constructor(data?: IBooleanResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): BooleanResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data;
    }

    clone(): BooleanResultDto {
        const json = this.toJSON();
        let result = new BooleanResultDto();
        result.init(json);
        return result;
    }
}

export interface IBooleanResultDto {
    result: boolean;
}

export class ByteReadOnlyMemory implements IByteReadOnlyMemory {
    readonly length!: number;
    readonly isEmpty!: boolean;
    span!: ByteReadOnlySpan;

    constructor(data?: IByteReadOnlyMemory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).length = _data["length"];
            (<any>this).isEmpty = _data["isEmpty"];
            this.span = _data["span"] ? ByteReadOnlySpan.fromJS(_data["span"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ByteReadOnlyMemory {
        data = typeof data === 'object' ? data : {};
        let result = new ByteReadOnlyMemory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["length"] = this.length;
        data["isEmpty"] = this.isEmpty;
        data["span"] = this.span ? this.span.toJSON() : <any>undefined;
        return data;
    }

    clone(): ByteReadOnlyMemory {
        const json = this.toJSON();
        let result = new ByteReadOnlyMemory();
        result.init(json);
        return result;
    }
}

export interface IByteReadOnlyMemory {
    length: number;
    isEmpty: boolean;
    span: ByteReadOnlySpan;
}

export class ByteReadOnlySpan implements IByteReadOnlySpan {
    readonly length!: number;
    readonly isEmpty!: boolean;

    constructor(data?: IByteReadOnlySpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).length = _data["length"];
            (<any>this).isEmpty = _data["isEmpty"];
        }
    }

    static fromJS(data: any): ByteReadOnlySpan {
        data = typeof data === 'object' ? data : {};
        let result = new ByteReadOnlySpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["length"] = this.length;
        data["isEmpty"] = this.isEmpty;
        return data;
    }

    clone(): ByteReadOnlySpan {
        const json = this.toJSON();
        let result = new ByteReadOnlySpan();
        result.init(json);
        return result;
    }
}

export interface IByteReadOnlySpan {
    length: number;
    isEmpty: boolean;
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class CancellationToken implements ICancellationToken {
    readonly isCancellationRequested!: boolean;
    readonly canBeCanceled!: boolean;
    waitHandle!: WaitHandle;

    constructor(data?: ICancellationToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isCancellationRequested = _data["isCancellationRequested"];
            (<any>this).canBeCanceled = _data["canBeCanceled"];
            this.waitHandle = _data["waitHandle"] ? WaitHandle.fromJS(_data["waitHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CancellationToken {
        data = typeof data === 'object' ? data : {};
        let result = new CancellationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCancellationRequested"] = this.isCancellationRequested;
        data["canBeCanceled"] = this.canBeCanceled;
        data["waitHandle"] = this.waitHandle ? this.waitHandle.toJSON() : <any>undefined;
        return data;
    }

    clone(): CancellationToken {
        const json = this.toJSON();
        let result = new CancellationToken();
        result.init(json);
        return result;
    }
}

export interface ICancellationToken {
    isCancellationRequested: boolean;
    canBeCanceled: boolean;
    waitHandle: WaitHandle;
}

export class ChangeMoneyRfidInput implements IChangeMoneyRfidInput {
    rf_id!: number;
    type_recharge!: RFIDTypeRecharge;
    rf_money_current!: number;

    constructor(data?: IChangeMoneyRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_id = _data["rf_id"];
            this.type_recharge = _data["type_recharge"];
            this.rf_money_current = _data["rf_money_current"];
        }
    }

    static fromJS(data: any): ChangeMoneyRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeMoneyRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_id"] = this.rf_id;
        data["type_recharge"] = this.type_recharge;
        data["rf_money_current"] = this.rf_money_current;
        return data;
    }

    clone(): ChangeMoneyRfidInput {
        const json = this.toJSON();
        let result = new ChangeMoneyRfidInput();
        result.init(json);
        return result;
    }
}

export interface IChangeMoneyRfidInput {
    rf_id: number;
    type_recharge: RFIDTypeRecharge;
    rf_money_current: number;
}

export class ChangeOwnerRfidInput implements IChangeOwnerRfidInput {
    rf_id!: number;
    us_id_owner!: number;

    constructor(data?: IChangeOwnerRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_id = _data["rf_id"];
            this.us_id_owner = _data["us_id_owner"];
        }
    }

    static fromJS(data: any): ChangeOwnerRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOwnerRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_id"] = this.rf_id;
        data["us_id_owner"] = this.us_id_owner;
        return data;
    }

    clone(): ChangeOwnerRfidInput {
        const json = this.toJSON();
        let result = new ChangeOwnerRfidInput();
        result.init(json);
        return result;
    }
}

export interface IChangeOwnerRfidInput {
    rf_id: number;
    us_id_owner: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword!: string;
    newPassword!: string;
    user_id!: number;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["user_id"] = this.user_id;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
    user_id: number;
}

export class ChangeReasonAndStatusReconcileInput implements IChangeReasonAndStatusReconcileInput {
    rec_id!: number;
    code!: string | undefined;
    reconcile_reason!: string | undefined;
    reconcile_status!: EBillReconcileStatus;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IChangeReasonAndStatusReconcileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.code = _data["code"];
            this.reconcile_reason = _data["reconcile_reason"];
            this.reconcile_status = _data["reconcile_status"];
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangeReasonAndStatusReconcileInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeReasonAndStatusReconcileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["code"] = this.code;
        data["reconcile_reason"] = this.reconcile_reason;
        data["reconcile_status"] = this.reconcile_status;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): ChangeReasonAndStatusReconcileInput {
        const json = this.toJSON();
        let result = new ChangeReasonAndStatusReconcileInput();
        result.init(json);
        return result;
    }
}

export interface IChangeReasonAndStatusReconcileInput {
    rec_id: number;
    code: string | undefined;
    reconcile_reason: string | undefined;
    reconcile_status: EBillReconcileStatus;
    fi_id_list: AttachmentItem[] | undefined;
}

export class ChangeStatusLossRepositoryInput implements IChangeStatusLossRepositoryInput {
    lo_re_id!: number;
    lo_re_status!: ELossRepositoryStatus;

    constructor(data?: IChangeStatusLossRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lo_re_id = _data["lo_re_id"];
            this.lo_re_status = _data["lo_re_status"];
        }
    }

    static fromJS(data: any): ChangeStatusLossRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStatusLossRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lo_re_id"] = this.lo_re_id;
        data["lo_re_status"] = this.lo_re_status;
        return data;
    }

    clone(): ChangeStatusLossRepositoryInput {
        const json = this.toJSON();
        let result = new ChangeStatusLossRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IChangeStatusLossRepositoryInput {
    lo_re_id: number;
    lo_re_status: ELossRepositoryStatus;
}

export class ChangeStatusTranferRepositoryInput implements IChangeStatusTranferRepositoryInput {
    tr_re_id!: number;
    tr_re_status!: ETranferRepositoryStatus;
    tr_re_reason!: string | undefined;

    constructor(data?: IChangeStatusTranferRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_re_id = _data["tr_re_id"];
            this.tr_re_status = _data["tr_re_status"];
            this.tr_re_reason = _data["tr_re_reason"];
        }
    }

    static fromJS(data: any): ChangeStatusTranferRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStatusTranferRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_re_id"] = this.tr_re_id;
        data["tr_re_status"] = this.tr_re_status;
        data["tr_re_reason"] = this.tr_re_reason;
        return data;
    }

    clone(): ChangeStatusTranferRepositoryInput {
        const json = this.toJSON();
        let result = new ChangeStatusTranferRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IChangeStatusTranferRepositoryInput {
    tr_re_id: number;
    tr_re_status: ETranferRepositoryStatus;
    tr_re_reason: string | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme!: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangeUserOwnerInput implements IChangeUserOwnerInput {
    ma_id!: number;
    us_id_owner!: number;

    constructor(data?: IChangeUserOwnerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.us_id_owner = _data["us_id_owner"];
        }
    }

    static fromJS(data: any): ChangeUserOwnerInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserOwnerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["us_id_owner"] = this.us_id_owner;
        return data;
    }

    clone(): ChangeUserOwnerInput {
        const json = this.toJSON();
        let result = new ChangeUserOwnerInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUserOwnerInput {
    ma_id: number;
    us_id_owner: number;
}

export class CheckCodeDiscountInput implements ICheckCodeDiscountInput {
    discountCode!: string | undefined;

    constructor(data?: ICheckCodeDiscountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discountCode = _data["discountCode"];
        }
    }

    static fromJS(data: any): CheckCodeDiscountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckCodeDiscountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountCode"] = this.discountCode;
        return data;
    }

    clone(): CheckCodeDiscountInput {
        const json = this.toJSON();
        let result = new CheckCodeDiscountInput();
        result.init(json);
        return result;
    }
}

export interface ICheckCodeDiscountInput {
    discountCode: string | undefined;
}

export class CheckPassword2Output implements ICheckPassword2Output {
    id!: number;
    password!: string | undefined;
    isCorrect!: boolean;

    constructor(data?: ICheckPassword2Output) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.password = _data["password"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): CheckPassword2Output {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPassword2Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        data["isCorrect"] = this.isCorrect;
        return data;
    }

    clone(): CheckPassword2Output {
        const json = this.toJSON();
        let result = new CheckPassword2Output();
        result.init(json);
        return result;
    }
}

export interface ICheckPassword2Output {
    id: number;
    password: string | undefined;
    isCorrect: boolean;
}

export class CheckRifdPaymentInput implements ICheckRifdPaymentInput {
    bi_code!: string | undefined;
    deviceID!: string | undefined;
    bi_remain_money!: number;
    bi_method_payment!: string | undefined;
    entities_id_arr!: ItemBillingEntity[] | undefined;
    bi_cash_received!: number;
    bi_qr_received!: number;
    bi_rifd_received!: number;
    total_cash_all_billing_before!: number;
    bi_code_before!: string | undefined;
    bi_money!: number;
    di_id!: number;
    bi_created_at!: Date;
    rifdCode!: string;

    constructor(data?: ICheckRifdPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.deviceID = _data["deviceID"];
            this.bi_remain_money = _data["bi_remain_money"];
            this.bi_method_payment = _data["bi_method_payment"];
            if (Array.isArray(_data["entities_id_arr"])) {
                this.entities_id_arr = [] as any;
                for (let item of _data["entities_id_arr"])
                    this.entities_id_arr!.push(ItemBillingEntity.fromJS(item));
            }
            this.bi_cash_received = _data["bi_cash_received"];
            this.bi_qr_received = _data["bi_qr_received"];
            this.bi_rifd_received = _data["bi_rifd_received"];
            this.total_cash_all_billing_before = _data["total_cash_all_billing_before"];
            this.bi_code_before = _data["bi_code_before"];
            this.bi_money = _data["bi_money"];
            this.di_id = _data["di_id"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
            this.rifdCode = _data["rifdCode"];
        }
    }

    static fromJS(data: any): CheckRifdPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRifdPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["deviceID"] = this.deviceID;
        data["bi_remain_money"] = this.bi_remain_money;
        data["bi_method_payment"] = this.bi_method_payment;
        if (Array.isArray(this.entities_id_arr)) {
            data["entities_id_arr"] = [];
            for (let item of this.entities_id_arr)
                data["entities_id_arr"].push(item.toJSON());
        }
        data["bi_cash_received"] = this.bi_cash_received;
        data["bi_qr_received"] = this.bi_qr_received;
        data["bi_rifd_received"] = this.bi_rifd_received;
        data["total_cash_all_billing_before"] = this.total_cash_all_billing_before;
        data["bi_code_before"] = this.bi_code_before;
        data["bi_money"] = this.bi_money;
        data["di_id"] = this.di_id;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        data["rifdCode"] = this.rifdCode;
        return data;
    }

    clone(): CheckRifdPaymentInput {
        const json = this.toJSON();
        let result = new CheckRifdPaymentInput();
        result.init(json);
        return result;
    }
}

export interface ICheckRifdPaymentInput {
    bi_code: string | undefined;
    deviceID: string | undefined;
    bi_remain_money: number;
    bi_method_payment: string | undefined;
    entities_id_arr: ItemBillingEntity[] | undefined;
    bi_cash_received: number;
    bi_qr_received: number;
    bi_rifd_received: number;
    total_cash_all_billing_before: number;
    bi_code_before: string | undefined;
    bi_money: number;
    di_id: number;
    bi_created_at: Date;
    rifdCode: string;
}

export class CheckoutQRCodePaymentDto implements ICheckoutQRCodePaymentDto {
    pa_ba_id!: number;
    pa_ba_tranId!: string | undefined;
    bi_code!: string | undefined;
    pa_ba_money!: number;

    constructor(data?: ICheckoutQRCodePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pa_ba_id = _data["pa_ba_id"];
            this.pa_ba_tranId = _data["pa_ba_tranId"];
            this.bi_code = _data["bi_code"];
            this.pa_ba_money = _data["pa_ba_money"];
        }
    }

    static fromJS(data: any): CheckoutQRCodePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutQRCodePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pa_ba_id"] = this.pa_ba_id;
        data["pa_ba_tranId"] = this.pa_ba_tranId;
        data["bi_code"] = this.bi_code;
        data["pa_ba_money"] = this.pa_ba_money;
        return data;
    }

    clone(): CheckoutQRCodePaymentDto {
        const json = this.toJSON();
        let result = new CheckoutQRCodePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICheckoutQRCodePaymentDto {
    pa_ba_id: number;
    pa_ba_tranId: string | undefined;
    bi_code: string | undefined;
    pa_ba_money: number;
}

export class CheckoutRifdPaymentDto implements ICheckoutRifdPaymentDto {
    rf_lo_Id!: number;
    bi_code!: string | undefined;
    has_rfid_code!: boolean;
    rf_money!: number;
    rf_money_discount!: number;
    rf_money_total!: number;

    constructor(data?: ICheckoutRifdPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_lo_Id = _data["rf_lo_Id"];
            this.bi_code = _data["bi_code"];
            this.has_rfid_code = _data["has_rfid_code"];
            this.rf_money = _data["rf_money"];
            this.rf_money_discount = _data["rf_money_discount"];
            this.rf_money_total = _data["rf_money_total"];
        }
    }

    static fromJS(data: any): CheckoutRifdPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutRifdPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_lo_Id"] = this.rf_lo_Id;
        data["bi_code"] = this.bi_code;
        data["has_rfid_code"] = this.has_rfid_code;
        data["rf_money"] = this.rf_money;
        data["rf_money_discount"] = this.rf_money_discount;
        data["rf_money_total"] = this.rf_money_total;
        return data;
    }

    clone(): CheckoutRifdPaymentDto {
        const json = this.toJSON();
        let result = new CheckoutRifdPaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICheckoutRifdPaymentDto {
    rf_lo_Id: number;
    bi_code: string | undefined;
    has_rfid_code: boolean;
    rf_money: number;
    rf_money_discount: number;
    rf_money_total: number;
}

export class Claim implements IClaim {
    readonly issuer!: string | undefined;
    readonly originalIssuer!: string | undefined;
    readonly properties!: { [key: string]: string; } | undefined;
    subject!: ClaimsIdentity;
    readonly type!: string | undefined;
    readonly value!: string | undefined;
    readonly valueType!: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuer = _data["issuer"];
            (<any>this).originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            (<any>this).type = _data["type"];
            (<any>this).value = _data["value"];
            (<any>this).valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }

    clone(): Claim {
        const json = this.toJSON();
        let result = new Claim();
        result.init(json);
        return result;
    }
}

export interface IClaim {
    issuer: string | undefined;
    originalIssuer: string | undefined;
    properties: { [key: string]: string; } | undefined;
    subject: ClaimsIdentity;
    type: string | undefined;
    value: string | undefined;
    valueType: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    readonly authenticationType!: string | undefined;
    readonly isAuthenticated!: boolean;
    actor!: ClaimsIdentity;
    bootstrapContext!: any | undefined;
    readonly claims!: Claim[] | undefined;
    label!: string | undefined;
    readonly name!: string | undefined;
    readonly nameClaimType!: string | undefined;
    readonly roleClaimType!: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            this.label = _data["label"];
            (<any>this).name = _data["name"];
            (<any>this).nameClaimType = _data["nameClaimType"];
            (<any>this).roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }

    clone(): ClaimsIdentity {
        const json = this.toJSON();
        let result = new ClaimsIdentity();
        result.init(json);
        return result;
    }
}

export interface IClaimsIdentity {
    authenticationType: string | undefined;
    isAuthenticated: boolean;
    actor: ClaimsIdentity;
    bootstrapContext: any | undefined;
    claims: Claim[] | undefined;
    label: string | undefined;
    name: string | undefined;
    nameClaimType: string | undefined;
    roleClaimType: string | undefined;
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    readonly claims!: Claim[] | undefined;
    readonly identities!: ClaimsIdentity[] | undefined;
    identity!: IIdentity;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            if (Array.isArray(_data["identities"])) {
                (<any>this).identities = [] as any;
                for (let item of _data["identities"])
                    (<any>this).identities!.push(ClaimsIdentity.fromJS(item));
            }
            this.identity = _data["identity"] ? IIdentity.fromJS(_data["identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.identities)) {
            data["identities"] = [];
            for (let item of this.identities)
                data["identities"].push(item.toJSON());
        }
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data;
    }

    clone(): ClaimsPrincipal {
        const json = this.toJSON();
        let result = new ClaimsPrincipal();
        result.init(json);
        return result;
    }
}

export interface IClaimsPrincipal {
    claims: Claim[] | undefined;
    identities: ClaimsIdentity[] | undefined;
    identity: IIdentity;
}

export class ConnectionInfo implements IConnectionInfo {
    id!: string | undefined;
    remoteIpAddress!: IPAddress;
    remotePort!: number;
    localIpAddress!: IPAddress;
    localPort!: number;
    clientCertificate!: X509Certificate2;

    constructor(data?: IConnectionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.remoteIpAddress = _data["remoteIpAddress"] ? IPAddress.fromJS(_data["remoteIpAddress"]) : <any>undefined;
            this.remotePort = _data["remotePort"];
            this.localIpAddress = _data["localIpAddress"] ? IPAddress.fromJS(_data["localIpAddress"]) : <any>undefined;
            this.localPort = _data["localPort"];
            this.clientCertificate = _data["clientCertificate"] ? X509Certificate2.fromJS(_data["clientCertificate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConnectionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["remoteIpAddress"] = this.remoteIpAddress ? this.remoteIpAddress.toJSON() : <any>undefined;
        data["remotePort"] = this.remotePort;
        data["localIpAddress"] = this.localIpAddress ? this.localIpAddress.toJSON() : <any>undefined;
        data["localPort"] = this.localPort;
        data["clientCertificate"] = this.clientCertificate ? this.clientCertificate.toJSON() : <any>undefined;
        return data;
    }

    clone(): ConnectionInfo {
        const json = this.toJSON();
        let result = new ConnectionInfo();
        result.init(json);
        return result;
    }
}

export interface IConnectionInfo {
    id: string | undefined;
    remoteIpAddress: IPAddress;
    remotePort: number;
    localIpAddress: IPAddress;
    localPort: number;
    clientCertificate: X509Certificate2;
}

export class ConstructorInfo implements IConstructorInfo {
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    memberType!: MemberTypes;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        return data;
    }

    clone(): ConstructorInfo {
        const json = this.toJSON();
        let result = new ConstructorInfo();
        result.init(json);
        return result;
    }
}

export interface IConstructorInfo {
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    memberType: MemberTypes;
}

export class CreateApplicationExtInput implements ICreateApplicationExtInput {
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: ICreateApplicationExtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): CreateApplicationExtInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationExtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): CreateApplicationExtInput {
        const json = this.toJSON();
        let result = new CreateApplicationExtInput();
        result.init(json);
        return result;
    }
}

export interface ICreateApplicationExtInput {
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class CreateAuthorizationMachineInput implements ICreateAuthorizationMachineInput {
    ma_id_list!: number[] | undefined;
    us_id_is_authorized!: number;
    au_ma_type!: EAuthorizationMachineType;
    tenantId!: number | undefined;

    constructor(data?: ICreateAuthorizationMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            this.us_id_is_authorized = _data["us_id_is_authorized"];
            this.au_ma_type = _data["au_ma_type"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateAuthorizationMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAuthorizationMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        data["us_id_is_authorized"] = this.us_id_is_authorized;
        data["au_ma_type"] = this.au_ma_type;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateAuthorizationMachineInput {
        const json = this.toJSON();
        let result = new CreateAuthorizationMachineInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAuthorizationMachineInput {
    ma_id_list: number[] | undefined;
    us_id_is_authorized: number;
    au_ma_type: EAuthorizationMachineType;
    tenantId: number | undefined;
}

export class CreateBillingInput implements ICreateBillingInput {
    bi_code!: string | undefined;
    deviceID!: string | undefined;
    bi_remain_money!: number;
    bi_method_payment!: string | undefined;
    entities_id_arr!: ItemBillingEntity[] | undefined;
    bi_cash_received!: number;
    bi_qr_received!: number;
    bi_rifd_received!: number;
    total_cash_all_billing_before!: number;
    bi_code_before!: string | undefined;
    bi_money!: number;
    di_id!: number;
    bi_created_at!: Date;

    constructor(data?: ICreateBillingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.deviceID = _data["deviceID"];
            this.bi_remain_money = _data["bi_remain_money"];
            this.bi_method_payment = _data["bi_method_payment"];
            if (Array.isArray(_data["entities_id_arr"])) {
                this.entities_id_arr = [] as any;
                for (let item of _data["entities_id_arr"])
                    this.entities_id_arr!.push(ItemBillingEntity.fromJS(item));
            }
            this.bi_cash_received = _data["bi_cash_received"];
            this.bi_qr_received = _data["bi_qr_received"];
            this.bi_rifd_received = _data["bi_rifd_received"];
            this.total_cash_all_billing_before = _data["total_cash_all_billing_before"];
            this.bi_code_before = _data["bi_code_before"];
            this.bi_money = _data["bi_money"];
            this.di_id = _data["di_id"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateBillingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBillingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["deviceID"] = this.deviceID;
        data["bi_remain_money"] = this.bi_remain_money;
        data["bi_method_payment"] = this.bi_method_payment;
        if (Array.isArray(this.entities_id_arr)) {
            data["entities_id_arr"] = [];
            for (let item of this.entities_id_arr)
                data["entities_id_arr"].push(item.toJSON());
        }
        data["bi_cash_received"] = this.bi_cash_received;
        data["bi_qr_received"] = this.bi_qr_received;
        data["bi_rifd_received"] = this.bi_rifd_received;
        data["total_cash_all_billing_before"] = this.total_cash_all_billing_before;
        data["bi_code_before"] = this.bi_code_before;
        data["bi_money"] = this.bi_money;
        data["di_id"] = this.di_id;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateBillingInput {
        const json = this.toJSON();
        let result = new CreateBillingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBillingInput {
    bi_code: string | undefined;
    deviceID: string | undefined;
    bi_remain_money: number;
    bi_method_payment: string | undefined;
    entities_id_arr: ItemBillingEntity[] | undefined;
    bi_cash_received: number;
    bi_qr_received: number;
    bi_rifd_received: number;
    total_cash_all_billing_before: number;
    bi_code_before: string | undefined;
    bi_money: number;
    di_id: number;
    bi_created_at: Date;
}

export class CreateDiscountCodeInput implements ICreateDiscountCodeInput {
    di_code!: string | undefined;
    di_desc!: string | undefined;
    di_price!: number;
    di_quantity_max!: number;
    di_start_at!: Date | undefined;
    di_end_at!: Date | undefined;
    di_active!: boolean;
    ma_id_list!: number[] | undefined;

    constructor(data?: ICreateDiscountCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.di_code = _data["di_code"];
            this.di_desc = _data["di_desc"];
            this.di_price = _data["di_price"];
            this.di_quantity_max = _data["di_quantity_max"];
            this.di_start_at = _data["di_start_at"] ? new Date(_data["di_start_at"].toString()) : <any>undefined;
            this.di_end_at = _data["di_end_at"] ? new Date(_data["di_end_at"].toString()) : <any>undefined;
            this.di_active = _data["di_active"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateDiscountCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDiscountCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["di_code"] = this.di_code;
        data["di_desc"] = this.di_desc;
        data["di_price"] = this.di_price;
        data["di_quantity_max"] = this.di_quantity_max;
        data["di_start_at"] = this.di_start_at ? this.di_start_at.toISOString() : <any>undefined;
        data["di_end_at"] = this.di_end_at ? this.di_end_at.toISOString() : <any>undefined;
        data["di_active"] = this.di_active;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        return data;
    }

    clone(): CreateDiscountCodeInput {
        const json = this.toJSON();
        let result = new CreateDiscountCodeInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDiscountCodeInput {
    di_code: string | undefined;
    di_desc: string | undefined;
    di_price: number;
    di_quantity_max: number;
    di_start_at: Date | undefined;
    di_end_at: Date | undefined;
    di_active: boolean;
    ma_id_list: number[] | undefined;
}

export class CreateDrinkInput implements ICreateDrinkInput {
    dr_name!: string | undefined;
    dr_image!: AttachmentItem;
    dr_desc!: string | undefined;
    su_id!: number;
    dr_price!: number;

    constructor(data?: ICreateDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dr_name = _data["dr_name"];
            this.dr_image = _data["dr_image"] ? AttachmentItem.fromJS(_data["dr_image"]) : <any>undefined;
            this.dr_desc = _data["dr_desc"];
            this.su_id = _data["su_id"];
            this.dr_price = _data["dr_price"];
        }
    }

    static fromJS(data: any): CreateDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dr_name"] = this.dr_name;
        data["dr_image"] = this.dr_image ? this.dr_image.toJSON() : <any>undefined;
        data["dr_desc"] = this.dr_desc;
        data["su_id"] = this.su_id;
        data["dr_price"] = this.dr_price;
        return data;
    }

    clone(): CreateDrinkInput {
        const json = this.toJSON();
        let result = new CreateDrinkInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDrinkInput {
    dr_name: string | undefined;
    dr_image: AttachmentItem;
    dr_desc: string | undefined;
    su_id: number;
    dr_price: number;
}

export class CreateFreshDrinkInput implements ICreateFreshDrinkInput {
    fr_dr_name!: string | undefined;
    fr_dr_image!: AttachmentItem;
    fr_dr_capacity!: number;
    fr_dr_price!: number;
    su_id!: number;

    constructor(data?: ICreateFreshDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fr_dr_name = _data["fr_dr_name"];
            this.fr_dr_image = _data["fr_dr_image"] ? AttachmentItem.fromJS(_data["fr_dr_image"]) : <any>undefined;
            this.fr_dr_capacity = _data["fr_dr_capacity"];
            this.fr_dr_price = _data["fr_dr_price"];
            this.su_id = _data["su_id"];
        }
    }

    static fromJS(data: any): CreateFreshDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFreshDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fr_dr_name"] = this.fr_dr_name;
        data["fr_dr_image"] = this.fr_dr_image ? this.fr_dr_image.toJSON() : <any>undefined;
        data["fr_dr_capacity"] = this.fr_dr_capacity;
        data["fr_dr_price"] = this.fr_dr_price;
        data["su_id"] = this.su_id;
        return data;
    }

    clone(): CreateFreshDrinkInput {
        const json = this.toJSON();
        let result = new CreateFreshDrinkInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFreshDrinkInput {
    fr_dr_name: string | undefined;
    fr_dr_image: AttachmentItem;
    fr_dr_capacity: number;
    fr_dr_price: number;
    su_id: number;
}

export class CreateGroupMachineInput implements ICreateGroupMachineInput {
    gr_ma_area!: string | undefined;
    gr_ma_desc!: string | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateGroupMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_ma_area = _data["gr_ma_area"];
            this.gr_ma_desc = _data["gr_ma_desc"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateGroupMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_ma_area"] = this.gr_ma_area;
        data["gr_ma_desc"] = this.gr_ma_desc;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateGroupMachineInput {
        const json = this.toJSON();
        let result = new CreateGroupMachineInput();
        result.init(json);
        return result;
    }
}

export interface ICreateGroupMachineInput {
    gr_ma_area: string | undefined;
    gr_ma_desc: string | undefined;
    tenantId: number | undefined;
}

export class CreateGroupTrashbinInput implements ICreateGroupTrashbinInput {
    gr_tr_name!: string | undefined;
    gr_tr_desc!: string | undefined;

    constructor(data?: ICreateGroupTrashbinInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_tr_name = _data["gr_tr_name"];
            this.gr_tr_desc = _data["gr_tr_desc"];
        }
    }

    static fromJS(data: any): CreateGroupTrashbinInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupTrashbinInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_tr_name"] = this.gr_tr_name;
        data["gr_tr_desc"] = this.gr_tr_desc;
        return data;
    }

    clone(): CreateGroupTrashbinInput {
        const json = this.toJSON();
        let result = new CreateGroupTrashbinInput();
        result.init(json);
        return result;
    }
}

export interface ICreateGroupTrashbinInput {
    gr_tr_name: string | undefined;
    gr_tr_desc: string | undefined;
}

export class CreateHandoverInput implements ICreateHandoverInput {
    handover_user!: number;
    receive_user!: number;
    ha_status!: EHandoverStatus;
    ha_type!: EHandoverType;
    ha_note!: string | undefined;
    ma_id_list!: number[] | undefined;
    productHandoverInputs!: ProductHandoverInput[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateHandoverInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handover_user = _data["handover_user"];
            this.receive_user = _data["receive_user"];
            this.ha_status = _data["ha_status"];
            this.ha_type = _data["ha_type"];
            this.ha_note = _data["ha_note"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            if (Array.isArray(_data["productHandoverInputs"])) {
                this.productHandoverInputs = [] as any;
                for (let item of _data["productHandoverInputs"])
                    this.productHandoverInputs!.push(ProductHandoverInput.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateHandoverInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHandoverInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["handover_user"] = this.handover_user;
        data["receive_user"] = this.receive_user;
        data["ha_status"] = this.ha_status;
        data["ha_type"] = this.ha_type;
        data["ha_note"] = this.ha_note;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        if (Array.isArray(this.productHandoverInputs)) {
            data["productHandoverInputs"] = [];
            for (let item of this.productHandoverInputs)
                data["productHandoverInputs"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateHandoverInput {
        const json = this.toJSON();
        let result = new CreateHandoverInput();
        result.init(json);
        return result;
    }
}

export interface ICreateHandoverInput {
    handover_user: number;
    receive_user: number;
    ha_status: EHandoverStatus;
    ha_type: EHandoverType;
    ha_note: string | undefined;
    ma_id_list: number[] | undefined;
    productHandoverInputs: ProductHandoverInput[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CreateImportRepositoryInput implements ICreateImportRepositoryInput {
    im_re_code!: string | undefined;
    su_id!: number;
    re_id!: number;
    im_re_total_money!: number;
    im_re_debt!: number;
    im_re_note!: string | undefined;
    im_re_status!: EImportRepositoryStatus;
    im_re_imported_at!: Date;
    listProductImport!: ProductImportDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateImportRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_re_code = _data["im_re_code"];
            this.su_id = _data["su_id"];
            this.re_id = _data["re_id"];
            this.im_re_total_money = _data["im_re_total_money"];
            this.im_re_debt = _data["im_re_debt"];
            this.im_re_note = _data["im_re_note"];
            this.im_re_status = _data["im_re_status"];
            this.im_re_imported_at = _data["im_re_imported_at"] ? new Date(_data["im_re_imported_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listProductImport"])) {
                this.listProductImport = [] as any;
                for (let item of _data["listProductImport"])
                    this.listProductImport!.push(ProductImportDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateImportRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateImportRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_re_code"] = this.im_re_code;
        data["su_id"] = this.su_id;
        data["re_id"] = this.re_id;
        data["im_re_total_money"] = this.im_re_total_money;
        data["im_re_debt"] = this.im_re_debt;
        data["im_re_note"] = this.im_re_note;
        data["im_re_status"] = this.im_re_status;
        data["im_re_imported_at"] = this.im_re_imported_at ? this.im_re_imported_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listProductImport)) {
            data["listProductImport"] = [];
            for (let item of this.listProductImport)
                data["listProductImport"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateImportRepositoryInput {
        const json = this.toJSON();
        let result = new CreateImportRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateImportRepositoryInput {
    im_re_code: string | undefined;
    su_id: number;
    re_id: number;
    im_re_total_money: number;
    im_re_debt: number;
    im_re_note: string | undefined;
    im_re_status: EImportRepositoryStatus;
    im_re_imported_at: Date;
    listProductImport: ProductImportDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CreateLayoutInput implements ICreateLayoutInput {
    la_name!: string | undefined;
    la_type!: string | undefined;
    la_desc!: string | undefined;
    layoutSlotDtos!: LayoutSlotDto[] | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateLayoutInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_name = _data["la_name"];
            this.la_type = _data["la_type"];
            this.la_desc = _data["la_desc"];
            if (Array.isArray(_data["layoutSlotDtos"])) {
                this.layoutSlotDtos = [] as any;
                for (let item of _data["layoutSlotDtos"])
                    this.layoutSlotDtos!.push(LayoutSlotDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateLayoutInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLayoutInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_name"] = this.la_name;
        data["la_type"] = this.la_type;
        data["la_desc"] = this.la_desc;
        if (Array.isArray(this.layoutSlotDtos)) {
            data["layoutSlotDtos"] = [];
            for (let item of this.layoutSlotDtos)
                data["layoutSlotDtos"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateLayoutInput {
        const json = this.toJSON();
        let result = new CreateLayoutInput();
        result.init(json);
        return result;
    }
}

export interface ICreateLayoutInput {
    la_name: string | undefined;
    la_type: string | undefined;
    la_desc: string | undefined;
    layoutSlotDtos: LayoutSlotDto[] | undefined;
    tenantId: number | undefined;
}

export class CreateLossRepositoryInput implements ICreateLossRepositoryInput {
    lo_re_code!: string | undefined;
    us_id_import!: number;
    re_id!: number;
    lo_re_reason!: string | undefined;
    lo_re_status!: ELossRepositoryStatus;
    listProductLoss!: ProductLossDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateLossRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lo_re_code = _data["lo_re_code"];
            this.us_id_import = _data["us_id_import"];
            this.re_id = _data["re_id"];
            this.lo_re_reason = _data["lo_re_reason"];
            this.lo_re_status = _data["lo_re_status"];
            if (Array.isArray(_data["listProductLoss"])) {
                this.listProductLoss = [] as any;
                for (let item of _data["listProductLoss"])
                    this.listProductLoss!.push(ProductLossDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateLossRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLossRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lo_re_code"] = this.lo_re_code;
        data["us_id_import"] = this.us_id_import;
        data["re_id"] = this.re_id;
        data["lo_re_reason"] = this.lo_re_reason;
        data["lo_re_status"] = this.lo_re_status;
        if (Array.isArray(this.listProductLoss)) {
            data["listProductLoss"] = [];
            for (let item of this.listProductLoss)
                data["listProductLoss"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateLossRepositoryInput {
        const json = this.toJSON();
        let result = new CreateLossRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateLossRepositoryInput {
    lo_re_code: string | undefined;
    us_id_import: number;
    re_id: number;
    lo_re_reason: string | undefined;
    lo_re_status: ELossRepositoryStatus;
    listProductLoss: ProductLossDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CreateMachineLocationLogInput implements ICreateMachineLocationLogInput {
    ma_id!: number;
    ma_lo_log_mapName!: string | undefined;
    ma_lo_log_mapUrl!: string | undefined;

    constructor(data?: ICreateMachineLocationLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.ma_lo_log_mapName = _data["ma_lo_log_mapName"];
            this.ma_lo_log_mapUrl = _data["ma_lo_log_mapUrl"];
        }
    }

    static fromJS(data: any): CreateMachineLocationLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMachineLocationLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["ma_lo_log_mapName"] = this.ma_lo_log_mapName;
        data["ma_lo_log_mapUrl"] = this.ma_lo_log_mapUrl;
        return data;
    }

    clone(): CreateMachineLocationLogInput {
        const json = this.toJSON();
        let result = new CreateMachineLocationLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMachineLocationLogInput {
    ma_id: number;
    ma_lo_log_mapName: string | undefined;
    ma_lo_log_mapUrl: string | undefined;
}

export class CreateMachineLogsInput implements ICreateMachineLogsInput {
    entities_id!: number;
    ma_lo_type!: MachineLogsType;
    ma_lo_data!: string | undefined;
    ma_log_display!: string | undefined;

    constructor(data?: ICreateMachineLogsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entities_id = _data["entities_id"];
            this.ma_lo_type = _data["ma_lo_type"];
            this.ma_lo_data = _data["ma_lo_data"];
            this.ma_log_display = _data["ma_log_display"];
        }
    }

    static fromJS(data: any): CreateMachineLogsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMachineLogsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entities_id"] = this.entities_id;
        data["ma_lo_type"] = this.ma_lo_type;
        data["ma_lo_data"] = this.ma_lo_data;
        data["ma_log_display"] = this.ma_log_display;
        return data;
    }

    clone(): CreateMachineLogsInput {
        const json = this.toJSON();
        let result = new CreateMachineLogsInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMachineLogsInput {
    entities_id: number;
    ma_lo_type: MachineLogsType;
    ma_lo_data: string | undefined;
    ma_log_display: string | undefined;
}

export class CreateMachineSoftInput implements ICreateMachineSoftInput {
    ma_so_version_name!: string | undefined;
    ma_so_version_code!: number;
    ma_id_list!: number[] | undefined;
    fi_id!: AttachmentItem;
    tenantId!: number | undefined;

    constructor(data?: ICreateMachineSoftInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_so_version_name = _data["ma_so_version_name"];
            this.ma_so_version_code = _data["ma_so_version_code"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateMachineSoftInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMachineSoftInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_so_version_name"] = this.ma_so_version_name;
        data["ma_so_version_code"] = this.ma_so_version_code;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateMachineSoftInput {
        const json = this.toJSON();
        let result = new CreateMachineSoftInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMachineSoftInput {
    ma_so_version_name: string | undefined;
    ma_so_version_code: number;
    ma_id_list: number[] | undefined;
    fi_id: AttachmentItem;
    tenantId: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreateProductInput implements ICreateProductInput {
    pr_name!: string | undefined;
    pr_desc!: string | undefined;
    pr_unit!: string | undefined;
    pr_price!: number;
    pr_type!: EDrinkType;
    tenantId!: number | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: ICreateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_name = _data["pr_name"];
            this.pr_desc = _data["pr_desc"];
            this.pr_unit = _data["pr_unit"];
            this.pr_price = _data["pr_price"];
            this.pr_type = _data["pr_type"];
            this.tenantId = _data["tenantId"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_name"] = this.pr_name;
        data["pr_desc"] = this.pr_desc;
        data["pr_unit"] = this.pr_unit;
        data["pr_price"] = this.pr_price;
        data["pr_type"] = this.pr_type;
        data["tenantId"] = this.tenantId;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateProductInput {
        const json = this.toJSON();
        let result = new CreateProductInput();
        result.init(json);
        return result;
    }
}

export interface ICreateProductInput {
    pr_name: string | undefined;
    pr_desc: string | undefined;
    pr_unit: string | undefined;
    pr_price: number;
    pr_type: EDrinkType;
    tenantId: number | undefined;
    fi_id: AttachmentItem;
}

export class CreateQRCodePaymentInput implements ICreateQRCodePaymentInput {
    bi_code!: string | undefined;
    deviceID!: string | undefined;
    bi_remain_money!: number;
    bi_method_payment!: string | undefined;
    entities_id_arr!: ItemBillingEntity[] | undefined;
    bi_cash_received!: number;
    bi_qr_received!: number;
    bi_rifd_received!: number;
    total_cash_all_billing_before!: number;
    bi_code_before!: string | undefined;
    bi_money!: number;
    di_id!: number;
    bi_created_at!: Date;

    constructor(data?: ICreateQRCodePaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.deviceID = _data["deviceID"];
            this.bi_remain_money = _data["bi_remain_money"];
            this.bi_method_payment = _data["bi_method_payment"];
            if (Array.isArray(_data["entities_id_arr"])) {
                this.entities_id_arr = [] as any;
                for (let item of _data["entities_id_arr"])
                    this.entities_id_arr!.push(ItemBillingEntity.fromJS(item));
            }
            this.bi_cash_received = _data["bi_cash_received"];
            this.bi_qr_received = _data["bi_qr_received"];
            this.bi_rifd_received = _data["bi_rifd_received"];
            this.total_cash_all_billing_before = _data["total_cash_all_billing_before"];
            this.bi_code_before = _data["bi_code_before"];
            this.bi_money = _data["bi_money"];
            this.di_id = _data["di_id"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateQRCodePaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQRCodePaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["deviceID"] = this.deviceID;
        data["bi_remain_money"] = this.bi_remain_money;
        data["bi_method_payment"] = this.bi_method_payment;
        if (Array.isArray(this.entities_id_arr)) {
            data["entities_id_arr"] = [];
            for (let item of this.entities_id_arr)
                data["entities_id_arr"].push(item.toJSON());
        }
        data["bi_cash_received"] = this.bi_cash_received;
        data["bi_qr_received"] = this.bi_qr_received;
        data["bi_rifd_received"] = this.bi_rifd_received;
        data["total_cash_all_billing_before"] = this.total_cash_all_billing_before;
        data["bi_code_before"] = this.bi_code_before;
        data["bi_money"] = this.bi_money;
        data["di_id"] = this.di_id;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateQRCodePaymentInput {
        const json = this.toJSON();
        let result = new CreateQRCodePaymentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateQRCodePaymentInput {
    bi_code: string | undefined;
    deviceID: string | undefined;
    bi_remain_money: number;
    bi_method_payment: string | undefined;
    entities_id_arr: ItemBillingEntity[] | undefined;
    bi_cash_received: number;
    bi_qr_received: number;
    bi_rifd_received: number;
    total_cash_all_billing_before: number;
    bi_code_before: string | undefined;
    bi_money: number;
    di_id: number;
    bi_created_at: Date;
}

export class CreateRefundInput implements ICreateRefundInput {
    bi_code!: string | undefined;
    ref_status!: string | undefined;
    ref_code!: string | undefined;
    deviceID!: string | undefined;
    ref_money!: number;
    ref_phone!: string | undefined;

    constructor(data?: ICreateRefundInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.ref_status = _data["ref_status"];
            this.ref_code = _data["ref_code"];
            this.deviceID = _data["deviceID"];
            this.ref_money = _data["ref_money"];
            this.ref_phone = _data["ref_phone"];
        }
    }

    static fromJS(data: any): CreateRefundInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRefundInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["ref_status"] = this.ref_status;
        data["ref_code"] = this.ref_code;
        data["deviceID"] = this.deviceID;
        data["ref_money"] = this.ref_money;
        data["ref_phone"] = this.ref_phone;
        return data;
    }

    clone(): CreateRefundInput {
        const json = this.toJSON();
        let result = new CreateRefundInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRefundInput {
    bi_code: string | undefined;
    ref_status: string | undefined;
    ref_code: string | undefined;
    deviceID: string | undefined;
    ref_money: number;
    ref_phone: string | undefined;
}

export class CreateRepositoryDetailInput implements ICreateRepositoryDetailInput {
    re_id!: number;
    pr_id!: number;
    pr_quantity!: number;
    pr_quantity_quydoi!: number;
    pr_total_quantity_quydoi!: number;
    pr_unit_quydoi!: string | undefined;
    pr_price!: number;

    constructor(data?: ICreateRepositoryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.pr_id = _data["pr_id"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_quantity_quydoi = _data["pr_quantity_quydoi"];
            this.pr_total_quantity_quydoi = _data["pr_total_quantity_quydoi"];
            this.pr_unit_quydoi = _data["pr_unit_quydoi"];
            this.pr_price = _data["pr_price"];
        }
    }

    static fromJS(data: any): CreateRepositoryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepositoryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["pr_id"] = this.pr_id;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_quantity_quydoi"] = this.pr_quantity_quydoi;
        data["pr_total_quantity_quydoi"] = this.pr_total_quantity_quydoi;
        data["pr_unit_quydoi"] = this.pr_unit_quydoi;
        data["pr_price"] = this.pr_price;
        return data;
    }

    clone(): CreateRepositoryDetailInput {
        const json = this.toJSON();
        let result = new CreateRepositoryDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRepositoryDetailInput {
    re_id: number;
    pr_id: number;
    pr_quantity: number;
    pr_quantity_quydoi: number;
    pr_total_quantity_quydoi: number;
    pr_unit_quydoi: string | undefined;
    pr_price: number;
}

export class CreateRepositoryInput implements ICreateRepositoryInput {
    us_id_operator!: number;
    re_name!: string | undefined;
    re_desc!: string | undefined;
    re_parent_id!: number;
    re_type!: ERepositoryType;
    ma_id_arr!: number[] | undefined;

    constructor(data?: ICreateRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.us_id_operator = _data["us_id_operator"];
            this.re_name = _data["re_name"];
            this.re_desc = _data["re_desc"];
            this.re_parent_id = _data["re_parent_id"];
            this.re_type = _data["re_type"];
            if (Array.isArray(_data["ma_id_arr"])) {
                this.ma_id_arr = [] as any;
                for (let item of _data["ma_id_arr"])
                    this.ma_id_arr!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["us_id_operator"] = this.us_id_operator;
        data["re_name"] = this.re_name;
        data["re_desc"] = this.re_desc;
        data["re_parent_id"] = this.re_parent_id;
        data["re_type"] = this.re_type;
        if (Array.isArray(this.ma_id_arr)) {
            data["ma_id_arr"] = [];
            for (let item of this.ma_id_arr)
                data["ma_id_arr"].push(item);
        }
        return data;
    }

    clone(): CreateRepositoryInput {
        const json = this.toJSON();
        let result = new CreateRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRepositoryInput {
    us_id_operator: number;
    re_name: string | undefined;
    re_desc: string | undefined;
    re_parent_id: number;
    re_type: ERepositoryType;
    ma_id_arr: number[] | undefined;
}

export class CreateRfidInput implements ICreateRfidInput {
    rf_code!: string | undefined;
    rf_money_current!: number;
    rf_money_current_sale!: number;
    tenantId!: number | undefined;
    rf_type_drink_payment!: RFIDTypeDrinkPayment;
    rf_is_active!: boolean;

    constructor(data?: ICreateRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_code = _data["rf_code"];
            this.rf_money_current = _data["rf_money_current"];
            this.rf_money_current_sale = _data["rf_money_current_sale"];
            this.tenantId = _data["tenantId"];
            this.rf_type_drink_payment = _data["rf_type_drink_payment"];
            this.rf_is_active = _data["rf_is_active"];
        }
    }

    static fromJS(data: any): CreateRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_code"] = this.rf_code;
        data["rf_money_current"] = this.rf_money_current;
        data["rf_money_current_sale"] = this.rf_money_current_sale;
        data["tenantId"] = this.tenantId;
        data["rf_type_drink_payment"] = this.rf_type_drink_payment;
        data["rf_is_active"] = this.rf_is_active;
        return data;
    }

    clone(): CreateRfidInput {
        const json = this.toJSON();
        let result = new CreateRfidInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRfidInput {
    rf_code: string | undefined;
    rf_money_current: number;
    rf_money_current_sale: number;
    tenantId: number | undefined;
    rf_type_drink_payment: RFIDTypeDrinkPayment;
    rf_is_active: boolean;
}

export class CreateRoleInput implements ICreateRoleInput {
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    isDefault!: boolean;
    tenantId!: number;
    grantedPermissions!: string[] | undefined;

    constructor(data?: ICreateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleInput {
        const json = this.toJSON();
        let result = new CreateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleInput {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    tenantId: number;
    grantedPermissions: string[] | undefined;
}

export class CreateSupplierInput implements ICreateSupplierInput {
    su_name!: string | undefined;
    su_phone!: string | undefined;
    su_address!: string | undefined;
    su_email!: string | undefined;
    su_contact_person!: string | undefined;
    su_note!: string | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateSupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_name = _data["su_name"];
            this.su_phone = _data["su_phone"];
            this.su_address = _data["su_address"];
            this.su_email = _data["su_email"];
            this.su_contact_person = _data["su_contact_person"];
            this.su_note = _data["su_note"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateSupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_name"] = this.su_name;
        data["su_phone"] = this.su_phone;
        data["su_address"] = this.su_address;
        data["su_email"] = this.su_email;
        data["su_contact_person"] = this.su_contact_person;
        data["su_note"] = this.su_note;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateSupplierInput {
        const json = this.toJSON();
        let result = new CreateSupplierInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSupplierInput {
    su_name: string | undefined;
    su_phone: string | undefined;
    su_address: string | undefined;
    su_email: string | undefined;
    su_contact_person: string | undefined;
    su_note: string | undefined;
    tenantId: number | undefined;
}

export class CreateSwallowCashMachineInput implements ICreateSwallowCashMachineInput {
    sw_code!: string | undefined;
    sw_money!: number;
    deviceId!: string | undefined;

    constructor(data?: ICreateSwallowCashMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sw_code = _data["sw_code"];
            this.sw_money = _data["sw_money"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): CreateSwallowCashMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSwallowCashMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sw_code"] = this.sw_code;
        data["sw_money"] = this.sw_money;
        data["deviceId"] = this.deviceId;
        return data;
    }

    clone(): CreateSwallowCashMachineInput {
        const json = this.toJSON();
        let result = new CreateSwallowCashMachineInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSwallowCashMachineInput {
    sw_code: string | undefined;
    sw_money: number;
    deviceId: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    connectionString!: string | undefined;
    vCBInformationPayment!: VCBInformationPayment;
    mOMOInformationPayment!: MoMoInformationPayment;
    vnPayInformationPayment!: VNPayInformationPayment;
    maxNumberOfMachine!: number;
    isActive!: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.vCBInformationPayment = _data["vCBInformationPayment"] ? VCBInformationPayment.fromJS(_data["vCBInformationPayment"]) : <any>undefined;
            this.mOMOInformationPayment = _data["mOMOInformationPayment"] ? MoMoInformationPayment.fromJS(_data["mOMOInformationPayment"]) : <any>undefined;
            this.vnPayInformationPayment = _data["vnPayInformationPayment"] ? VNPayInformationPayment.fromJS(_data["vnPayInformationPayment"]) : <any>undefined;
            this.maxNumberOfMachine = _data["maxNumberOfMachine"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["vCBInformationPayment"] = this.vCBInformationPayment ? this.vCBInformationPayment.toJSON() : <any>undefined;
        data["mOMOInformationPayment"] = this.mOMOInformationPayment ? this.mOMOInformationPayment.toJSON() : <any>undefined;
        data["vnPayInformationPayment"] = this.vnPayInformationPayment ? this.vnPayInformationPayment.toJSON() : <any>undefined;
        data["maxNumberOfMachine"] = this.maxNumberOfMachine;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    vCBInformationPayment: VCBInformationPayment;
    mOMOInformationPayment: MoMoInformationPayment;
    vnPayInformationPayment: VNPayInformationPayment;
    maxNumberOfMachine: number;
    isActive: boolean;
}

export class CreateTranferRepositoryInput implements ICreateTranferRepositoryInput {
    re_id_transfer!: number;
    re_id_receiver!: number;
    tr_re_total_money!: number;
    tr_re_note!: string | undefined;
    tr_re_status!: ETranferRepositoryStatus;
    listProductTranfer!: ProductTranferDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateTranferRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id_transfer = _data["re_id_transfer"];
            this.re_id_receiver = _data["re_id_receiver"];
            this.tr_re_total_money = _data["tr_re_total_money"];
            this.tr_re_note = _data["tr_re_note"];
            this.tr_re_status = _data["tr_re_status"];
            if (Array.isArray(_data["listProductTranfer"])) {
                this.listProductTranfer = [] as any;
                for (let item of _data["listProductTranfer"])
                    this.listProductTranfer!.push(ProductTranferDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTranferRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTranferRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id_transfer"] = this.re_id_transfer;
        data["re_id_receiver"] = this.re_id_receiver;
        data["tr_re_total_money"] = this.tr_re_total_money;
        data["tr_re_note"] = this.tr_re_note;
        data["tr_re_status"] = this.tr_re_status;
        if (Array.isArray(this.listProductTranfer)) {
            data["listProductTranfer"] = [];
            for (let item of this.listProductTranfer)
                data["listProductTranfer"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateTranferRepositoryInput {
        const json = this.toJSON();
        let result = new CreateTranferRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTranferRepositoryInput {
    re_id_transfer: number;
    re_id_receiver: number;
    tr_re_total_money: number;
    tr_re_note: string | undefined;
    tr_re_status: ETranferRepositoryStatus;
    listProductTranfer: ProductTranferDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CreateTrashBinInput implements ICreateTrashBinInput {
    tr_name!: string | undefined;
    deviceMAC!: string | undefined;
    tr_urlMap!: string | undefined;
    tr_tien_quy_doi_theo_rac!: number;
    gr_tr_id!: number;
    tr_type!: ETrashType;
    tr_note!: string | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateTrashBinInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_name = _data["tr_name"];
            this.deviceMAC = _data["deviceMAC"];
            this.tr_urlMap = _data["tr_urlMap"];
            this.tr_tien_quy_doi_theo_rac = _data["tr_tien_quy_doi_theo_rac"];
            this.gr_tr_id = _data["gr_tr_id"];
            this.tr_type = _data["tr_type"];
            this.tr_note = _data["tr_note"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateTrashBinInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrashBinInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_name"] = this.tr_name;
        data["deviceMAC"] = this.deviceMAC;
        data["tr_urlMap"] = this.tr_urlMap;
        data["tr_tien_quy_doi_theo_rac"] = this.tr_tien_quy_doi_theo_rac;
        data["gr_tr_id"] = this.gr_tr_id;
        data["tr_type"] = this.tr_type;
        data["tr_note"] = this.tr_note;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateTrashBinInput {
        const json = this.toJSON();
        let result = new CreateTrashBinInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTrashBinInput {
    tr_name: string | undefined;
    deviceMAC: string | undefined;
    tr_urlMap: string | undefined;
    tr_tien_quy_doi_theo_rac: number;
    gr_tr_id: number;
    tr_type: ETrashType;
    tr_note: string | undefined;
    tenantId: number | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    roleNames!: string[] | undefined;
    password!: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class CreateWithdrawBankInput implements ICreateWithdrawBankInput {
    rec_id!: number;
    wi_total_money_reality!: number;
    ma_id!: number;
    wi_payment_type!: BillMethod;
    wi_note!: string | undefined;
    wi_start_date!: Date | undefined;
    wi_end_date!: Date | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateWithdrawBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.wi_total_money_reality = _data["wi_total_money_reality"];
            this.ma_id = _data["ma_id"];
            this.wi_payment_type = _data["wi_payment_type"];
            this.wi_note = _data["wi_note"];
            this.wi_start_date = _data["wi_start_date"] ? new Date(_data["wi_start_date"].toString()) : <any>undefined;
            this.wi_end_date = _data["wi_end_date"] ? new Date(_data["wi_end_date"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWithdrawBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWithdrawBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["wi_total_money_reality"] = this.wi_total_money_reality;
        data["ma_id"] = this.ma_id;
        data["wi_payment_type"] = this.wi_payment_type;
        data["wi_note"] = this.wi_note;
        data["wi_start_date"] = this.wi_start_date ? this.wi_start_date.toISOString() : <any>undefined;
        data["wi_end_date"] = this.wi_end_date ? this.wi_end_date.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateWithdrawBankInput {
        const json = this.toJSON();
        let result = new CreateWithdrawBankInput();
        result.init(json);
        return result;
    }
}

export interface ICreateWithdrawBankInput {
    rec_id: number;
    wi_total_money_reality: number;
    ma_id: number;
    wi_payment_type: BillMethod;
    wi_note: string | undefined;
    wi_start_date: Date | undefined;
    wi_end_date: Date | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CreateWithdrawCashInput implements ICreateWithdrawCashInput {
    rec_id!: number[] | undefined;
    wi_total_money_reality!: number;
    ma_id!: number;
    wi_payment_type!: BillMethod;
    wi_note!: string | undefined;
    wi_start_date!: Date | undefined;
    wi_end_date!: Date | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: ICreateWithdrawCashInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rec_id"])) {
                this.rec_id = [] as any;
                for (let item of _data["rec_id"])
                    this.rec_id!.push(item);
            }
            this.wi_total_money_reality = _data["wi_total_money_reality"];
            this.ma_id = _data["ma_id"];
            this.wi_payment_type = _data["wi_payment_type"];
            this.wi_note = _data["wi_note"];
            this.wi_start_date = _data["wi_start_date"] ? new Date(_data["wi_start_date"].toString()) : <any>undefined;
            this.wi_end_date = _data["wi_end_date"] ? new Date(_data["wi_end_date"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWithdrawCashInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWithdrawCashInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rec_id)) {
            data["rec_id"] = [];
            for (let item of this.rec_id)
                data["rec_id"].push(item);
        }
        data["wi_total_money_reality"] = this.wi_total_money_reality;
        data["ma_id"] = this.ma_id;
        data["wi_payment_type"] = this.wi_payment_type;
        data["wi_note"] = this.wi_note;
        data["wi_start_date"] = this.wi_start_date ? this.wi_start_date.toISOString() : <any>undefined;
        data["wi_end_date"] = this.wi_end_date ? this.wi_end_date.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateWithdrawCashInput {
        const json = this.toJSON();
        let result = new CreateWithdrawCashInput();
        result.init(json);
        return result;
    }
}

export interface ICreateWithdrawCashInput {
    rec_id: number[] | undefined;
    wi_total_money_reality: number;
    ma_id: number;
    wi_payment_type: BillMethod;
    wi_note: string | undefined;
    wi_start_date: Date | undefined;
    wi_end_date: Date | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType!: Type;
    constructor_!: ConstructorInfo;
    readonly constructorArguments!: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments!: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustomAttributeData {
        const json = this.toJSON();
        let result = new CustomAttributeData();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeData {
    attributeType: Type;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[] | undefined;
    namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo!: MemberInfo;
    typedValue!: CustomAttributeTypedArgument;
    readonly memberName!: string | undefined;
    readonly isField!: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }

    clone(): CustomAttributeNamedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeNamedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string | undefined;
    isField: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType!: Type;
    value!: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }

    clone(): CustomAttributeTypedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeTypedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: Type;
    value: any | undefined;
}

export class CustomNotificationData implements ICustomNotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;
    message!: string | undefined;
    route!: string | undefined;
    value!: string | undefined;

    constructor(data?: ICustomNotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.message = _data["message"];
            this.route = _data["route"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomNotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomNotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["message"] = this.message;
        data["route"] = this.route;
        data["value"] = this.value;
        return data;
    }

    clone(): CustomNotificationData {
        const json = this.toJSON();
        let result = new CustomNotificationData();
        result.init(json);
        return result;
    }
}

export interface ICustomNotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
    message: string | undefined;
    route: string | undefined;
    value: string | undefined;
}

export class CustomUserNotification implements ICustomUserNotification {
    userNotification!: UserNotification;
    customData!: CustomNotificationData;

    constructor(data?: ICustomUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNotification = _data["userNotification"] ? UserNotification.fromJS(_data["userNotification"]) : <any>undefined;
            this.customData = _data["customData"] ? CustomNotificationData.fromJS(_data["customData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomUserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new CustomUserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNotification"] = this.userNotification ? this.userNotification.toJSON() : <any>undefined;
        data["customData"] = this.customData ? this.customData.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomUserNotification {
        const json = this.toJSON();
        let result = new CustomUserNotification();
        result.init(json);
        return result;
    }
}

export interface ICustomUserNotification {
    userNotification: UserNotification;
    customData: CustomNotificationData;
}

export class DashboardCombinationDto implements IDashboardCombinationDto {
    top5ProductOfMoneyToday!: ItemChartDashBoard[] | undefined;
    top5ProductOfQuantityToday!: ItemChartDashBoard[] | undefined;
    numberOfBillingByPaymentToday!: StatisticBillingOfPaymentDto[] | undefined;
    topProductOfMoneyAndQuantity!: ItemChartDashBoardCombination[] | undefined;
    topRefundMoneyMachine!: ItemChartDashBoardCombination[] | undefined;

    constructor(data?: IDashboardCombinationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["top5ProductOfMoneyToday"])) {
                this.top5ProductOfMoneyToday = [] as any;
                for (let item of _data["top5ProductOfMoneyToday"])
                    this.top5ProductOfMoneyToday!.push(ItemChartDashBoard.fromJS(item));
            }
            if (Array.isArray(_data["top5ProductOfQuantityToday"])) {
                this.top5ProductOfQuantityToday = [] as any;
                for (let item of _data["top5ProductOfQuantityToday"])
                    this.top5ProductOfQuantityToday!.push(ItemChartDashBoard.fromJS(item));
            }
            if (Array.isArray(_data["numberOfBillingByPaymentToday"])) {
                this.numberOfBillingByPaymentToday = [] as any;
                for (let item of _data["numberOfBillingByPaymentToday"])
                    this.numberOfBillingByPaymentToday!.push(StatisticBillingOfPaymentDto.fromJS(item));
            }
            if (Array.isArray(_data["topProductOfMoneyAndQuantity"])) {
                this.topProductOfMoneyAndQuantity = [] as any;
                for (let item of _data["topProductOfMoneyAndQuantity"])
                    this.topProductOfMoneyAndQuantity!.push(ItemChartDashBoardCombination.fromJS(item));
            }
            if (Array.isArray(_data["topRefundMoneyMachine"])) {
                this.topRefundMoneyMachine = [] as any;
                for (let item of _data["topRefundMoneyMachine"])
                    this.topRefundMoneyMachine!.push(ItemChartDashBoardCombination.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardCombinationDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardCombinationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.top5ProductOfMoneyToday)) {
            data["top5ProductOfMoneyToday"] = [];
            for (let item of this.top5ProductOfMoneyToday)
                data["top5ProductOfMoneyToday"].push(item.toJSON());
        }
        if (Array.isArray(this.top5ProductOfQuantityToday)) {
            data["top5ProductOfQuantityToday"] = [];
            for (let item of this.top5ProductOfQuantityToday)
                data["top5ProductOfQuantityToday"].push(item.toJSON());
        }
        if (Array.isArray(this.numberOfBillingByPaymentToday)) {
            data["numberOfBillingByPaymentToday"] = [];
            for (let item of this.numberOfBillingByPaymentToday)
                data["numberOfBillingByPaymentToday"].push(item.toJSON());
        }
        if (Array.isArray(this.topProductOfMoneyAndQuantity)) {
            data["topProductOfMoneyAndQuantity"] = [];
            for (let item of this.topProductOfMoneyAndQuantity)
                data["topProductOfMoneyAndQuantity"].push(item.toJSON());
        }
        if (Array.isArray(this.topRefundMoneyMachine)) {
            data["topRefundMoneyMachine"] = [];
            for (let item of this.topRefundMoneyMachine)
                data["topRefundMoneyMachine"].push(item.toJSON());
        }
        return data;
    }

    clone(): DashboardCombinationDto {
        const json = this.toJSON();
        let result = new DashboardCombinationDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardCombinationDto {
    top5ProductOfMoneyToday: ItemChartDashBoard[] | undefined;
    top5ProductOfQuantityToday: ItemChartDashBoard[] | undefined;
    numberOfBillingByPaymentToday: StatisticBillingOfPaymentDto[] | undefined;
    topProductOfMoneyAndQuantity: ItemChartDashBoardCombination[] | undefined;
    topRefundMoneyMachine: ItemChartDashBoardCombination[] | undefined;
}

export class DashboardDto implements IDashboardDto {
    key!: string | undefined;
    totalMachine!: number;
    totalMachineOnline!: number;
    totalMachineOffline!: number;
    totalMachineAbnormality_Error!: number;
    totalMachineOutOfStock!: number;
    totalMoneyToDay!: number;
    totalMoneyCashToDay!: number;
    totalMoneyQrToDay!: number;
    totalMoneyRfidToDay!: number;
    totalMoneyYesterday!: number;
    totalMoneyCashYesterday!: number;
    totalMoneyQrYesterday!: number;
    totalMoneyRfidYesterday!: number;
    totalMoneyToWeek!: number;
    totalMoneyCashToWeek!: number;
    totalMoneyQrToWeek!: number;
    totalMoneyRfidToWeek!: number;
    totalMoneyToMonth!: number;
    totalMoneyCashToMonth!: number;
    totalMoneyQrToMonth!: number;
    totalMoneyRfidToMonth!: number;
    totalMoneyToLastMonth!: number;
    totalMoneyCashToLastMonth!: number;
    totalMoneyQrToLastMonth!: number;
    totalMoneyRfidToLastMonth!: number;
    totalValueOfDiscountToDay!: number;
    totalValueOfDiscountYesterday!: number;
    totalValueOfDiscountToWeek!: number;
    totalValueOfDiscountToMonth!: number;
    totalValueOfDiscountToLastMonth!: number;
    totalMoneyRefundToday!: number;
    totalMoneyRefundYesterday!: number;
    totalMoneyRefundWeek!: number;
    totalMoneyRefundMonth!: number;
    totalMoneyRefundLastMonth!: number;
    totalMoneySwallowToday!: number;
    totalMoneySwallowYesterday!: number;
    totalMoneySwallowWeek!: number;
    totalMoneySwallowMonth!: number;
    totalMoneySwallowLastMonth!: number;
    totalTrashToday!: number;
    totalTrashYesterday!: number;
    totalTrashWeek!: number;
    totalTrashMonth!: number;
    totalTrashLastMonth!: number;
    totalCarbonCredit!: number;
    totalPlasticCredit!: number;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.totalMachine = _data["totalMachine"];
            this.totalMachineOnline = _data["totalMachineOnline"];
            this.totalMachineOffline = _data["totalMachineOffline"];
            this.totalMachineAbnormality_Error = _data["totalMachineAbnormality_Error"];
            this.totalMachineOutOfStock = _data["totalMachineOutOfStock"];
            this.totalMoneyToDay = _data["totalMoneyToDay"];
            this.totalMoneyCashToDay = _data["totalMoneyCashToDay"];
            this.totalMoneyQrToDay = _data["totalMoneyQrToDay"];
            this.totalMoneyRfidToDay = _data["totalMoneyRfidToDay"];
            this.totalMoneyYesterday = _data["totalMoneyYesterday"];
            this.totalMoneyCashYesterday = _data["totalMoneyCashYesterday"];
            this.totalMoneyQrYesterday = _data["totalMoneyQrYesterday"];
            this.totalMoneyRfidYesterday = _data["totalMoneyRfidYesterday"];
            this.totalMoneyToWeek = _data["totalMoneyToWeek"];
            this.totalMoneyCashToWeek = _data["totalMoneyCashToWeek"];
            this.totalMoneyQrToWeek = _data["totalMoneyQrToWeek"];
            this.totalMoneyRfidToWeek = _data["totalMoneyRfidToWeek"];
            this.totalMoneyToMonth = _data["totalMoneyToMonth"];
            this.totalMoneyCashToMonth = _data["totalMoneyCashToMonth"];
            this.totalMoneyQrToMonth = _data["totalMoneyQrToMonth"];
            this.totalMoneyRfidToMonth = _data["totalMoneyRfidToMonth"];
            this.totalMoneyToLastMonth = _data["totalMoneyToLastMonth"];
            this.totalMoneyCashToLastMonth = _data["totalMoneyCashToLastMonth"];
            this.totalMoneyQrToLastMonth = _data["totalMoneyQrToLastMonth"];
            this.totalMoneyRfidToLastMonth = _data["totalMoneyRfidToLastMonth"];
            this.totalValueOfDiscountToDay = _data["totalValueOfDiscountToDay"];
            this.totalValueOfDiscountYesterday = _data["totalValueOfDiscountYesterday"];
            this.totalValueOfDiscountToWeek = _data["totalValueOfDiscountToWeek"];
            this.totalValueOfDiscountToMonth = _data["totalValueOfDiscountToMonth"];
            this.totalValueOfDiscountToLastMonth = _data["totalValueOfDiscountToLastMonth"];
            this.totalMoneyRefundToday = _data["totalMoneyRefundToday"];
            this.totalMoneyRefundYesterday = _data["totalMoneyRefundYesterday"];
            this.totalMoneyRefundWeek = _data["totalMoneyRefundWeek"];
            this.totalMoneyRefundMonth = _data["totalMoneyRefundMonth"];
            this.totalMoneyRefundLastMonth = _data["totalMoneyRefundLastMonth"];
            this.totalMoneySwallowToday = _data["totalMoneySwallowToday"];
            this.totalMoneySwallowYesterday = _data["totalMoneySwallowYesterday"];
            this.totalMoneySwallowWeek = _data["totalMoneySwallowWeek"];
            this.totalMoneySwallowMonth = _data["totalMoneySwallowMonth"];
            this.totalMoneySwallowLastMonth = _data["totalMoneySwallowLastMonth"];
            this.totalTrashToday = _data["totalTrashToday"];
            this.totalTrashYesterday = _data["totalTrashYesterday"];
            this.totalTrashWeek = _data["totalTrashWeek"];
            this.totalTrashMonth = _data["totalTrashMonth"];
            this.totalTrashLastMonth = _data["totalTrashLastMonth"];
            this.totalCarbonCredit = _data["totalCarbonCredit"];
            this.totalPlasticCredit = _data["totalPlasticCredit"];
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["totalMachine"] = this.totalMachine;
        data["totalMachineOnline"] = this.totalMachineOnline;
        data["totalMachineOffline"] = this.totalMachineOffline;
        data["totalMachineAbnormality_Error"] = this.totalMachineAbnormality_Error;
        data["totalMachineOutOfStock"] = this.totalMachineOutOfStock;
        data["totalMoneyToDay"] = this.totalMoneyToDay;
        data["totalMoneyCashToDay"] = this.totalMoneyCashToDay;
        data["totalMoneyQrToDay"] = this.totalMoneyQrToDay;
        data["totalMoneyRfidToDay"] = this.totalMoneyRfidToDay;
        data["totalMoneyYesterday"] = this.totalMoneyYesterday;
        data["totalMoneyCashYesterday"] = this.totalMoneyCashYesterday;
        data["totalMoneyQrYesterday"] = this.totalMoneyQrYesterday;
        data["totalMoneyRfidYesterday"] = this.totalMoneyRfidYesterday;
        data["totalMoneyToWeek"] = this.totalMoneyToWeek;
        data["totalMoneyCashToWeek"] = this.totalMoneyCashToWeek;
        data["totalMoneyQrToWeek"] = this.totalMoneyQrToWeek;
        data["totalMoneyRfidToWeek"] = this.totalMoneyRfidToWeek;
        data["totalMoneyToMonth"] = this.totalMoneyToMonth;
        data["totalMoneyCashToMonth"] = this.totalMoneyCashToMonth;
        data["totalMoneyQrToMonth"] = this.totalMoneyQrToMonth;
        data["totalMoneyRfidToMonth"] = this.totalMoneyRfidToMonth;
        data["totalMoneyToLastMonth"] = this.totalMoneyToLastMonth;
        data["totalMoneyCashToLastMonth"] = this.totalMoneyCashToLastMonth;
        data["totalMoneyQrToLastMonth"] = this.totalMoneyQrToLastMonth;
        data["totalMoneyRfidToLastMonth"] = this.totalMoneyRfidToLastMonth;
        data["totalValueOfDiscountToDay"] = this.totalValueOfDiscountToDay;
        data["totalValueOfDiscountYesterday"] = this.totalValueOfDiscountYesterday;
        data["totalValueOfDiscountToWeek"] = this.totalValueOfDiscountToWeek;
        data["totalValueOfDiscountToMonth"] = this.totalValueOfDiscountToMonth;
        data["totalValueOfDiscountToLastMonth"] = this.totalValueOfDiscountToLastMonth;
        data["totalMoneyRefundToday"] = this.totalMoneyRefundToday;
        data["totalMoneyRefundYesterday"] = this.totalMoneyRefundYesterday;
        data["totalMoneyRefundWeek"] = this.totalMoneyRefundWeek;
        data["totalMoneyRefundMonth"] = this.totalMoneyRefundMonth;
        data["totalMoneyRefundLastMonth"] = this.totalMoneyRefundLastMonth;
        data["totalMoneySwallowToday"] = this.totalMoneySwallowToday;
        data["totalMoneySwallowYesterday"] = this.totalMoneySwallowYesterday;
        data["totalMoneySwallowWeek"] = this.totalMoneySwallowWeek;
        data["totalMoneySwallowMonth"] = this.totalMoneySwallowMonth;
        data["totalMoneySwallowLastMonth"] = this.totalMoneySwallowLastMonth;
        data["totalTrashToday"] = this.totalTrashToday;
        data["totalTrashYesterday"] = this.totalTrashYesterday;
        data["totalTrashWeek"] = this.totalTrashWeek;
        data["totalTrashMonth"] = this.totalTrashMonth;
        data["totalTrashLastMonth"] = this.totalTrashLastMonth;
        data["totalCarbonCredit"] = this.totalCarbonCredit;
        data["totalPlasticCredit"] = this.totalPlasticCredit;
        return data;
    }

    clone(): DashboardDto {
        const json = this.toJSON();
        let result = new DashboardDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardDto {
    key: string | undefined;
    totalMachine: number;
    totalMachineOnline: number;
    totalMachineOffline: number;
    totalMachineAbnormality_Error: number;
    totalMachineOutOfStock: number;
    totalMoneyToDay: number;
    totalMoneyCashToDay: number;
    totalMoneyQrToDay: number;
    totalMoneyRfidToDay: number;
    totalMoneyYesterday: number;
    totalMoneyCashYesterday: number;
    totalMoneyQrYesterday: number;
    totalMoneyRfidYesterday: number;
    totalMoneyToWeek: number;
    totalMoneyCashToWeek: number;
    totalMoneyQrToWeek: number;
    totalMoneyRfidToWeek: number;
    totalMoneyToMonth: number;
    totalMoneyCashToMonth: number;
    totalMoneyQrToMonth: number;
    totalMoneyRfidToMonth: number;
    totalMoneyToLastMonth: number;
    totalMoneyCashToLastMonth: number;
    totalMoneyQrToLastMonth: number;
    totalMoneyRfidToLastMonth: number;
    totalValueOfDiscountToDay: number;
    totalValueOfDiscountYesterday: number;
    totalValueOfDiscountToWeek: number;
    totalValueOfDiscountToMonth: number;
    totalValueOfDiscountToLastMonth: number;
    totalMoneyRefundToday: number;
    totalMoneyRefundYesterday: number;
    totalMoneyRefundWeek: number;
    totalMoneyRefundMonth: number;
    totalMoneyRefundLastMonth: number;
    totalMoneySwallowToday: number;
    totalMoneySwallowYesterday: number;
    totalMoneySwallowWeek: number;
    totalMoneySwallowMonth: number;
    totalMoneySwallowLastMonth: number;
    totalTrashToday: number;
    totalTrashYesterday: number;
    totalTrashWeek: number;
    totalTrashMonth: number;
    totalTrashLastMonth: number;
    totalCarbonCredit: number;
    totalPlasticCredit: number;
}

export class DiscountCodeDto implements IDiscountCodeDto {
    di_id!: number;
    di_code!: string | undefined;
    di_desc!: string | undefined;
    di_price!: number;
    di_quantity_use!: number;
    di_quantity_max!: number;
    di_start_at!: Date | undefined;
    di_end_at!: Date | undefined;
    di_active!: boolean;
    di_is_deleted!: boolean;
    ma_id_list!: number[] | undefined;
    di_created_at!: Date;

    constructor(data?: IDiscountCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.di_id = _data["di_id"];
            this.di_code = _data["di_code"];
            this.di_desc = _data["di_desc"];
            this.di_price = _data["di_price"];
            this.di_quantity_use = _data["di_quantity_use"];
            this.di_quantity_max = _data["di_quantity_max"];
            this.di_start_at = _data["di_start_at"] ? new Date(_data["di_start_at"].toString()) : <any>undefined;
            this.di_end_at = _data["di_end_at"] ? new Date(_data["di_end_at"].toString()) : <any>undefined;
            this.di_active = _data["di_active"];
            this.di_is_deleted = _data["di_is_deleted"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            this.di_created_at = _data["di_created_at"] ? new Date(_data["di_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscountCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["di_id"] = this.di_id;
        data["di_code"] = this.di_code;
        data["di_desc"] = this.di_desc;
        data["di_price"] = this.di_price;
        data["di_quantity_use"] = this.di_quantity_use;
        data["di_quantity_max"] = this.di_quantity_max;
        data["di_start_at"] = this.di_start_at ? this.di_start_at.toISOString() : <any>undefined;
        data["di_end_at"] = this.di_end_at ? this.di_end_at.toISOString() : <any>undefined;
        data["di_active"] = this.di_active;
        data["di_is_deleted"] = this.di_is_deleted;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        data["di_created_at"] = this.di_created_at ? this.di_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DiscountCodeDto {
        const json = this.toJSON();
        let result = new DiscountCodeDto();
        result.init(json);
        return result;
    }
}

export interface IDiscountCodeDto {
    di_id: number;
    di_code: string | undefined;
    di_desc: string | undefined;
    di_price: number;
    di_quantity_use: number;
    di_quantity_max: number;
    di_start_at: Date | undefined;
    di_end_at: Date | undefined;
    di_active: boolean;
    di_is_deleted: boolean;
    ma_id_list: number[] | undefined;
    di_created_at: Date;
}

export class DiscountCodeDtoPagedResultDto implements IDiscountCodeDtoPagedResultDto {
    items!: DiscountCodeDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDiscountCodeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DiscountCodeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DiscountCodeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountCodeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DiscountCodeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DiscountCodeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDiscountCodeDtoPagedResultDto {
    items: DiscountCodeDto[] | undefined;
    totalCount: number;
}

export class DrinkDto implements IDrinkDto {
    dr_id!: number;
    dr_code!: string | undefined;
    dr_name!: string | undefined;
    dr_image!: AttachmentItem;
    dr_desc!: string | undefined;
    su_id!: number;
    dr_is_deleted!: boolean;
    dr_price!: number;

    constructor(data?: IDrinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dr_id = _data["dr_id"];
            this.dr_code = _data["dr_code"];
            this.dr_name = _data["dr_name"];
            this.dr_image = _data["dr_image"] ? AttachmentItem.fromJS(_data["dr_image"]) : <any>undefined;
            this.dr_desc = _data["dr_desc"];
            this.su_id = _data["su_id"];
            this.dr_is_deleted = _data["dr_is_deleted"];
            this.dr_price = _data["dr_price"];
        }
    }

    static fromJS(data: any): DrinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new DrinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dr_id"] = this.dr_id;
        data["dr_code"] = this.dr_code;
        data["dr_name"] = this.dr_name;
        data["dr_image"] = this.dr_image ? this.dr_image.toJSON() : <any>undefined;
        data["dr_desc"] = this.dr_desc;
        data["su_id"] = this.su_id;
        data["dr_is_deleted"] = this.dr_is_deleted;
        data["dr_price"] = this.dr_price;
        return data;
    }

    clone(): DrinkDto {
        const json = this.toJSON();
        let result = new DrinkDto();
        result.init(json);
        return result;
    }
}

export interface IDrinkDto {
    dr_id: number;
    dr_code: string | undefined;
    dr_name: string | undefined;
    dr_image: AttachmentItem;
    dr_desc: string | undefined;
    su_id: number;
    dr_is_deleted: boolean;
    dr_price: number;
}

export class DrinkDtoPagedResultDto implements IDrinkDtoPagedResultDto {
    items!: DrinkDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDrinkDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DrinkDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DrinkDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DrinkDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DrinkDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DrinkDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDrinkDtoPagedResultDto {
    items: DrinkDto[] | undefined;
    totalCount: number;
}

export enum DrinkType {
    _0 = 0,
    _1 = 1,
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export class EventInfo implements IEventInfo {
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    memberType!: MemberTypes;
    attributes!: EventAttributes;
    readonly isSpecialName!: boolean;
    addMethod!: MethodInfo;
    removeMethod!: MethodInfo;
    raiseMethod!: MethodInfo;
    readonly isMulticast!: boolean;
    eventHandlerType!: Type;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        return data;
    }

    clone(): EventInfo {
        const json = this.toJSON();
        let result = new EventInfo();
        result.init(json);
        return result;
    }
}

export interface IEventInfo {
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    memberType: MemberTypes;
    attributes: EventAttributes;
    isSpecialName: boolean;
    addMethod: MethodInfo;
    removeMethod: MethodInfo;
    raiseMethod: MethodInfo;
    isMulticast: boolean;
    eventHandlerType: Type;
}

export class ExcelReconcileBankInput implements IExcelReconcileBankInput {
    bi_code!: string | undefined;
    bi_money!: number;
    bi_create!: Date;

    constructor(data?: IExcelReconcileBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.bi_money = _data["bi_money"];
            this.bi_create = _data["bi_create"] ? new Date(_data["bi_create"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExcelReconcileBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelReconcileBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["bi_money"] = this.bi_money;
        data["bi_create"] = this.bi_create ? this.bi_create.toISOString() : <any>undefined;
        return data;
    }

    clone(): ExcelReconcileBankInput {
        const json = this.toJSON();
        let result = new ExcelReconcileBankInput();
        result.init(json);
        return result;
    }
}

export interface IExcelReconcileBankInput {
    bi_code: string | undefined;
    bi_money: number;
    bi_create: Date;
}

export class ExcelReconcileDto implements IExcelReconcileDto {
    ex_code!: string | undefined;
    ex_money!: number;
    ex_reconcile_status!: EBillReconcileStatus;
    ex_reconcile_at!: Date;
    ex_created_at!: Date;
    ex_reconcile_reason!: string | undefined;

    constructor(data?: IExcelReconcileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ex_code = _data["ex_code"];
            this.ex_money = _data["ex_money"];
            this.ex_reconcile_status = _data["ex_reconcile_status"];
            this.ex_reconcile_at = _data["ex_reconcile_at"] ? new Date(_data["ex_reconcile_at"].toString()) : <any>undefined;
            this.ex_created_at = _data["ex_created_at"] ? new Date(_data["ex_created_at"].toString()) : <any>undefined;
            this.ex_reconcile_reason = _data["ex_reconcile_reason"];
        }
    }

    static fromJS(data: any): ExcelReconcileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelReconcileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ex_code"] = this.ex_code;
        data["ex_money"] = this.ex_money;
        data["ex_reconcile_status"] = this.ex_reconcile_status;
        data["ex_reconcile_at"] = this.ex_reconcile_at ? this.ex_reconcile_at.toISOString() : <any>undefined;
        data["ex_created_at"] = this.ex_created_at ? this.ex_created_at.toISOString() : <any>undefined;
        data["ex_reconcile_reason"] = this.ex_reconcile_reason;
        return data;
    }

    clone(): ExcelReconcileDto {
        const json = this.toJSON();
        let result = new ExcelReconcileDto();
        result.init(json);
        return result;
    }
}

export interface IExcelReconcileDto {
    ex_code: string | undefined;
    ex_money: number;
    ex_reconcile_status: EBillReconcileStatus;
    ex_reconcile_at: Date;
    ex_created_at: Date;
    ex_reconcile_reason: string | undefined;
}

export class ExcelReconcileRFIDInput implements IExcelReconcileRFIDInput {
    rf_code!: string | undefined;
    rf_money!: number;
    rf_create!: Date;

    constructor(data?: IExcelReconcileRFIDInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_code = _data["rf_code"];
            this.rf_money = _data["rf_money"];
            this.rf_create = _data["rf_create"] ? new Date(_data["rf_create"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExcelReconcileRFIDInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelReconcileRFIDInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_code"] = this.rf_code;
        data["rf_money"] = this.rf_money;
        data["rf_create"] = this.rf_create ? this.rf_create.toISOString() : <any>undefined;
        return data;
    }

    clone(): ExcelReconcileRFIDInput {
        const json = this.toJSON();
        let result = new ExcelReconcileRFIDInput();
        result.init(json);
        return result;
    }
}

export interface IExcelReconcileRFIDInput {
    rf_code: string | undefined;
    rf_money: number;
    rf_create: Date;
}

export class ExcelReconcileSupplierDebtInput implements IExcelReconcileSupplierDebtInput {
    ma_phieu_nhap!: string | undefined;
    su_id!: number;
    productSupplierDebtInputs!: ReconcileProductSupplierDebtInput[] | undefined;
    pr_total_money!: number;

    constructor(data?: IExcelReconcileSupplierDebtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_phieu_nhap = _data["ma_phieu_nhap"];
            this.su_id = _data["su_id"];
            if (Array.isArray(_data["productSupplierDebtInputs"])) {
                this.productSupplierDebtInputs = [] as any;
                for (let item of _data["productSupplierDebtInputs"])
                    this.productSupplierDebtInputs!.push(ReconcileProductSupplierDebtInput.fromJS(item));
            }
            this.pr_total_money = _data["pr_total_money"];
        }
    }

    static fromJS(data: any): ExcelReconcileSupplierDebtInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelReconcileSupplierDebtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_phieu_nhap"] = this.ma_phieu_nhap;
        data["su_id"] = this.su_id;
        if (Array.isArray(this.productSupplierDebtInputs)) {
            data["productSupplierDebtInputs"] = [];
            for (let item of this.productSupplierDebtInputs)
                data["productSupplierDebtInputs"].push(item.toJSON());
        }
        data["pr_total_money"] = this.pr_total_money;
        return data;
    }

    clone(): ExcelReconcileSupplierDebtInput {
        const json = this.toJSON();
        let result = new ExcelReconcileSupplierDebtInput();
        result.init(json);
        return result;
    }
}

export interface IExcelReconcileSupplierDebtInput {
    ma_phieu_nhap: string | undefined;
    su_id: number;
    productSupplierDebtInputs: ReconcileProductSupplierDebtInput[] | undefined;
    pr_total_money: number;
}

export class ExportRepository implements IExportRepository {
    id!: number;
    readonly ex_re_id!: number;
    ex_re_code!: string | undefined;
    ma_id!: number;
    ex_re_quantity!: number;
    re_id!: number;
    im_id!: number;
    ex_re_created_at!: Date;
    listProductExport!: string | undefined;
    tenantId!: number;
    machine!: Machine;
    repository!: Repository;
    importing!: Importing;

    constructor(data?: IExportRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).ex_re_id = _data["ex_re_id"];
            this.ex_re_code = _data["ex_re_code"];
            this.ma_id = _data["ma_id"];
            this.ex_re_quantity = _data["ex_re_quantity"];
            this.re_id = _data["re_id"];
            this.im_id = _data["im_id"];
            this.ex_re_created_at = _data["ex_re_created_at"] ? new Date(_data["ex_re_created_at"].toString()) : <any>undefined;
            this.listProductExport = _data["listProductExport"];
            this.tenantId = _data["tenantId"];
            this.machine = _data["machine"] ? Machine.fromJS(_data["machine"]) : <any>undefined;
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.importing = _data["importing"] ? Importing.fromJS(_data["importing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportRepository {
        data = typeof data === 'object' ? data : {};
        let result = new ExportRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ex_re_id"] = this.ex_re_id;
        data["ex_re_code"] = this.ex_re_code;
        data["ma_id"] = this.ma_id;
        data["ex_re_quantity"] = this.ex_re_quantity;
        data["re_id"] = this.re_id;
        data["im_id"] = this.im_id;
        data["ex_re_created_at"] = this.ex_re_created_at ? this.ex_re_created_at.toISOString() : <any>undefined;
        data["listProductExport"] = this.listProductExport;
        data["tenantId"] = this.tenantId;
        data["machine"] = this.machine ? this.machine.toJSON() : <any>undefined;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["importing"] = this.importing ? this.importing.toJSON() : <any>undefined;
        return data;
    }

    clone(): ExportRepository {
        const json = this.toJSON();
        let result = new ExportRepository();
        result.init(json);
        return result;
    }
}

export interface IExportRepository {
    id: number;
    ex_re_id: number;
    ex_re_code: string | undefined;
    ma_id: number;
    ex_re_quantity: number;
    re_id: number;
    im_id: number;
    ex_re_created_at: Date;
    listProductExport: string | undefined;
    tenantId: number;
    machine: Machine;
    repository: Repository;
    importing: Importing;
}

export class ExportRepositoryDto implements IExportRepositoryDto {
    ex_re_id!: number;
    ex_re_code!: string | undefined;
    ma_id!: number;
    re_id!: number;
    im_id!: number;
    ex_re_quantity!: number;
    ex_re_created_at!: Date;
    machineDto!: MachineAbstractDto;
    repostitoryDto!: RepositoryAbstractDto;
    importingDto!: ImportingDto;
    listProductExport!: ProductExportDto[] | undefined;

    constructor(data?: IExportRepositoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ex_re_id = _data["ex_re_id"];
            this.ex_re_code = _data["ex_re_code"];
            this.ma_id = _data["ma_id"];
            this.re_id = _data["re_id"];
            this.im_id = _data["im_id"];
            this.ex_re_quantity = _data["ex_re_quantity"];
            this.ex_re_created_at = _data["ex_re_created_at"] ? new Date(_data["ex_re_created_at"].toString()) : <any>undefined;
            this.machineDto = _data["machineDto"] ? MachineAbstractDto.fromJS(_data["machineDto"]) : <any>undefined;
            this.repostitoryDto = _data["repostitoryDto"] ? RepositoryAbstractDto.fromJS(_data["repostitoryDto"]) : <any>undefined;
            this.importingDto = _data["importingDto"] ? ImportingDto.fromJS(_data["importingDto"]) : <any>undefined;
            if (Array.isArray(_data["listProductExport"])) {
                this.listProductExport = [] as any;
                for (let item of _data["listProductExport"])
                    this.listProductExport!.push(ProductExportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportRepositoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportRepositoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ex_re_id"] = this.ex_re_id;
        data["ex_re_code"] = this.ex_re_code;
        data["ma_id"] = this.ma_id;
        data["re_id"] = this.re_id;
        data["im_id"] = this.im_id;
        data["ex_re_quantity"] = this.ex_re_quantity;
        data["ex_re_created_at"] = this.ex_re_created_at ? this.ex_re_created_at.toISOString() : <any>undefined;
        data["machineDto"] = this.machineDto ? this.machineDto.toJSON() : <any>undefined;
        data["repostitoryDto"] = this.repostitoryDto ? this.repostitoryDto.toJSON() : <any>undefined;
        data["importingDto"] = this.importingDto ? this.importingDto.toJSON() : <any>undefined;
        if (Array.isArray(this.listProductExport)) {
            data["listProductExport"] = [];
            for (let item of this.listProductExport)
                data["listProductExport"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportRepositoryDto {
        const json = this.toJSON();
        let result = new ExportRepositoryDto();
        result.init(json);
        return result;
    }
}

export interface IExportRepositoryDto {
    ex_re_id: number;
    ex_re_code: string | undefined;
    ma_id: number;
    re_id: number;
    im_id: number;
    ex_re_quantity: number;
    ex_re_created_at: Date;
    machineDto: MachineAbstractDto;
    repostitoryDto: RepositoryAbstractDto;
    importingDto: ImportingDto;
    listProductExport: ProductExportDto[] | undefined;
}

export class ExportRepositoryDtoPagedResultDto implements IExportRepositoryDtoPagedResultDto {
    items!: ExportRepositoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IExportRepositoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExportRepositoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExportRepositoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportRepositoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ExportRepositoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ExportRepositoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IExportRepositoryDtoPagedResultDto {
    items: ExportRepositoryDto[] | undefined;
    totalCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalLoginProviderInfoModelListResultDto implements IExternalLoginProviderInfoModelListResultDto {
    items!: ExternalLoginProviderInfoModel[] | undefined;

    constructor(data?: IExternalLoginProviderInfoModelListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModelListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModelListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExternalLoginProviderInfoModelListResultDto {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModelListResultDto();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModelListResultDto {
    items: ExternalLoginProviderInfoModel[] | undefined;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }

    clone(): ExternalLoginSettingsDto {
        const json = this.toJSON();
        let result = new ExternalLoginSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class FieldInfo implements IFieldInfo {
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    memberType!: MemberTypes;
    attributes!: FieldAttributes;
    fieldType!: Type;
    readonly isInitOnly!: boolean;
    readonly isLiteral!: boolean;
    readonly isNotSerialized!: boolean;
    readonly isPinvokeImpl!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    fieldHandle!: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        return data;
    }

    clone(): FieldInfo {
        const json = this.toJSON();
        let result = new FieldInfo();
        result.init(json);
        return result;
    }
}

export interface IFieldInfo {
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: Type;
    isInitOnly: boolean;
    isLiteral: boolean;
    isNotSerialized: boolean;
    isPinvokeImpl: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
}

export class FileDto implements IFileDto {
    fi_id!: number;
    us_id!: number;
    fi_name!: string | undefined;
    fi_decs!: string | undefined;
    fi_md5!: string | undefined;
    fi_type!: number;
    fi_state!: FileState;
    fi_path!: string | undefined;
    fi_extension!: string | undefined;
    fi_upload_from!: string | undefined;
    fi_size!: number;
    fi_created_at!: Date;
    fi_updated_at!: Date;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_id = _data["fi_id"];
            this.us_id = _data["us_id"];
            this.fi_name = _data["fi_name"];
            this.fi_decs = _data["fi_decs"];
            this.fi_md5 = _data["fi_md5"];
            this.fi_type = _data["fi_type"];
            this.fi_state = _data["fi_state"];
            this.fi_path = _data["fi_path"];
            this.fi_extension = _data["fi_extension"];
            this.fi_upload_from = _data["fi_upload_from"];
            this.fi_size = _data["fi_size"];
            this.fi_created_at = _data["fi_created_at"] ? new Date(_data["fi_created_at"].toString()) : <any>undefined;
            this.fi_updated_at = _data["fi_updated_at"] ? new Date(_data["fi_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_id"] = this.fi_id;
        data["us_id"] = this.us_id;
        data["fi_name"] = this.fi_name;
        data["fi_decs"] = this.fi_decs;
        data["fi_md5"] = this.fi_md5;
        data["fi_type"] = this.fi_type;
        data["fi_state"] = this.fi_state;
        data["fi_path"] = this.fi_path;
        data["fi_extension"] = this.fi_extension;
        data["fi_upload_from"] = this.fi_upload_from;
        data["fi_size"] = this.fi_size;
        data["fi_created_at"] = this.fi_created_at ? this.fi_created_at.toISOString() : <any>undefined;
        data["fi_updated_at"] = this.fi_updated_at ? this.fi_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fi_id: number;
    us_id: number;
    fi_name: string | undefined;
    fi_decs: string | undefined;
    fi_md5: string | undefined;
    fi_type: number;
    fi_state: FileState;
    fi_path: string | undefined;
    fi_extension: string | undefined;
    fi_upload_from: string | undefined;
    fi_size: number;
    fi_created_at: Date;
    fi_updated_at: Date;
}

export class FileDtoPagedResultDto implements IFileDtoPagedResultDto {
    items!: FileDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FileDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FileDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileDtoPagedResultDto {
    items: FileDto[] | undefined;
    totalCount: number;
}

export class FileMediaDto implements IFileMediaDto {
    fi_me_id!: number;
    fi_me_name!: string | undefined;
    fi_me_decs!: string | undefined;
    fi_me_md5!: string | undefined;
    fi_me_path!: string | undefined;
    fi_me_extension!: string | undefined;
    fi_me_upload_from!: string | undefined;
    fi_me_size!: number;
    fi_me_type!: ETypeFileMedia;
    fi_me_created_at!: Date;
    fi_me_updated_at!: Date;

    constructor(data?: IFileMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_me_id = _data["fi_me_id"];
            this.fi_me_name = _data["fi_me_name"];
            this.fi_me_decs = _data["fi_me_decs"];
            this.fi_me_md5 = _data["fi_me_md5"];
            this.fi_me_path = _data["fi_me_path"];
            this.fi_me_extension = _data["fi_me_extension"];
            this.fi_me_upload_from = _data["fi_me_upload_from"];
            this.fi_me_size = _data["fi_me_size"];
            this.fi_me_type = _data["fi_me_type"];
            this.fi_me_created_at = _data["fi_me_created_at"] ? new Date(_data["fi_me_created_at"].toString()) : <any>undefined;
            this.fi_me_updated_at = _data["fi_me_updated_at"] ? new Date(_data["fi_me_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_me_id"] = this.fi_me_id;
        data["fi_me_name"] = this.fi_me_name;
        data["fi_me_decs"] = this.fi_me_decs;
        data["fi_me_md5"] = this.fi_me_md5;
        data["fi_me_path"] = this.fi_me_path;
        data["fi_me_extension"] = this.fi_me_extension;
        data["fi_me_upload_from"] = this.fi_me_upload_from;
        data["fi_me_size"] = this.fi_me_size;
        data["fi_me_type"] = this.fi_me_type;
        data["fi_me_created_at"] = this.fi_me_created_at ? this.fi_me_created_at.toISOString() : <any>undefined;
        data["fi_me_updated_at"] = this.fi_me_updated_at ? this.fi_me_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileMediaDto {
        const json = this.toJSON();
        let result = new FileMediaDto();
        result.init(json);
        return result;
    }
}

export interface IFileMediaDto {
    fi_me_id: number;
    fi_me_name: string | undefined;
    fi_me_decs: string | undefined;
    fi_me_md5: string | undefined;
    fi_me_path: string | undefined;
    fi_me_extension: string | undefined;
    fi_me_upload_from: string | undefined;
    fi_me_size: number;
    fi_me_type: ETypeFileMedia;
    fi_me_created_at: Date;
    fi_me_updated_at: Date;
}

export class FileMediaDtoPagedResultDto implements IFileMediaDtoPagedResultDto {
    items!: FileMediaDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFileMediaDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileMediaDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FileMediaDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMediaDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FileMediaDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FileMediaDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileMediaDtoPagedResultDto {
    items: FileMediaDto[] | undefined;
    totalCount: number;
}

export enum FileState {
    _0 = 0,
    _1 = 1,
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;
    organizationUnitId!: number;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): FindOrganizationUnitRolesInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitRolesInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitRolesInput {
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;
    organizationUnitId!: number;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
    organizationUnitId: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class FreshDrinkDto implements IFreshDrinkDto {
    fr_dr_id!: number;
    fr_dr_code!: string | undefined;
    fr_dr_name!: string | undefined;
    fr_dr_image!: AttachmentItem;
    fr_dr_capacity!: number;
    fr_dr_price!: number;
    su_id!: number;
    fr_dr_is_deleted!: boolean;

    constructor(data?: IFreshDrinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fr_dr_id = _data["fr_dr_id"];
            this.fr_dr_code = _data["fr_dr_code"];
            this.fr_dr_name = _data["fr_dr_name"];
            this.fr_dr_image = _data["fr_dr_image"] ? AttachmentItem.fromJS(_data["fr_dr_image"]) : <any>undefined;
            this.fr_dr_capacity = _data["fr_dr_capacity"];
            this.fr_dr_price = _data["fr_dr_price"];
            this.su_id = _data["su_id"];
            this.fr_dr_is_deleted = _data["fr_dr_is_deleted"];
        }
    }

    static fromJS(data: any): FreshDrinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new FreshDrinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fr_dr_id"] = this.fr_dr_id;
        data["fr_dr_code"] = this.fr_dr_code;
        data["fr_dr_name"] = this.fr_dr_name;
        data["fr_dr_image"] = this.fr_dr_image ? this.fr_dr_image.toJSON() : <any>undefined;
        data["fr_dr_capacity"] = this.fr_dr_capacity;
        data["fr_dr_price"] = this.fr_dr_price;
        data["su_id"] = this.su_id;
        data["fr_dr_is_deleted"] = this.fr_dr_is_deleted;
        return data;
    }

    clone(): FreshDrinkDto {
        const json = this.toJSON();
        let result = new FreshDrinkDto();
        result.init(json);
        return result;
    }
}

export interface IFreshDrinkDto {
    fr_dr_id: number;
    fr_dr_code: string | undefined;
    fr_dr_name: string | undefined;
    fr_dr_image: AttachmentItem;
    fr_dr_capacity: number;
    fr_dr_price: number;
    su_id: number;
    fr_dr_is_deleted: boolean;
}

export class FreshDrinkDtoPagedResultDto implements IFreshDrinkDtoPagedResultDto {
    items!: FreshDrinkDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFreshDrinkDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FreshDrinkDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FreshDrinkDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FreshDrinkDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FreshDrinkDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FreshDrinkDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFreshDrinkDtoPagedResultDto {
    items: FreshDrinkDto[] | undefined;
    totalCount: number;
}

export enum GENDER {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;
    soLuongSapHetHangVending!: number;
    soLuongSapHetHangRefill!: number;
    soLuongHangToiDaBoCucMau!: number;
    soLuongCotToiDaBoCucMau!: number;
    thoiGianKiemTraMayOnline!: number;
    tatBatSiderMenu!: boolean;
    soLuongMayToiDaHienThiLenDashboard!: number;
    soNgayThongBaoNeuThanhToanTienMatKhongHoatDong!: number;
    tenWebSite!: string | undefined;
    logo!: string | undefined;
    longLogo!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
            this.soLuongSapHetHangVending = _data["soLuongSapHetHangVending"];
            this.soLuongSapHetHangRefill = _data["soLuongSapHetHangRefill"];
            this.soLuongHangToiDaBoCucMau = _data["soLuongHangToiDaBoCucMau"];
            this.soLuongCotToiDaBoCucMau = _data["soLuongCotToiDaBoCucMau"];
            this.thoiGianKiemTraMayOnline = _data["thoiGianKiemTraMayOnline"];
            this.tatBatSiderMenu = _data["tatBatSiderMenu"];
            this.soLuongMayToiDaHienThiLenDashboard = _data["soLuongMayToiDaHienThiLenDashboard"];
            this.soNgayThongBaoNeuThanhToanTienMatKhongHoatDong = _data["soNgayThongBaoNeuThanhToanTienMatKhongHoatDong"];
            this.tenWebSite = _data["tenWebSite"];
            this.logo = _data["logo"];
            this.longLogo = _data["longLogo"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        data["soLuongSapHetHangVending"] = this.soLuongSapHetHangVending;
        data["soLuongSapHetHangRefill"] = this.soLuongSapHetHangRefill;
        data["soLuongHangToiDaBoCucMau"] = this.soLuongHangToiDaBoCucMau;
        data["soLuongCotToiDaBoCucMau"] = this.soLuongCotToiDaBoCucMau;
        data["thoiGianKiemTraMayOnline"] = this.thoiGianKiemTraMayOnline;
        data["tatBatSiderMenu"] = this.tatBatSiderMenu;
        data["soLuongMayToiDaHienThiLenDashboard"] = this.soLuongMayToiDaHienThiLenDashboard;
        data["soNgayThongBaoNeuThanhToanTienMatKhongHoatDong"] = this.soNgayThongBaoNeuThanhToanTienMatKhongHoatDong;
        data["tenWebSite"] = this.tenWebSite;
        data["logo"] = this.logo;
        data["longLogo"] = this.longLogo;
        return data;
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
    soLuongSapHetHangVending: number;
    soLuongSapHetHangRefill: number;
    soLuongHangToiDaBoCucMau: number;
    soLuongCotToiDaBoCucMau: number;
    thoiGianKiemTraMayOnline: number;
    tatBatSiderMenu: boolean;
    soLuongMayToiDaHienThiLenDashboard: number;
    soNgayThongBaoNeuThanhToanTienMatKhongHoatDong: number;
    tenWebSite: string | undefined;
    logo: string | undefined;
    longLogo: string | undefined;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): GetAllAvailableWebhooksOutput {
        const json = this.toJSON();
        let result = new GetAllAvailableWebhooksOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetAllAvailableWebhooksOutputListResultDto implements IGetAllAvailableWebhooksOutputListResultDto {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllAvailableWebhooksOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllAvailableWebhooksOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllAvailableWebhooksOutputListResultDto {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: Date;
    lastModificationTime!: Date | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): GetAllSendAttemptsOfWebhookEventOutput {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: Date;
    lastModificationTime: Date | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutputListResultDto implements IGetAllSendAttemptsOfWebhookEventOutputListResultDto {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllSendAttemptsOfWebhookEventOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOfWebhookEventOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutputListResultDto {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: Date;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): GetAllSendAttemptsOutput {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: Date;
}

export class GetAllSendAttemptsOutputPagedResultDto implements IGetAllSendAttemptsOutputPagedResultDto {
    items!: GetAllSendAttemptsOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllSendAttemptsOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetAllSendAttemptsOutputPagedResultDto {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOutputPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOutputPagedResultDto {
    items: GetAllSendAttemptsOutput[] | undefined;
    totalCount: number;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    id!: string;
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        return data;
    }

    clone(): GetAllSubscriptionsOutput {
        const json = this.toJSON();
        let result = new GetAllSubscriptionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSubscriptionsOutput {
    id: string;
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
}

export class GetAllSubscriptionsOutputListResultDto implements IGetAllSubscriptionsOutputListResultDto {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IGetAllSubscriptionsOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllSubscriptionsOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllSubscriptionsOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSubscriptionsOutputListResultDto {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application!: ApplicationInfoDto;
    user!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    products!: ProductAbstractDto[] | undefined;
    productInRepositorys!: ProductInRepositoryAbtractDto[] | undefined;
    machines!: MachineAbstractDto[] | undefined;
    groupMachines!: GroupMachineAbstractDto[] | undefined;
    groupTrashbins!: GroupTrashbinAbstractDto[] | undefined;
    suppliers!: SupplierAbstractDto[] | undefined;
    tenants!: TenantAbstractDto[] | undefined;
    users!: UserDto[] | undefined;
    layouts!: LayoutDto[] | undefined;
    repositories!: RepositoryAbstractDto[] | undefined;
    machineInRepository!: MachineInrepositoryAbstractDto[] | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["productInRepositorys"])) {
                this.productInRepositorys = [] as any;
                for (let item of _data["productInRepositorys"])
                    this.productInRepositorys!.push(ProductInRepositoryAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["machines"])) {
                this.machines = [] as any;
                for (let item of _data["machines"])
                    this.machines!.push(MachineAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["groupMachines"])) {
                this.groupMachines = [] as any;
                for (let item of _data["groupMachines"])
                    this.groupMachines!.push(GroupMachineAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["groupTrashbins"])) {
                this.groupTrashbins = [] as any;
                for (let item of _data["groupTrashbins"])
                    this.groupTrashbins!.push(GroupTrashbinAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["suppliers"])) {
                this.suppliers = [] as any;
                for (let item of _data["suppliers"])
                    this.suppliers!.push(SupplierAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["tenants"])) {
                this.tenants = [] as any;
                for (let item of _data["tenants"])
                    this.tenants!.push(TenantAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDto.fromJS(item));
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts!.push(LayoutDto.fromJS(item));
            }
            if (Array.isArray(_data["repositories"])) {
                this.repositories = [] as any;
                for (let item of _data["repositories"])
                    this.repositories!.push(RepositoryAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["machineInRepository"])) {
                this.machineInRepository = [] as any;
                for (let item of _data["machineInRepository"])
                    this.machineInRepository!.push(MachineInrepositoryAbstractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.productInRepositorys)) {
            data["productInRepositorys"] = [];
            for (let item of this.productInRepositorys)
                data["productInRepositorys"].push(item.toJSON());
        }
        if (Array.isArray(this.machines)) {
            data["machines"] = [];
            for (let item of this.machines)
                data["machines"].push(item.toJSON());
        }
        if (Array.isArray(this.groupMachines)) {
            data["groupMachines"] = [];
            for (let item of this.groupMachines)
                data["groupMachines"].push(item.toJSON());
        }
        if (Array.isArray(this.groupTrashbins)) {
            data["groupTrashbins"] = [];
            for (let item of this.groupTrashbins)
                data["groupTrashbins"].push(item.toJSON());
        }
        if (Array.isArray(this.suppliers)) {
            data["suppliers"] = [];
            for (let item of this.suppliers)
                data["suppliers"].push(item.toJSON());
        }
        if (Array.isArray(this.tenants)) {
            data["tenants"] = [];
            for (let item of this.tenants)
                data["tenants"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        if (Array.isArray(this.repositories)) {
            data["repositories"] = [];
            for (let item of this.repositories)
                data["repositories"].push(item.toJSON());
        }
        if (Array.isArray(this.machineInRepository)) {
            data["machineInRepository"] = [];
            for (let item of this.machineInRepository)
                data["machineInRepository"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    products: ProductAbstractDto[] | undefined;
    productInRepositorys: ProductInRepositoryAbtractDto[] | undefined;
    machines: MachineAbstractDto[] | undefined;
    groupMachines: GroupMachineAbstractDto[] | undefined;
    groupTrashbins: GroupTrashbinAbstractDto[] | undefined;
    suppliers: SupplierAbstractDto[] | undefined;
    tenants: TenantAbstractDto[] | undefined;
    users: UserDto[] | undefined;
    layouts: LayoutDto[] | undefined;
    repositories: RepositoryAbstractDto[] | undefined;
    machineInRepository: MachineInrepositoryAbstractDto[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GroupMachineAbstractDto implements IGroupMachineAbstractDto {
    gr_ma_id!: number;
    gr_ma_area!: string | undefined;
    gr_ma_is_deleted!: boolean;

    constructor(data?: IGroupMachineAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_ma_id = _data["gr_ma_id"];
            this.gr_ma_area = _data["gr_ma_area"];
            this.gr_ma_is_deleted = _data["gr_ma_is_deleted"];
        }
    }

    static fromJS(data: any): GroupMachineAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupMachineAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_ma_id"] = this.gr_ma_id;
        data["gr_ma_area"] = this.gr_ma_area;
        data["gr_ma_is_deleted"] = this.gr_ma_is_deleted;
        return data;
    }

    clone(): GroupMachineAbstractDto {
        const json = this.toJSON();
        let result = new GroupMachineAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IGroupMachineAbstractDto {
    gr_ma_id: number;
    gr_ma_area: string | undefined;
    gr_ma_is_deleted: boolean;
}

export class GroupMachineDto implements IGroupMachineDto {
    gr_ma_id!: number;
    gr_ma_area!: string | undefined;
    gr_ma_desc!: string | undefined;
    machines!: Machine[] | undefined;
    gr_ma_is_deleted!: boolean;
    gr_ma_created_at!: Date;
    gr_ma_updated_at!: Date;
    gr_ma_deleted_at!: Date | undefined;

    constructor(data?: IGroupMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_ma_id = _data["gr_ma_id"];
            this.gr_ma_area = _data["gr_ma_area"];
            this.gr_ma_desc = _data["gr_ma_desc"];
            if (Array.isArray(_data["machines"])) {
                this.machines = [] as any;
                for (let item of _data["machines"])
                    this.machines!.push(Machine.fromJS(item));
            }
            this.gr_ma_is_deleted = _data["gr_ma_is_deleted"];
            this.gr_ma_created_at = _data["gr_ma_created_at"] ? new Date(_data["gr_ma_created_at"].toString()) : <any>undefined;
            this.gr_ma_updated_at = _data["gr_ma_updated_at"] ? new Date(_data["gr_ma_updated_at"].toString()) : <any>undefined;
            this.gr_ma_deleted_at = _data["gr_ma_deleted_at"] ? new Date(_data["gr_ma_deleted_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_ma_id"] = this.gr_ma_id;
        data["gr_ma_area"] = this.gr_ma_area;
        data["gr_ma_desc"] = this.gr_ma_desc;
        if (Array.isArray(this.machines)) {
            data["machines"] = [];
            for (let item of this.machines)
                data["machines"].push(item.toJSON());
        }
        data["gr_ma_is_deleted"] = this.gr_ma_is_deleted;
        data["gr_ma_created_at"] = this.gr_ma_created_at ? this.gr_ma_created_at.toISOString() : <any>undefined;
        data["gr_ma_updated_at"] = this.gr_ma_updated_at ? this.gr_ma_updated_at.toISOString() : <any>undefined;
        data["gr_ma_deleted_at"] = this.gr_ma_deleted_at ? this.gr_ma_deleted_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): GroupMachineDto {
        const json = this.toJSON();
        let result = new GroupMachineDto();
        result.init(json);
        return result;
    }
}

export interface IGroupMachineDto {
    gr_ma_id: number;
    gr_ma_area: string | undefined;
    gr_ma_desc: string | undefined;
    machines: Machine[] | undefined;
    gr_ma_is_deleted: boolean;
    gr_ma_created_at: Date;
    gr_ma_updated_at: Date;
    gr_ma_deleted_at: Date | undefined;
}

export class GroupMachineDtoPagedResultDto implements IGroupMachineDtoPagedResultDto {
    items!: GroupMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGroupMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GroupMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GroupMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GroupMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGroupMachineDtoPagedResultDto {
    items: GroupMachineDto[] | undefined;
    totalCount: number;
}

export class GroupTrashbinAbstractDto implements IGroupTrashbinAbstractDto {
    gr_tr_id!: number;
    gr_tr_name!: string | undefined;
    gr_tr_is_deleted!: boolean;

    constructor(data?: IGroupTrashbinAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_tr_id = _data["gr_tr_id"];
            this.gr_tr_name = _data["gr_tr_name"];
            this.gr_tr_is_deleted = _data["gr_tr_is_deleted"];
        }
    }

    static fromJS(data: any): GroupTrashbinAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTrashbinAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_tr_id"] = this.gr_tr_id;
        data["gr_tr_name"] = this.gr_tr_name;
        data["gr_tr_is_deleted"] = this.gr_tr_is_deleted;
        return data;
    }

    clone(): GroupTrashbinAbstractDto {
        const json = this.toJSON();
        let result = new GroupTrashbinAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IGroupTrashbinAbstractDto {
    gr_tr_id: number;
    gr_tr_name: string | undefined;
    gr_tr_is_deleted: boolean;
}

export class GroupTrashbinDto implements IGroupTrashbinDto {
    gr_tr_id!: number;
    gr_tr_name!: string | undefined;
    gr_tr_desc!: string | undefined;
    trashBins!: TrashBin[] | undefined;
    gr_tr_created_at!: Date;
    gr_tr_updated_at!: Date;
    gr_tr_deleted_at!: Date | undefined;

    constructor(data?: IGroupTrashbinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_tr_id = _data["gr_tr_id"];
            this.gr_tr_name = _data["gr_tr_name"];
            this.gr_tr_desc = _data["gr_tr_desc"];
            if (Array.isArray(_data["trashBins"])) {
                this.trashBins = [] as any;
                for (let item of _data["trashBins"])
                    this.trashBins!.push(TrashBin.fromJS(item));
            }
            this.gr_tr_created_at = _data["gr_tr_created_at"] ? new Date(_data["gr_tr_created_at"].toString()) : <any>undefined;
            this.gr_tr_updated_at = _data["gr_tr_updated_at"] ? new Date(_data["gr_tr_updated_at"].toString()) : <any>undefined;
            this.gr_tr_deleted_at = _data["gr_tr_deleted_at"] ? new Date(_data["gr_tr_deleted_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupTrashbinDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTrashbinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_tr_id"] = this.gr_tr_id;
        data["gr_tr_name"] = this.gr_tr_name;
        data["gr_tr_desc"] = this.gr_tr_desc;
        if (Array.isArray(this.trashBins)) {
            data["trashBins"] = [];
            for (let item of this.trashBins)
                data["trashBins"].push(item.toJSON());
        }
        data["gr_tr_created_at"] = this.gr_tr_created_at ? this.gr_tr_created_at.toISOString() : <any>undefined;
        data["gr_tr_updated_at"] = this.gr_tr_updated_at ? this.gr_tr_updated_at.toISOString() : <any>undefined;
        data["gr_tr_deleted_at"] = this.gr_tr_deleted_at ? this.gr_tr_deleted_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): GroupTrashbinDto {
        const json = this.toJSON();
        let result = new GroupTrashbinDto();
        result.init(json);
        return result;
    }
}

export interface IGroupTrashbinDto {
    gr_tr_id: number;
    gr_tr_name: string | undefined;
    gr_tr_desc: string | undefined;
    trashBins: TrashBin[] | undefined;
    gr_tr_created_at: Date;
    gr_tr_updated_at: Date;
    gr_tr_deleted_at: Date | undefined;
}

export class GroupTrashbinDtoPagedResultDto implements IGroupTrashbinDtoPagedResultDto {
    items!: GroupTrashbinDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGroupTrashbinDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupTrashbinDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GroupTrashbinDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTrashbinDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GroupTrashbinDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GroupTrashbinDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGroupTrashbinDtoPagedResultDto {
    items: GroupTrashbinDto[] | undefined;
    totalCount: number;
}

export class HandoverDto implements IHandoverDto {
    ha_id!: number;
    ha_code!: string | undefined;
    handover_user!: number;
    receive_user!: number;
    ha_status!: EHandoverStatus;
    ha_type!: EHandoverType;
    ha_note!: string | undefined;
    ma_id_list!: number[] | undefined;
    productHandoverInputs!: ProductHandoverInput[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    ha_created_at!: Date;
    ha_updated_at!: Date;

    constructor(data?: IHandoverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ha_id = _data["ha_id"];
            this.ha_code = _data["ha_code"];
            this.handover_user = _data["handover_user"];
            this.receive_user = _data["receive_user"];
            this.ha_status = _data["ha_status"];
            this.ha_type = _data["ha_type"];
            this.ha_note = _data["ha_note"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            if (Array.isArray(_data["productHandoverInputs"])) {
                this.productHandoverInputs = [] as any;
                for (let item of _data["productHandoverInputs"])
                    this.productHandoverInputs!.push(ProductHandoverInput.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.ha_created_at = _data["ha_created_at"] ? new Date(_data["ha_created_at"].toString()) : <any>undefined;
            this.ha_updated_at = _data["ha_updated_at"] ? new Date(_data["ha_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HandoverDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandoverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ha_id"] = this.ha_id;
        data["ha_code"] = this.ha_code;
        data["handover_user"] = this.handover_user;
        data["receive_user"] = this.receive_user;
        data["ha_status"] = this.ha_status;
        data["ha_type"] = this.ha_type;
        data["ha_note"] = this.ha_note;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        if (Array.isArray(this.productHandoverInputs)) {
            data["productHandoverInputs"] = [];
            for (let item of this.productHandoverInputs)
                data["productHandoverInputs"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["ha_created_at"] = this.ha_created_at ? this.ha_created_at.toISOString() : <any>undefined;
        data["ha_updated_at"] = this.ha_updated_at ? this.ha_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): HandoverDto {
        const json = this.toJSON();
        let result = new HandoverDto();
        result.init(json);
        return result;
    }
}

export interface IHandoverDto {
    ha_id: number;
    ha_code: string | undefined;
    handover_user: number;
    receive_user: number;
    ha_status: EHandoverStatus;
    ha_type: EHandoverType;
    ha_note: string | undefined;
    ma_id_list: number[] | undefined;
    productHandoverInputs: ProductHandoverInput[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    ha_created_at: Date;
    ha_updated_at: Date;
}

export class HandoverDtoPagedResultDto implements IHandoverDtoPagedResultDto {
    items!: HandoverDto[] | undefined;
    totalCount!: number;

    constructor(data?: IHandoverDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HandoverDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HandoverDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandoverDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HandoverDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HandoverDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHandoverDtoPagedResultDto {
    items: HandoverDto[] | undefined;
    totalCount: number;
}

export class HardwareAuthenticateModel implements IHardwareAuthenticateModel {
    tenantId!: number | undefined;
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;
    tenantName!: string | undefined;
    deviceID!: string | undefined;
    deviceMAC!: string | undefined;
    lat!: string | undefined;
    lng!: string | undefined;
    data!: string | undefined;

    constructor(data?: IHardwareAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.tenantName = _data["tenantName"];
            this.deviceID = _data["deviceID"];
            this.deviceMAC = _data["deviceMAC"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): HardwareAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["tenantName"] = this.tenantName;
        data["deviceID"] = this.deviceID;
        data["deviceMAC"] = this.deviceMAC;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["data"] = this.data;
        return data;
    }

    clone(): HardwareAuthenticateModel {
        const json = this.toJSON();
        let result = new HardwareAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IHardwareAuthenticateModel {
    tenantId: number | undefined;
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    tenantName: string | undefined;
    deviceID: string | undefined;
    deviceMAC: string | undefined;
    lat: string | undefined;
    lng: string | undefined;
    data: string | undefined;
}

export class HardwareAuthenticateResultModel implements IHardwareAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;
    tenantId!: number | undefined;
    passcodeAdmin!: string | undefined;
    passcodeReplenish!: string | undefined;
    deviceID!: string | undefined;
    displayName!: string | undefined;
    isDebug!: boolean;
    activeMomoPayment!: boolean;
    activeVNPayment!: boolean;
    activeQrCodePayment!: boolean;
    activeMIGPayment!: boolean;
    activeRifdPayment!: boolean;
    activeCashPayment!: boolean;

    constructor(data?: IHardwareAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.passcodeAdmin = _data["passcodeAdmin"];
            this.passcodeReplenish = _data["passcodeReplenish"];
            this.deviceID = _data["deviceID"];
            this.displayName = _data["displayName"];
            this.isDebug = _data["isDebug"];
            this.activeMomoPayment = _data["activeMomoPayment"];
            this.activeVNPayment = _data["activeVNPayment"];
            this.activeQrCodePayment = _data["activeQrCodePayment"];
            this.activeMIGPayment = _data["activeMIGPayment"];
            this.activeRifdPayment = _data["activeRifdPayment"];
            this.activeCashPayment = _data["activeCashPayment"];
        }
    }

    static fromJS(data: any): HardwareAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new HardwareAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["passcodeAdmin"] = this.passcodeAdmin;
        data["passcodeReplenish"] = this.passcodeReplenish;
        data["deviceID"] = this.deviceID;
        data["displayName"] = this.displayName;
        data["isDebug"] = this.isDebug;
        data["activeMomoPayment"] = this.activeMomoPayment;
        data["activeVNPayment"] = this.activeVNPayment;
        data["activeQrCodePayment"] = this.activeQrCodePayment;
        data["activeMIGPayment"] = this.activeMIGPayment;
        data["activeRifdPayment"] = this.activeRifdPayment;
        data["activeCashPayment"] = this.activeCashPayment;
        return data;
    }

    clone(): HardwareAuthenticateResultModel {
        const json = this.toJSON();
        let result = new HardwareAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IHardwareAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    tenantId: number | undefined;
    passcodeAdmin: string | undefined;
    passcodeReplenish: string | undefined;
    deviceID: string | undefined;
    displayName: string | undefined;
    isDebug: boolean;
    activeMomoPayment: boolean;
    activeVNPayment: boolean;
    activeQrCodePayment: boolean;
    activeMIGPayment: boolean;
    activeRifdPayment: boolean;
    activeCashPayment: boolean;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    email!: EmailSettingsEditDto;
    security!: SecuritySettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        return data;
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    email: EmailSettingsEditDto;
    security: SecuritySettingsEditDto;
}

export class HostString implements IHostString {
    value!: string | undefined;
    readonly hasValue!: boolean;
    readonly host!: string | undefined;
    readonly port!: number | undefined;

    constructor(data?: IHostString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).hasValue = _data["hasValue"];
            (<any>this).host = _data["host"];
            (<any>this).port = _data["port"];
        }
    }

    static fromJS(data: any): HostString {
        data = typeof data === 'object' ? data : {};
        let result = new HostString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["hasValue"] = this.hasValue;
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }

    clone(): HostString {
        const json = this.toJSON();
        let result = new HostString();
        result.init(json);
        return result;
    }
}

export interface IHostString {
    value: string | undefined;
    hasValue: boolean;
    host: string | undefined;
    port: number | undefined;
}

export class HttpContext implements IHttpContext {
    readonly features!: TypeObjectKeyValuePair[] | undefined;
    request!: HttpRequest;
    response!: HttpResponse;
    connection!: ConnectionInfo;
    webSockets!: WebSocketManager;
    user!: ClaimsPrincipal;
    items!: { [key: string]: any; } | undefined;
    requestServices!: IServiceProvider;
    requestAborted!: CancellationToken;
    traceIdentifier!: string | undefined;
    session!: ISession;

    constructor(data?: IHttpContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                (<any>this).features = [] as any;
                for (let item of _data["features"])
                    (<any>this).features!.push(TypeObjectKeyValuePair.fromJS(item));
            }
            this.request = _data["request"] ? HttpRequest.fromJS(_data["request"]) : <any>undefined;
            this.response = _data["response"] ? HttpResponse.fromJS(_data["response"]) : <any>undefined;
            this.connection = _data["connection"] ? ConnectionInfo.fromJS(_data["connection"]) : <any>undefined;
            this.webSockets = _data["webSockets"] ? WebSocketManager.fromJS(_data["webSockets"]) : <any>undefined;
            this.user = _data["user"] ? ClaimsPrincipal.fromJS(_data["user"]) : <any>undefined;
            if (_data["items"]) {
                this.items = {} as any;
                for (let key in _data["items"]) {
                    if (_data["items"].hasOwnProperty(key))
                        (<any>this.items)![key] = _data["items"][key];
                }
            }
            this.requestServices = _data["requestServices"] ? IServiceProvider.fromJS(_data["requestServices"]) : <any>undefined;
            this.requestAborted = _data["requestAborted"] ? CancellationToken.fromJS(_data["requestAborted"]) : <any>undefined;
            this.traceIdentifier = _data["traceIdentifier"];
            this.session = _data["session"] ? ISession.fromJS(_data["session"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpContext {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["connection"] = this.connection ? this.connection.toJSON() : <any>undefined;
        data["webSockets"] = this.webSockets ? this.webSockets.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.items) {
            data["items"] = {};
            for (let key in this.items) {
                if (this.items.hasOwnProperty(key))
                    (<any>data["items"])[key] = (<any>this.items)[key];
            }
        }
        data["requestServices"] = this.requestServices ? this.requestServices.toJSON() : <any>undefined;
        data["requestAborted"] = this.requestAborted ? this.requestAborted.toJSON() : <any>undefined;
        data["traceIdentifier"] = this.traceIdentifier;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        return data;
    }

    clone(): HttpContext {
        const json = this.toJSON();
        let result = new HttpContext();
        result.init(json);
        return result;
    }
}

export interface IHttpContext {
    features: TypeObjectKeyValuePair[] | undefined;
    request: HttpRequest;
    response: HttpResponse;
    connection: ConnectionInfo;
    webSockets: WebSocketManager;
    user: ClaimsPrincipal;
    items: { [key: string]: any; } | undefined;
    requestServices: IServiceProvider;
    requestAborted: CancellationToken;
    traceIdentifier: string | undefined;
    session: ISession;
}

export class HttpRequest implements IHttpRequest {
    httpContext!: HttpContext;
    method!: string | undefined;
    scheme!: string | undefined;
    isHttps!: boolean;
    host!: HostString;
    pathBase!: PathString;
    path!: PathString;
    queryString!: QueryString;
    query!: StringStringValuesKeyValuePair[] | undefined;
    protocol!: string | undefined;
    readonly headers!: { [key: string]: string[]; } | undefined;
    cookies!: StringStringKeyValuePair[] | undefined;
    contentLength!: number | undefined;
    contentType!: string | undefined;
    body!: Stream;
    bodyReader!: PipeReader;
    readonly hasFormContentType!: boolean;
    form!: StringStringValuesKeyValuePair[] | undefined;
    routeValues!: { [key: string]: any; } | undefined;

    constructor(data?: IHttpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpContext = _data["httpContext"] ? HttpContext.fromJS(_data["httpContext"]) : <any>undefined;
            this.method = _data["method"];
            this.scheme = _data["scheme"];
            this.isHttps = _data["isHttps"];
            this.host = _data["host"] ? HostString.fromJS(_data["host"]) : <any>undefined;
            this.pathBase = _data["pathBase"] ? PathString.fromJS(_data["pathBase"]) : <any>undefined;
            this.path = _data["path"] ? PathString.fromJS(_data["path"]) : <any>undefined;
            this.queryString = _data["queryString"] ? QueryString.fromJS(_data["queryString"]) : <any>undefined;
            if (Array.isArray(_data["query"])) {
                this.query = [] as any;
                for (let item of _data["query"])
                    this.query!.push(StringStringValuesKeyValuePair.fromJS(item));
            }
            this.protocol = _data["protocol"];
            if (_data["headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>(<any>this).headers)![key] = _data["headers"][key] !== undefined ? _data["headers"][key] : [];
                }
            }
            if (Array.isArray(_data["cookies"])) {
                this.cookies = [] as any;
                for (let item of _data["cookies"])
                    this.cookies!.push(StringStringKeyValuePair.fromJS(item));
            }
            this.contentLength = _data["contentLength"];
            this.contentType = _data["contentType"];
            this.body = _data["body"] ? Stream.fromJS(_data["body"]) : <any>undefined;
            this.bodyReader = _data["bodyReader"] ? PipeReader.fromJS(_data["bodyReader"]) : <any>undefined;
            (<any>this).hasFormContentType = _data["hasFormContentType"];
            if (Array.isArray(_data["form"])) {
                this.form = [] as any;
                for (let item of _data["form"])
                    this.form!.push(StringStringValuesKeyValuePair.fromJS(item));
            }
            if (_data["routeValues"]) {
                this.routeValues = {} as any;
                for (let key in _data["routeValues"]) {
                    if (_data["routeValues"].hasOwnProperty(key))
                        (<any>this.routeValues)![key] = _data["routeValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): HttpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["method"] = this.method;
        data["scheme"] = this.scheme;
        data["isHttps"] = this.isHttps;
        data["host"] = this.host ? this.host.toJSON() : <any>undefined;
        data["pathBase"] = this.pathBase ? this.pathBase.toJSON() : <any>undefined;
        data["path"] = this.path ? this.path.toJSON() : <any>undefined;
        data["queryString"] = this.queryString ? this.queryString.toJSON() : <any>undefined;
        if (Array.isArray(this.query)) {
            data["query"] = [];
            for (let item of this.query)
                data["query"].push(item.toJSON());
        }
        data["protocol"] = this.protocol;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        if (Array.isArray(this.cookies)) {
            data["cookies"] = [];
            for (let item of this.cookies)
                data["cookies"].push(item.toJSON());
        }
        data["contentLength"] = this.contentLength;
        data["contentType"] = this.contentType;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["bodyReader"] = this.bodyReader ? this.bodyReader.toJSON() : <any>undefined;
        data["hasFormContentType"] = this.hasFormContentType;
        if (Array.isArray(this.form)) {
            data["form"] = [];
            for (let item of this.form)
                data["form"].push(item.toJSON());
        }
        if (this.routeValues) {
            data["routeValues"] = {};
            for (let key in this.routeValues) {
                if (this.routeValues.hasOwnProperty(key))
                    (<any>data["routeValues"])[key] = (<any>this.routeValues)[key];
            }
        }
        return data;
    }

    clone(): HttpRequest {
        const json = this.toJSON();
        let result = new HttpRequest();
        result.init(json);
        return result;
    }
}

export interface IHttpRequest {
    httpContext: HttpContext;
    method: string | undefined;
    scheme: string | undefined;
    isHttps: boolean;
    host: HostString;
    pathBase: PathString;
    path: PathString;
    queryString: QueryString;
    query: StringStringValuesKeyValuePair[] | undefined;
    protocol: string | undefined;
    headers: { [key: string]: string[]; } | undefined;
    cookies: StringStringKeyValuePair[] | undefined;
    contentLength: number | undefined;
    contentType: string | undefined;
    body: Stream;
    bodyReader: PipeReader;
    hasFormContentType: boolean;
    form: StringStringValuesKeyValuePair[] | undefined;
    routeValues: { [key: string]: any; } | undefined;
}

export class HttpResponse implements IHttpResponse {
    httpContext!: HttpContext;
    statusCode!: number;
    readonly headers!: { [key: string]: string[]; } | undefined;
    body!: Stream;
    bodyWriter!: PipeWriter;
    contentLength!: number | undefined;
    contentType!: string | undefined;
    cookies!: IResponseCookies;
    readonly hasStarted!: boolean;

    constructor(data?: IHttpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpContext = _data["httpContext"] ? HttpContext.fromJS(_data["httpContext"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
            if (_data["headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>(<any>this).headers)![key] = _data["headers"][key] !== undefined ? _data["headers"][key] : [];
                }
            }
            this.body = _data["body"] ? Stream.fromJS(_data["body"]) : <any>undefined;
            this.bodyWriter = _data["bodyWriter"] ? PipeWriter.fromJS(_data["bodyWriter"]) : <any>undefined;
            this.contentLength = _data["contentLength"];
            this.contentType = _data["contentType"];
            this.cookies = _data["cookies"] ? IResponseCookies.fromJS(_data["cookies"]) : <any>undefined;
            (<any>this).hasStarted = _data["hasStarted"];
        }
    }

    static fromJS(data: any): HttpResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["bodyWriter"] = this.bodyWriter ? this.bodyWriter.toJSON() : <any>undefined;
        data["contentLength"] = this.contentLength;
        data["contentType"] = this.contentType;
        data["cookies"] = this.cookies ? this.cookies.toJSON() : <any>undefined;
        data["hasStarted"] = this.hasStarted;
        return data;
    }

    clone(): HttpResponse {
        const json = this.toJSON();
        let result = new HttpResponse();
        result.init(json);
        return result;
    }
}

export interface IHttpResponse {
    httpContext: HttpContext;
    statusCode: number;
    headers: { [key: string]: string[]; } | undefined;
    body: Stream;
    bodyWriter: PipeWriter;
    contentLength: number | undefined;
    contentType: string | undefined;
    cookies: IResponseCookies;
    hasStarted: boolean;
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): ICustomAttributeProvider {
        const json = this.toJSON();
        let result = new ICustomAttributeProvider();
        result.init(json);
        return result;
    }
}

export interface IICustomAttributeProvider {
}

export class IIdentity implements IIIdentity {
    readonly name!: string | undefined;
    readonly authenticationType!: string | undefined;
    readonly isAuthenticated!: boolean;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            (<any>this).authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new IIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        return data;
    }

    clone(): IIdentity {
        const json = this.toJSON();
        let result = new IIdentity();
        result.init(json);
        return result;
    }
}

export interface IIIdentity {
    name: string | undefined;
    authenticationType: string | undefined;
    isAuthenticated: boolean;
}

export class IPAddress implements IIPAddress {
    addressFamily!: AddressFamily;
    scopeId!: number;
    readonly isIPv6Multicast!: boolean;
    readonly isIPv6LinkLocal!: boolean;
    readonly isIPv6SiteLocal!: boolean;
    readonly isIPv6Teredo!: boolean;
    readonly isIPv6UniqueLocal!: boolean;
    readonly isIPv4MappedToIPv6!: boolean;
    address!: number;

    constructor(data?: IIPAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressFamily = _data["addressFamily"];
            this.scopeId = _data["scopeId"];
            (<any>this).isIPv6Multicast = _data["isIPv6Multicast"];
            (<any>this).isIPv6LinkLocal = _data["isIPv6LinkLocal"];
            (<any>this).isIPv6SiteLocal = _data["isIPv6SiteLocal"];
            (<any>this).isIPv6Teredo = _data["isIPv6Teredo"];
            (<any>this).isIPv6UniqueLocal = _data["isIPv6UniqueLocal"];
            (<any>this).isIPv4MappedToIPv6 = _data["isIPv4MappedToIPv6"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): IPAddress {
        data = typeof data === 'object' ? data : {};
        let result = new IPAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressFamily"] = this.addressFamily;
        data["scopeId"] = this.scopeId;
        data["isIPv6Multicast"] = this.isIPv6Multicast;
        data["isIPv6LinkLocal"] = this.isIPv6LinkLocal;
        data["isIPv6SiteLocal"] = this.isIPv6SiteLocal;
        data["isIPv6Teredo"] = this.isIPv6Teredo;
        data["isIPv6UniqueLocal"] = this.isIPv6UniqueLocal;
        data["isIPv4MappedToIPv6"] = this.isIPv4MappedToIPv6;
        data["address"] = this.address;
        return data;
    }

    clone(): IPAddress {
        const json = this.toJSON();
        let result = new IPAddress();
        result.init(json);
        return result;
    }
}

export interface IIPAddress {
    addressFamily: AddressFamily;
    scopeId: number;
    isIPv6Multicast: boolean;
    isIPv6LinkLocal: boolean;
    isIPv6SiteLocal: boolean;
    isIPv6Teredo: boolean;
    isIPv6UniqueLocal: boolean;
    isIPv4MappedToIPv6: boolean;
    address: number;
}

export class IResponseCookies implements IIResponseCookies {

    constructor(data?: IIResponseCookies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IResponseCookies {
        data = typeof data === 'object' ? data : {};
        let result = new IResponseCookies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): IResponseCookies {
        const json = this.toJSON();
        let result = new IResponseCookies();
        result.init(json);
        return result;
    }
}

export interface IIResponseCookies {
}

export class IServiceProvider implements IIServiceProvider {

    constructor(data?: IIServiceProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IServiceProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IServiceProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): IServiceProvider {
        const json = this.toJSON();
        let result = new IServiceProvider();
        result.init(json);
        return result;
    }
}

export interface IIServiceProvider {
}

export class ISession implements IISession {
    readonly isAvailable!: boolean;
    readonly id!: string | undefined;
    readonly keys!: string[] | undefined;

    constructor(data?: IISession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isAvailable = _data["isAvailable"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["keys"])) {
                (<any>this).keys = [] as any;
                for (let item of _data["keys"])
                    (<any>this).keys!.push(item);
            }
        }
    }

    static fromJS(data: any): ISession {
        data = typeof data === 'object' ? data : {};
        let result = new ISession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        data["id"] = this.id;
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item);
        }
        return data;
    }

    clone(): ISession {
        const json = this.toJSON();
        let result = new ISession();
        result.init(json);
        return result;
    }
}

export interface IISession {
    isAvailable: boolean;
    id: string | undefined;
    keys: string[] | undefined;
}

export class ImageProductDto implements IImageProductDto {
    im_pr_id!: number;
    im_pr_name!: string | undefined;
    im_pr_is_deleted!: boolean;
    im_pr_md5!: string | undefined;
    im_pr_path!: string | undefined;
    im_pr_extension!: string | undefined;
    im_pr_size!: number;
    im_pr_created_at!: Date;

    constructor(data?: IImageProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_pr_id = _data["im_pr_id"];
            this.im_pr_name = _data["im_pr_name"];
            this.im_pr_is_deleted = _data["im_pr_is_deleted"];
            this.im_pr_md5 = _data["im_pr_md5"];
            this.im_pr_path = _data["im_pr_path"];
            this.im_pr_extension = _data["im_pr_extension"];
            this.im_pr_size = _data["im_pr_size"];
            this.im_pr_created_at = _data["im_pr_created_at"] ? new Date(_data["im_pr_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImageProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_pr_id"] = this.im_pr_id;
        data["im_pr_name"] = this.im_pr_name;
        data["im_pr_is_deleted"] = this.im_pr_is_deleted;
        data["im_pr_md5"] = this.im_pr_md5;
        data["im_pr_path"] = this.im_pr_path;
        data["im_pr_extension"] = this.im_pr_extension;
        data["im_pr_size"] = this.im_pr_size;
        data["im_pr_created_at"] = this.im_pr_created_at ? this.im_pr_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ImageProductDto {
        const json = this.toJSON();
        let result = new ImageProductDto();
        result.init(json);
        return result;
    }
}

export interface IImageProductDto {
    im_pr_id: number;
    im_pr_name: string | undefined;
    im_pr_is_deleted: boolean;
    im_pr_md5: string | undefined;
    im_pr_path: string | undefined;
    im_pr_extension: string | undefined;
    im_pr_size: number;
    im_pr_created_at: Date;
}

export class ImageProductDtoPagedResultDto implements IImageProductDtoPagedResultDto {
    items!: ImageProductDto[] | undefined;
    totalCount!: number;

    constructor(data?: IImageProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ImageProductDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ImageProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ImageProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ImageProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IImageProductDtoPagedResultDto {
    items: ImageProductDto[] | undefined;
    totalCount: number;
}

export class ImportDrinkInput implements IImportDrinkInput {
    dr_name!: string | undefined;
    dr_desc!: string | undefined;
    su_name!: string | undefined;
    dr_price!: number;
    dr_image!: string | undefined;

    constructor(data?: IImportDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dr_name = _data["dr_name"];
            this.dr_desc = _data["dr_desc"];
            this.su_name = _data["su_name"];
            this.dr_price = _data["dr_price"];
            this.dr_image = _data["dr_image"];
        }
    }

    static fromJS(data: any): ImportDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dr_name"] = this.dr_name;
        data["dr_desc"] = this.dr_desc;
        data["su_name"] = this.su_name;
        data["dr_price"] = this.dr_price;
        data["dr_image"] = this.dr_image;
        return data;
    }

    clone(): ImportDrinkInput {
        const json = this.toJSON();
        let result = new ImportDrinkInput();
        result.init(json);
        return result;
    }
}

export interface IImportDrinkInput {
    dr_name: string | undefined;
    dr_desc: string | undefined;
    su_name: string | undefined;
    dr_price: number;
    dr_image: string | undefined;
}

export class ImportFreshDrinkInput implements IImportFreshDrinkInput {
    fr_dr_name!: string | undefined;
    fr_dr_capacity!: number;
    su_name!: string | undefined;
    fr_dr_price!: number;
    fr_dr_image!: string | undefined;

    constructor(data?: IImportFreshDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fr_dr_name = _data["fr_dr_name"];
            this.fr_dr_capacity = _data["fr_dr_capacity"];
            this.su_name = _data["su_name"];
            this.fr_dr_price = _data["fr_dr_price"];
            this.fr_dr_image = _data["fr_dr_image"];
        }
    }

    static fromJS(data: any): ImportFreshDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFreshDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fr_dr_name"] = this.fr_dr_name;
        data["fr_dr_capacity"] = this.fr_dr_capacity;
        data["su_name"] = this.su_name;
        data["fr_dr_price"] = this.fr_dr_price;
        data["fr_dr_image"] = this.fr_dr_image;
        return data;
    }

    clone(): ImportFreshDrinkInput {
        const json = this.toJSON();
        let result = new ImportFreshDrinkInput();
        result.init(json);
        return result;
    }
}

export interface IImportFreshDrinkInput {
    fr_dr_name: string | undefined;
    fr_dr_capacity: number;
    su_name: string | undefined;
    fr_dr_price: number;
    fr_dr_image: string | undefined;
}

export class ImportRepository implements IImportRepository {
    id!: number;
    readonly im_re_id!: number;
    im_re_code!: string | undefined;
    us_id_import!: number;
    su_id!: number;
    re_id!: number;
    im_re_total_money!: number;
    im_re_status!: EImportRepositoryStatus;
    im_re_debt!: number;
    im_re_is_deleted!: boolean;
    im_re_note!: string | undefined;
    im_re_created_at!: Date;
    im_re_updated_at!: Date;
    im_re_imported_at!: Date | undefined;
    im_re_deleted_at!: Date | undefined;
    tenantId!: number;
    listProductImport!: string | undefined;
    repository!: Repository;
    fi_id_list!: string | undefined;

    constructor(data?: IImportRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).im_re_id = _data["im_re_id"];
            this.im_re_code = _data["im_re_code"];
            this.us_id_import = _data["us_id_import"];
            this.su_id = _data["su_id"];
            this.re_id = _data["re_id"];
            this.im_re_total_money = _data["im_re_total_money"];
            this.im_re_status = _data["im_re_status"];
            this.im_re_debt = _data["im_re_debt"];
            this.im_re_is_deleted = _data["im_re_is_deleted"];
            this.im_re_note = _data["im_re_note"];
            this.im_re_created_at = _data["im_re_created_at"] ? new Date(_data["im_re_created_at"].toString()) : <any>undefined;
            this.im_re_updated_at = _data["im_re_updated_at"] ? new Date(_data["im_re_updated_at"].toString()) : <any>undefined;
            this.im_re_imported_at = _data["im_re_imported_at"] ? new Date(_data["im_re_imported_at"].toString()) : <any>undefined;
            this.im_re_deleted_at = _data["im_re_deleted_at"] ? new Date(_data["im_re_deleted_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.listProductImport = _data["listProductImport"];
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.fi_id_list = _data["fi_id_list"];
        }
    }

    static fromJS(data: any): ImportRepository {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["im_re_id"] = this.im_re_id;
        data["im_re_code"] = this.im_re_code;
        data["us_id_import"] = this.us_id_import;
        data["su_id"] = this.su_id;
        data["re_id"] = this.re_id;
        data["im_re_total_money"] = this.im_re_total_money;
        data["im_re_status"] = this.im_re_status;
        data["im_re_debt"] = this.im_re_debt;
        data["im_re_is_deleted"] = this.im_re_is_deleted;
        data["im_re_note"] = this.im_re_note;
        data["im_re_created_at"] = this.im_re_created_at ? this.im_re_created_at.toISOString() : <any>undefined;
        data["im_re_updated_at"] = this.im_re_updated_at ? this.im_re_updated_at.toISOString() : <any>undefined;
        data["im_re_imported_at"] = this.im_re_imported_at ? this.im_re_imported_at.toISOString() : <any>undefined;
        data["im_re_deleted_at"] = this.im_re_deleted_at ? this.im_re_deleted_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["listProductImport"] = this.listProductImport;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["fi_id_list"] = this.fi_id_list;
        return data;
    }

    clone(): ImportRepository {
        const json = this.toJSON();
        let result = new ImportRepository();
        result.init(json);
        return result;
    }
}

export interface IImportRepository {
    id: number;
    im_re_id: number;
    im_re_code: string | undefined;
    us_id_import: number;
    su_id: number;
    re_id: number;
    im_re_total_money: number;
    im_re_status: EImportRepositoryStatus;
    im_re_debt: number;
    im_re_is_deleted: boolean;
    im_re_note: string | undefined;
    im_re_created_at: Date;
    im_re_updated_at: Date;
    im_re_imported_at: Date | undefined;
    im_re_deleted_at: Date | undefined;
    tenantId: number;
    listProductImport: string | undefined;
    repository: Repository;
    fi_id_list: string | undefined;
}

export class ImportRepositoryDto implements IImportRepositoryDto {
    im_re_id!: number;
    re_id!: number;
    im_re_code!: string | undefined;
    im_re_total_quantity!: number;
    us_id_import!: number;
    su_id!: number;
    im_re_total_money!: number;
    im_re_status!: EImportRepositoryStatus;
    im_re_debt!: number;
    im_re_note!: string | undefined;
    im_re_created_at!: Date;
    im_re_imported_at!: Date | undefined;
    im_re_export_billing_at!: Date;
    listProductImport!: ProductImportDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    repositoryDto!: RepositoryAbstractDto;

    constructor(data?: IImportRepositoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_re_id = _data["im_re_id"];
            this.re_id = _data["re_id"];
            this.im_re_code = _data["im_re_code"];
            this.im_re_total_quantity = _data["im_re_total_quantity"];
            this.us_id_import = _data["us_id_import"];
            this.su_id = _data["su_id"];
            this.im_re_total_money = _data["im_re_total_money"];
            this.im_re_status = _data["im_re_status"];
            this.im_re_debt = _data["im_re_debt"];
            this.im_re_note = _data["im_re_note"];
            this.im_re_created_at = _data["im_re_created_at"] ? new Date(_data["im_re_created_at"].toString()) : <any>undefined;
            this.im_re_imported_at = _data["im_re_imported_at"] ? new Date(_data["im_re_imported_at"].toString()) : <any>undefined;
            this.im_re_export_billing_at = _data["im_re_export_billing_at"] ? new Date(_data["im_re_export_billing_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listProductImport"])) {
                this.listProductImport = [] as any;
                for (let item of _data["listProductImport"])
                    this.listProductImport!.push(ProductImportDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.repositoryDto = _data["repositoryDto"] ? RepositoryAbstractDto.fromJS(_data["repositoryDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportRepositoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRepositoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_re_id"] = this.im_re_id;
        data["re_id"] = this.re_id;
        data["im_re_code"] = this.im_re_code;
        data["im_re_total_quantity"] = this.im_re_total_quantity;
        data["us_id_import"] = this.us_id_import;
        data["su_id"] = this.su_id;
        data["im_re_total_money"] = this.im_re_total_money;
        data["im_re_status"] = this.im_re_status;
        data["im_re_debt"] = this.im_re_debt;
        data["im_re_note"] = this.im_re_note;
        data["im_re_created_at"] = this.im_re_created_at ? this.im_re_created_at.toISOString() : <any>undefined;
        data["im_re_imported_at"] = this.im_re_imported_at ? this.im_re_imported_at.toISOString() : <any>undefined;
        data["im_re_export_billing_at"] = this.im_re_export_billing_at ? this.im_re_export_billing_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listProductImport)) {
            data["listProductImport"] = [];
            for (let item of this.listProductImport)
                data["listProductImport"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["repositoryDto"] = this.repositoryDto ? this.repositoryDto.toJSON() : <any>undefined;
        return data;
    }

    clone(): ImportRepositoryDto {
        const json = this.toJSON();
        let result = new ImportRepositoryDto();
        result.init(json);
        return result;
    }
}

export interface IImportRepositoryDto {
    im_re_id: number;
    re_id: number;
    im_re_code: string | undefined;
    im_re_total_quantity: number;
    us_id_import: number;
    su_id: number;
    im_re_total_money: number;
    im_re_status: EImportRepositoryStatus;
    im_re_debt: number;
    im_re_note: string | undefined;
    im_re_created_at: Date;
    im_re_imported_at: Date | undefined;
    im_re_export_billing_at: Date;
    listProductImport: ProductImportDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    repositoryDto: RepositoryAbstractDto;
}

export class ImportRepositoryDtoPagedResultDto implements IImportRepositoryDtoPagedResultDto {
    items!: ImportRepositoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IImportRepositoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ImportRepositoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ImportRepositoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRepositoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ImportRepositoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ImportRepositoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IImportRepositoryDtoPagedResultDto {
    items: ImportRepositoryDto[] | undefined;
    totalCount: number;
}

export class Importing implements IImporting {
    id!: number;
    readonly im_id!: number;
    im_code!: string | undefined;
    im_period!: string | undefined;
    im_person_charge!: string | undefined;
    ma_id!: number;
    us_id!: number;
    im_total_drink!: number;
    im_total_frdrink!: number;
    fi_id_list!: string | undefined;
    im_created_at!: Date;
    listImportingDetails!: ImportingDetail[] | undefined;
    tenantId!: number;
    listExportRepository!: ExportRepository[] | undefined;
    _fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IImporting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).im_id = _data["im_id"];
            this.im_code = _data["im_code"];
            this.im_period = _data["im_period"];
            this.im_person_charge = _data["im_person_charge"];
            this.ma_id = _data["ma_id"];
            this.us_id = _data["us_id"];
            this.im_total_drink = _data["im_total_drink"];
            this.im_total_frdrink = _data["im_total_frdrink"];
            this.fi_id_list = _data["fi_id_list"];
            this.im_created_at = _data["im_created_at"] ? new Date(_data["im_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listImportingDetails"])) {
                this.listImportingDetails = [] as any;
                for (let item of _data["listImportingDetails"])
                    this.listImportingDetails!.push(ImportingDetail.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["listExportRepository"])) {
                this.listExportRepository = [] as any;
                for (let item of _data["listExportRepository"])
                    this.listExportRepository!.push(ExportRepository.fromJS(item));
            }
            if (Array.isArray(_data["_fi_id_list"])) {
                this._fi_id_list = [] as any;
                for (let item of _data["_fi_id_list"])
                    this._fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Importing {
        data = typeof data === 'object' ? data : {};
        let result = new Importing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["im_id"] = this.im_id;
        data["im_code"] = this.im_code;
        data["im_period"] = this.im_period;
        data["im_person_charge"] = this.im_person_charge;
        data["ma_id"] = this.ma_id;
        data["us_id"] = this.us_id;
        data["im_total_drink"] = this.im_total_drink;
        data["im_total_frdrink"] = this.im_total_frdrink;
        data["fi_id_list"] = this.fi_id_list;
        data["im_created_at"] = this.im_created_at ? this.im_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listImportingDetails)) {
            data["listImportingDetails"] = [];
            for (let item of this.listImportingDetails)
                data["listImportingDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.listExportRepository)) {
            data["listExportRepository"] = [];
            for (let item of this.listExportRepository)
                data["listExportRepository"].push(item.toJSON());
        }
        if (Array.isArray(this._fi_id_list)) {
            data["_fi_id_list"] = [];
            for (let item of this._fi_id_list)
                data["_fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): Importing {
        const json = this.toJSON();
        let result = new Importing();
        result.init(json);
        return result;
    }
}

export interface IImporting {
    id: number;
    im_id: number;
    im_code: string | undefined;
    im_period: string | undefined;
    im_person_charge: string | undefined;
    ma_id: number;
    us_id: number;
    im_total_drink: number;
    im_total_frdrink: number;
    fi_id_list: string | undefined;
    im_created_at: Date;
    listImportingDetails: ImportingDetail[] | undefined;
    tenantId: number;
    listExportRepository: ExportRepository[] | undefined;
    _fi_id_list: AttachmentItem[] | undefined;
}

export class ImportingDetail implements IImportingDetail {
    id!: number;
    readonly im_de_id!: number;
    im_id!: number;
    im_de_slot_id!: number;
    pr_id!: number;
    pr_name!: string | undefined;
    im_de_product_type!: DrinkType;
    im_de_quantity!: number;
    im_de_type!: EImportDetailType;
    im_de_money!: number;
    tenantId!: number;
    product!: Product;
    importing!: Importing;

    constructor(data?: IImportingDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).im_de_id = _data["im_de_id"];
            this.im_id = _data["im_id"];
            this.im_de_slot_id = _data["im_de_slot_id"];
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.im_de_product_type = _data["im_de_product_type"];
            this.im_de_quantity = _data["im_de_quantity"];
            this.im_de_type = _data["im_de_type"];
            this.im_de_money = _data["im_de_money"];
            this.tenantId = _data["tenantId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.importing = _data["importing"] ? Importing.fromJS(_data["importing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportingDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ImportingDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["im_de_id"] = this.im_de_id;
        data["im_id"] = this.im_id;
        data["im_de_slot_id"] = this.im_de_slot_id;
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["im_de_product_type"] = this.im_de_product_type;
        data["im_de_quantity"] = this.im_de_quantity;
        data["im_de_type"] = this.im_de_type;
        data["im_de_money"] = this.im_de_money;
        data["tenantId"] = this.tenantId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["importing"] = this.importing ? this.importing.toJSON() : <any>undefined;
        return data;
    }

    clone(): ImportingDetail {
        const json = this.toJSON();
        let result = new ImportingDetail();
        result.init(json);
        return result;
    }
}

export interface IImportingDetail {
    id: number;
    im_de_id: number;
    im_id: number;
    im_de_slot_id: number;
    pr_id: number;
    pr_name: string | undefined;
    im_de_product_type: DrinkType;
    im_de_quantity: number;
    im_de_type: EImportDetailType;
    im_de_money: number;
    tenantId: number;
    product: Product;
    importing: Importing;
}

export class ImportingDetailAbstractDto implements IImportingDetailAbstractDto {
    im_de_id!: number;
    im_id!: number;
    im_de_slot_id!: number;
    pr_name!: string | undefined;
    im_de_product_type!: DrinkType;
    im_de_quantity!: number;
    im_de_type!: EImportDetailType;
    im_de_money!: number;

    constructor(data?: IImportingDetailAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_de_id = _data["im_de_id"];
            this.im_id = _data["im_id"];
            this.im_de_slot_id = _data["im_de_slot_id"];
            this.pr_name = _data["pr_name"];
            this.im_de_product_type = _data["im_de_product_type"];
            this.im_de_quantity = _data["im_de_quantity"];
            this.im_de_type = _data["im_de_type"];
            this.im_de_money = _data["im_de_money"];
        }
    }

    static fromJS(data: any): ImportingDetailAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportingDetailAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_de_id"] = this.im_de_id;
        data["im_id"] = this.im_id;
        data["im_de_slot_id"] = this.im_de_slot_id;
        data["pr_name"] = this.pr_name;
        data["im_de_product_type"] = this.im_de_product_type;
        data["im_de_quantity"] = this.im_de_quantity;
        data["im_de_type"] = this.im_de_type;
        data["im_de_money"] = this.im_de_money;
        return data;
    }

    clone(): ImportingDetailAbstractDto {
        const json = this.toJSON();
        let result = new ImportingDetailAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IImportingDetailAbstractDto {
    im_de_id: number;
    im_id: number;
    im_de_slot_id: number;
    pr_name: string | undefined;
    im_de_product_type: DrinkType;
    im_de_quantity: number;
    im_de_type: EImportDetailType;
    im_de_money: number;
}

export class ImportingDto implements IImportingDto {
    im_id!: number;
    im_code!: string | undefined;
    im_period!: string | undefined;
    im_person_charge!: string | undefined;
    ma_id!: number;
    us_id!: number;
    im_total_drink!: number;
    im_total_frdrink!: number;
    im_created_at!: Date;
    fi_id_list!: AttachmentItem[] | undefined;
    listImportingDetails!: ImportingDetailAbstractDto[] | undefined;

    constructor(data?: IImportingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_id = _data["im_id"];
            this.im_code = _data["im_code"];
            this.im_period = _data["im_period"];
            this.im_person_charge = _data["im_person_charge"];
            this.ma_id = _data["ma_id"];
            this.us_id = _data["us_id"];
            this.im_total_drink = _data["im_total_drink"];
            this.im_total_frdrink = _data["im_total_frdrink"];
            this.im_created_at = _data["im_created_at"] ? new Date(_data["im_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["listImportingDetails"])) {
                this.listImportingDetails = [] as any;
                for (let item of _data["listImportingDetails"])
                    this.listImportingDetails!.push(ImportingDetailAbstractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_id"] = this.im_id;
        data["im_code"] = this.im_code;
        data["im_period"] = this.im_period;
        data["im_person_charge"] = this.im_person_charge;
        data["ma_id"] = this.ma_id;
        data["us_id"] = this.us_id;
        data["im_total_drink"] = this.im_total_drink;
        data["im_total_frdrink"] = this.im_total_frdrink;
        data["im_created_at"] = this.im_created_at ? this.im_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        if (Array.isArray(this.listImportingDetails)) {
            data["listImportingDetails"] = [];
            for (let item of this.listImportingDetails)
                data["listImportingDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImportingDto {
        const json = this.toJSON();
        let result = new ImportingDto();
        result.init(json);
        return result;
    }
}

export interface IImportingDto {
    im_id: number;
    im_code: string | undefined;
    im_period: string | undefined;
    im_person_charge: string | undefined;
    ma_id: number;
    us_id: number;
    im_total_drink: number;
    im_total_frdrink: number;
    im_created_at: Date;
    fi_id_list: AttachmentItem[] | undefined;
    listImportingDetails: ImportingDetailAbstractDto[] | undefined;
}

export class ImportingDtoPagedResultDto implements IImportingDtoPagedResultDto {
    items!: ImportingDto[] | undefined;
    totalCount!: number;

    constructor(data?: IImportingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ImportingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ImportingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ImportingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ImportingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IImportingDtoPagedResultDto {
    items: ImportingDto[] | undefined;
    totalCount: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id!: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): IntPtr {
        const json = this.toJSON();
        let result = new IntPtr();
        result.init(json);
        return result;
    }
}

export interface IIntPtr {
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class ItemBillingEntity implements IItemBillingEntity {
    slot_id!: number;
    product_id!: number;
    product_name!: string | undefined;
    isErrorSlot!: boolean;
    product_type!: DrinkType;
    product_money!: number;
    money2Quanties!: number;
    product_no_order!: number;
    product_no_cur!: number;
    statusPaidProduct!: StatusPaidProduct[] | undefined;

    constructor(data?: IItemBillingEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.slot_id = _data["slot_id"];
            this.product_id = _data["product_id"];
            this.product_name = _data["product_name"];
            this.isErrorSlot = _data["isErrorSlot"];
            this.product_type = _data["product_type"];
            this.product_money = _data["product_money"];
            this.money2Quanties = _data["money2Quanties"];
            this.product_no_order = _data["product_no_order"];
            this.product_no_cur = _data["product_no_cur"];
            if (Array.isArray(_data["statusPaidProduct"])) {
                this.statusPaidProduct = [] as any;
                for (let item of _data["statusPaidProduct"])
                    this.statusPaidProduct!.push(StatusPaidProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemBillingEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ItemBillingEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["slot_id"] = this.slot_id;
        data["product_id"] = this.product_id;
        data["product_name"] = this.product_name;
        data["isErrorSlot"] = this.isErrorSlot;
        data["product_type"] = this.product_type;
        data["product_money"] = this.product_money;
        data["money2Quanties"] = this.money2Quanties;
        data["product_no_order"] = this.product_no_order;
        data["product_no_cur"] = this.product_no_cur;
        if (Array.isArray(this.statusPaidProduct)) {
            data["statusPaidProduct"] = [];
            for (let item of this.statusPaidProduct)
                data["statusPaidProduct"].push(item.toJSON());
        }
        return data;
    }

    clone(): ItemBillingEntity {
        const json = this.toJSON();
        let result = new ItemBillingEntity();
        result.init(json);
        return result;
    }
}

export interface IItemBillingEntity {
    slot_id: number;
    product_id: number;
    product_name: string | undefined;
    isErrorSlot: boolean;
    product_type: DrinkType;
    product_money: number;
    money2Quanties: number;
    product_no_order: number;
    product_no_cur: number;
    statusPaidProduct: StatusPaidProduct[] | undefined;
}

export class ItemChartDashBoard implements IItemChartDashBoard {
    id!: number;
    name!: string | undefined;
    value!: number;

    constructor(data?: IItemChartDashBoard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ItemChartDashBoard {
        data = typeof data === 'object' ? data : {};
        let result = new ItemChartDashBoard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): ItemChartDashBoard {
        const json = this.toJSON();
        let result = new ItemChartDashBoard();
        result.init(json);
        return result;
    }
}

export interface IItemChartDashBoard {
    id: number;
    name: string | undefined;
    value: number;
}

export class ItemChartDashBoardCombination implements IItemChartDashBoardCombination {
    id!: number;
    name!: string | undefined;
    valueColumn1!: number;
    valueColumn2!: number;
    valueColumn3!: number;

    constructor(data?: IItemChartDashBoardCombination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.valueColumn1 = _data["valueColumn1"];
            this.valueColumn2 = _data["valueColumn2"];
            this.valueColumn3 = _data["valueColumn3"];
        }
    }

    static fromJS(data: any): ItemChartDashBoardCombination {
        data = typeof data === 'object' ? data : {};
        let result = new ItemChartDashBoardCombination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["valueColumn1"] = this.valueColumn1;
        data["valueColumn2"] = this.valueColumn2;
        data["valueColumn3"] = this.valueColumn3;
        return data;
    }

    clone(): ItemChartDashBoardCombination {
        const json = this.toJSON();
        let result = new ItemChartDashBoardCombination();
        result.init(json);
        return result;
    }
}

export interface IItemChartDashBoardCombination {
    id: number;
    name: string | undefined;
    valueColumn1: number;
    valueColumn2: number;
    valueColumn3: number;
}

export class ItemProductLoad implements IItemProductLoad {
    slot_id!: number;
    product_name!: string | undefined;
    product_id!: number;
    slot_quantity!: number;
    slot_type!: EImportDetailType;
    slot_money!: number;

    constructor(data?: IItemProductLoad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.slot_id = _data["slot_id"];
            this.product_name = _data["product_name"];
            this.product_id = _data["product_id"];
            this.slot_quantity = _data["slot_quantity"];
            this.slot_type = _data["slot_type"];
            this.slot_money = _data["slot_money"];
        }
    }

    static fromJS(data: any): ItemProductLoad {
        data = typeof data === 'object' ? data : {};
        let result = new ItemProductLoad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["slot_id"] = this.slot_id;
        data["product_name"] = this.product_name;
        data["product_id"] = this.product_id;
        data["slot_quantity"] = this.slot_quantity;
        data["slot_type"] = this.slot_type;
        data["slot_money"] = this.slot_money;
        return data;
    }

    clone(): ItemProductLoad {
        const json = this.toJSON();
        let result = new ItemProductLoad();
        result.init(json);
        return result;
    }
}

export interface IItemProductLoad {
    slot_id: number;
    product_name: string | undefined;
    product_id: number;
    slot_quantity: number;
    slot_type: EImportDetailType;
    slot_money: number;
}

export class KeySizes implements IKeySizes {
    minSize!: number;
    maxSize!: number;
    skipSize!: number;

    constructor(data?: IKeySizes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minSize = _data["minSize"];
            this.maxSize = _data["maxSize"];
            this.skipSize = _data["skipSize"];
        }
    }

    static fromJS(data: any): KeySizes {
        data = typeof data === 'object' ? data : {};
        let result = new KeySizes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minSize"] = this.minSize;
        data["maxSize"] = this.maxSize;
        data["skipSize"] = this.skipSize;
        return data;
    }

    clone(): KeySizes {
        const json = this.toJSON();
        let result = new KeySizes();
        result.init(json);
        return result;
    }
}

export interface IKeySizes {
    minSize: number;
    maxSize: number;
    skipSize: number;
}

export class LayoutDto implements ILayoutDto {
    la_id!: number;
    la_name!: string | undefined;
    la_slots!: LayoutSlotDto[] | undefined;
    us_id_owner!: number;
    la_desc!: string | undefined;
    la_type!: string | undefined;
    us_id_create!: number;
    la_is_deleted!: boolean;
    la_created_at!: Date;
    la_updated_at!: Date;
    la_deleted_at!: Date;

    constructor(data?: ILayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_id = _data["la_id"];
            this.la_name = _data["la_name"];
            if (Array.isArray(_data["la_slots"])) {
                this.la_slots = [] as any;
                for (let item of _data["la_slots"])
                    this.la_slots!.push(LayoutSlotDto.fromJS(item));
            }
            this.us_id_owner = _data["us_id_owner"];
            this.la_desc = _data["la_desc"];
            this.la_type = _data["la_type"];
            this.us_id_create = _data["us_id_create"];
            this.la_is_deleted = _data["la_is_deleted"];
            this.la_created_at = _data["la_created_at"] ? new Date(_data["la_created_at"].toString()) : <any>undefined;
            this.la_updated_at = _data["la_updated_at"] ? new Date(_data["la_updated_at"].toString()) : <any>undefined;
            this.la_deleted_at = _data["la_deleted_at"] ? new Date(_data["la_deleted_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_id"] = this.la_id;
        data["la_name"] = this.la_name;
        if (Array.isArray(this.la_slots)) {
            data["la_slots"] = [];
            for (let item of this.la_slots)
                data["la_slots"].push(item.toJSON());
        }
        data["us_id_owner"] = this.us_id_owner;
        data["la_desc"] = this.la_desc;
        data["la_type"] = this.la_type;
        data["us_id_create"] = this.us_id_create;
        data["la_is_deleted"] = this.la_is_deleted;
        data["la_created_at"] = this.la_created_at ? this.la_created_at.toISOString() : <any>undefined;
        data["la_updated_at"] = this.la_updated_at ? this.la_updated_at.toISOString() : <any>undefined;
        data["la_deleted_at"] = this.la_deleted_at ? this.la_deleted_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): LayoutDto {
        const json = this.toJSON();
        let result = new LayoutDto();
        result.init(json);
        return result;
    }
}

export interface ILayoutDto {
    la_id: number;
    la_name: string | undefined;
    la_slots: LayoutSlotDto[] | undefined;
    us_id_owner: number;
    la_desc: string | undefined;
    la_type: string | undefined;
    us_id_create: number;
    la_is_deleted: boolean;
    la_created_at: Date;
    la_updated_at: Date;
    la_deleted_at: Date;
}

export class LayoutDtoPagedResultDto implements ILayoutDtoPagedResultDto {
    items!: LayoutDto[] | undefined;
    totalCount!: number;

    constructor(data?: ILayoutDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LayoutDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LayoutDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayoutDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LayoutDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LayoutDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILayoutDtoPagedResultDto {
    items: LayoutDto[] | undefined;
    totalCount: number;
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class LayoutSlotDto implements ILayoutSlotDto {
    slot_id!: number;
    pr_id!: number;
    quantity_max!: number;

    constructor(data?: ILayoutSlotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.slot_id = _data["slot_id"];
            this.pr_id = _data["pr_id"];
            this.quantity_max = _data["quantity_max"];
        }
    }

    static fromJS(data: any): LayoutSlotDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayoutSlotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["slot_id"] = this.slot_id;
        data["pr_id"] = this.pr_id;
        data["quantity_max"] = this.quantity_max;
        return data;
    }

    clone(): LayoutSlotDto {
        const json = this.toJSON();
        let result = new LayoutSlotDto();
        result.init(json);
        return result;
    }
}

export interface ILayoutSlotDto {
    slot_id: number;
    pr_id: number;
    quantity_max: number;
}

export class LoadProductInput implements ILoadProductInput {
    im_code!: string | undefined;
    devID!: string | undefined;
    slotsVending!: ItemProductLoad[] | undefined;
    slotsRefill!: ItemProductLoad[] | undefined;
    im_created_at!: Date;

    constructor(data?: ILoadProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_code = _data["im_code"];
            this.devID = _data["devID"];
            if (Array.isArray(_data["slotsVending"])) {
                this.slotsVending = [] as any;
                for (let item of _data["slotsVending"])
                    this.slotsVending!.push(ItemProductLoad.fromJS(item));
            }
            if (Array.isArray(_data["slotsRefill"])) {
                this.slotsRefill = [] as any;
                for (let item of _data["slotsRefill"])
                    this.slotsRefill!.push(ItemProductLoad.fromJS(item));
            }
            this.im_created_at = _data["im_created_at"] ? new Date(_data["im_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LoadProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new LoadProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_code"] = this.im_code;
        data["devID"] = this.devID;
        if (Array.isArray(this.slotsVending)) {
            data["slotsVending"] = [];
            for (let item of this.slotsVending)
                data["slotsVending"].push(item.toJSON());
        }
        if (Array.isArray(this.slotsRefill)) {
            data["slotsRefill"] = [];
            for (let item of this.slotsRefill)
                data["slotsRefill"].push(item.toJSON());
        }
        data["im_created_at"] = this.im_created_at ? this.im_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): LoadProductInput {
        const json = this.toJSON();
        let result = new LoadProductInput();
        result.init(json);
        return result;
    }
}

export interface ILoadProductInput {
    im_code: string | undefined;
    devID: string | undefined;
    slotsVending: ItemProductLoad[] | undefined;
    slotsRefill: ItemProductLoad[] | undefined;
    im_created_at: Date;
}

export class LossRepository implements ILossRepository {
    id!: number;
    readonly lo_re_id!: number;
    lo_re_code!: string | undefined;
    us_id_import!: number;
    re_id!: number;
    lo_re_reason!: string | undefined;
    lo_re_is_deleted!: boolean;
    lo_re_status!: ELossRepositoryStatus;
    lo_re_created_at!: Date;
    lo_re_updated_at!: Date;
    lo_re_deleted_at!: Date | undefined;
    tenantId!: number;
    listProductLoss!: string | undefined;
    repository!: Repository;
    fi_id_list!: string | undefined;

    constructor(data?: ILossRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).lo_re_id = _data["lo_re_id"];
            this.lo_re_code = _data["lo_re_code"];
            this.us_id_import = _data["us_id_import"];
            this.re_id = _data["re_id"];
            this.lo_re_reason = _data["lo_re_reason"];
            this.lo_re_is_deleted = _data["lo_re_is_deleted"];
            this.lo_re_status = _data["lo_re_status"];
            this.lo_re_created_at = _data["lo_re_created_at"] ? new Date(_data["lo_re_created_at"].toString()) : <any>undefined;
            this.lo_re_updated_at = _data["lo_re_updated_at"] ? new Date(_data["lo_re_updated_at"].toString()) : <any>undefined;
            this.lo_re_deleted_at = _data["lo_re_deleted_at"] ? new Date(_data["lo_re_deleted_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.listProductLoss = _data["listProductLoss"];
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.fi_id_list = _data["fi_id_list"];
        }
    }

    static fromJS(data: any): LossRepository {
        data = typeof data === 'object' ? data : {};
        let result = new LossRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lo_re_id"] = this.lo_re_id;
        data["lo_re_code"] = this.lo_re_code;
        data["us_id_import"] = this.us_id_import;
        data["re_id"] = this.re_id;
        data["lo_re_reason"] = this.lo_re_reason;
        data["lo_re_is_deleted"] = this.lo_re_is_deleted;
        data["lo_re_status"] = this.lo_re_status;
        data["lo_re_created_at"] = this.lo_re_created_at ? this.lo_re_created_at.toISOString() : <any>undefined;
        data["lo_re_updated_at"] = this.lo_re_updated_at ? this.lo_re_updated_at.toISOString() : <any>undefined;
        data["lo_re_deleted_at"] = this.lo_re_deleted_at ? this.lo_re_deleted_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["listProductLoss"] = this.listProductLoss;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["fi_id_list"] = this.fi_id_list;
        return data;
    }

    clone(): LossRepository {
        const json = this.toJSON();
        let result = new LossRepository();
        result.init(json);
        return result;
    }
}

export interface ILossRepository {
    id: number;
    lo_re_id: number;
    lo_re_code: string | undefined;
    us_id_import: number;
    re_id: number;
    lo_re_reason: string | undefined;
    lo_re_is_deleted: boolean;
    lo_re_status: ELossRepositoryStatus;
    lo_re_created_at: Date;
    lo_re_updated_at: Date;
    lo_re_deleted_at: Date | undefined;
    tenantId: number;
    listProductLoss: string | undefined;
    repository: Repository;
    fi_id_list: string | undefined;
}

export class LossRepositoryDto implements ILossRepositoryDto {
    lo_re_id!: number;
    lo_re_code!: string | undefined;
    lo_re_total_quantity!: number;
    us_id_import!: number;
    re_id!: number;
    lo_re_reason!: string | undefined;
    lo_re_is_deleted!: boolean;
    lo_re_status!: ELossRepositoryStatus;
    lo_re_created_at!: Date;
    lo_re_updated_at!: Date;
    lo_re_deleted_at!: Date | undefined;
    listProductLoss!: ProductLossDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    repositoryDto!: RepositoryAbstractDto;

    constructor(data?: ILossRepositoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lo_re_id = _data["lo_re_id"];
            this.lo_re_code = _data["lo_re_code"];
            this.lo_re_total_quantity = _data["lo_re_total_quantity"];
            this.us_id_import = _data["us_id_import"];
            this.re_id = _data["re_id"];
            this.lo_re_reason = _data["lo_re_reason"];
            this.lo_re_is_deleted = _data["lo_re_is_deleted"];
            this.lo_re_status = _data["lo_re_status"];
            this.lo_re_created_at = _data["lo_re_created_at"] ? new Date(_data["lo_re_created_at"].toString()) : <any>undefined;
            this.lo_re_updated_at = _data["lo_re_updated_at"] ? new Date(_data["lo_re_updated_at"].toString()) : <any>undefined;
            this.lo_re_deleted_at = _data["lo_re_deleted_at"] ? new Date(_data["lo_re_deleted_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listProductLoss"])) {
                this.listProductLoss = [] as any;
                for (let item of _data["listProductLoss"])
                    this.listProductLoss!.push(ProductLossDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.repositoryDto = _data["repositoryDto"] ? RepositoryAbstractDto.fromJS(_data["repositoryDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LossRepositoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LossRepositoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lo_re_id"] = this.lo_re_id;
        data["lo_re_code"] = this.lo_re_code;
        data["lo_re_total_quantity"] = this.lo_re_total_quantity;
        data["us_id_import"] = this.us_id_import;
        data["re_id"] = this.re_id;
        data["lo_re_reason"] = this.lo_re_reason;
        data["lo_re_is_deleted"] = this.lo_re_is_deleted;
        data["lo_re_status"] = this.lo_re_status;
        data["lo_re_created_at"] = this.lo_re_created_at ? this.lo_re_created_at.toISOString() : <any>undefined;
        data["lo_re_updated_at"] = this.lo_re_updated_at ? this.lo_re_updated_at.toISOString() : <any>undefined;
        data["lo_re_deleted_at"] = this.lo_re_deleted_at ? this.lo_re_deleted_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listProductLoss)) {
            data["listProductLoss"] = [];
            for (let item of this.listProductLoss)
                data["listProductLoss"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["repositoryDto"] = this.repositoryDto ? this.repositoryDto.toJSON() : <any>undefined;
        return data;
    }

    clone(): LossRepositoryDto {
        const json = this.toJSON();
        let result = new LossRepositoryDto();
        result.init(json);
        return result;
    }
}

export interface ILossRepositoryDto {
    lo_re_id: number;
    lo_re_code: string | undefined;
    lo_re_total_quantity: number;
    us_id_import: number;
    re_id: number;
    lo_re_reason: string | undefined;
    lo_re_is_deleted: boolean;
    lo_re_status: ELossRepositoryStatus;
    lo_re_created_at: Date;
    lo_re_updated_at: Date;
    lo_re_deleted_at: Date | undefined;
    listProductLoss: ProductLossDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    repositoryDto: RepositoryAbstractDto;
}

export class LossRepositoryDtoPagedResultDto implements ILossRepositoryDtoPagedResultDto {
    items!: LossRepositoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: ILossRepositoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LossRepositoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LossRepositoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LossRepositoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LossRepositoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LossRepositoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILossRepositoryDtoPagedResultDto {
    items: LossRepositoryDto[] | undefined;
    totalCount: number;
}

export class Machine implements IMachine {
    id!: number;
    readonly ma_id!: number;
    gr_ma_id!: number;
    ma_code!: string | undefined;
    ma_passcode_admin!: string | undefined;
    ma_passcode_replenish!: string | undefined;
    ma_display_name!: string | undefined;
    ma_mac!: string | undefined;
    ma_hardware_version_name!: string | undefined;
    ma_hardware_version_code!: number;
    us_id_login!: number;
    us_id_operator!: number;
    tenantId!: number;
    ma_money_drink!: number;
    ma_money_freshdrink!: number;
    ma_no_drink!: number;
    ma_no_fr_drink!: number;
    ma_no_drink_change!: number;
    ma_no_frdrink_change!: number;
    ma_total_current_cash!: number;
    ma_bg_image!: number;
    ma_gps_lat!: string | undefined;
    ma_gps_lng!: string | undefined;
    ma_mapUrl!: string | undefined;
    ma_mapName!: string | undefined;
    ma_isApplyDiscountCode!: boolean;
    ma_timeRepeatBootCheck!: number;
    ma_timeRepeatCheckQRQueue!: number;
    ma_restartMachineAt!: string | undefined;
    ma_rangeDisplayVending!: number;
    ma_turnOnGlassHeat!: boolean;
    workingTimeGlassHeat!: string | undefined;
    ma_hasDropSensor!: boolean;
    ma_self_inspection_shipment!: boolean;
    ma_turnOnLedVending!: boolean;
    ma_maxTrayVending!: number;
    workingTimeLedVending!: string | undefined;
    turnOnRefrigeration!: boolean;
    ma_targetTempRefrigeration!: number;
    ma_workingModeRefrigeration!: string | undefined;
    ma_lockAbnormalRefrigeration!: boolean;
    workingTimeRefrigeration!: string | undefined;
    ma_hasRefillSensor!: boolean;
    ma_turnOnledRefill!: boolean;
    ma_minFillOneTime!: number;
    ma_maxTankRefill!: number;
    workingTimeLedRefill!: string | undefined;
    ma_commandVending!: EMainBoard;
    ma_commandRefill!: EMainBoard;
    ma_restartPaymentAfter!: MachineResetPayment;
    ma_activeCashPayment!: boolean;
    ma_activeQrCodePayment!: boolean;
    ma_activeRifdPayment!: boolean;
    ma_activeMomoPayment!: boolean;
    ma_activeMIGPayment!: boolean;
    ma_activeVNPayment!: boolean;
    ma_activeRefill!: boolean;
    ma_unitPayment!: string | undefined;
    ma_status!: MachineStatus;
    ma_is_debug!: boolean;
    ma_layout!: string | undefined;
    ma_is_active!: boolean;
    ma_is_locked!: boolean;
    ma_is_deleted!: boolean;
    ma_cameraUrl!: string | undefined;
    ma_cameraUserName!: string | undefined;
    ma_cameraPassword!: string | undefined;
    ma_created_at!: Date;
    ma_last_withdraw_at!: Date;
    ma_updated_at!: Date;
    ma_delete_at!: Date | undefined;
    ma_lastOnline_at!: Date;
    ma_lastBuyCash_at!: Date | undefined;
    listBillings!: Billing[] | undefined;
    listSwallowCashMachines!: SwallowCashMachine[] | undefined;
    listExportRepository!: ExportRepository[] | undefined;

    constructor(data?: IMachine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).ma_id = _data["ma_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.ma_code = _data["ma_code"];
            this.ma_passcode_admin = _data["ma_passcode_admin"];
            this.ma_passcode_replenish = _data["ma_passcode_replenish"];
            this.ma_display_name = _data["ma_display_name"];
            this.ma_mac = _data["ma_mac"];
            this.ma_hardware_version_name = _data["ma_hardware_version_name"];
            this.ma_hardware_version_code = _data["ma_hardware_version_code"];
            this.us_id_login = _data["us_id_login"];
            this.us_id_operator = _data["us_id_operator"];
            this.tenantId = _data["tenantId"];
            this.ma_money_drink = _data["ma_money_drink"];
            this.ma_money_freshdrink = _data["ma_money_freshdrink"];
            this.ma_no_drink = _data["ma_no_drink"];
            this.ma_no_fr_drink = _data["ma_no_fr_drink"];
            this.ma_no_drink_change = _data["ma_no_drink_change"];
            this.ma_no_frdrink_change = _data["ma_no_frdrink_change"];
            this.ma_total_current_cash = _data["ma_total_current_cash"];
            this.ma_bg_image = _data["ma_bg_image"];
            this.ma_gps_lat = _data["ma_gps_lat"];
            this.ma_gps_lng = _data["ma_gps_lng"];
            this.ma_mapUrl = _data["ma_mapUrl"];
            this.ma_mapName = _data["ma_mapName"];
            this.ma_isApplyDiscountCode = _data["ma_isApplyDiscountCode"];
            this.ma_timeRepeatBootCheck = _data["ma_timeRepeatBootCheck"];
            this.ma_timeRepeatCheckQRQueue = _data["ma_timeRepeatCheckQRQueue"];
            this.ma_restartMachineAt = _data["ma_restartMachineAt"];
            this.ma_rangeDisplayVending = _data["ma_rangeDisplayVending"];
            this.ma_turnOnGlassHeat = _data["ma_turnOnGlassHeat"];
            this.workingTimeGlassHeat = _data["workingTimeGlassHeat"];
            this.ma_hasDropSensor = _data["ma_hasDropSensor"];
            this.ma_self_inspection_shipment = _data["ma_self_inspection_shipment"];
            this.ma_turnOnLedVending = _data["ma_turnOnLedVending"];
            this.ma_maxTrayVending = _data["ma_maxTrayVending"];
            this.workingTimeLedVending = _data["workingTimeLedVending"];
            this.turnOnRefrigeration = _data["turnOnRefrigeration"];
            this.ma_targetTempRefrigeration = _data["ma_targetTempRefrigeration"];
            this.ma_workingModeRefrigeration = _data["ma_workingModeRefrigeration"];
            this.ma_lockAbnormalRefrigeration = _data["ma_lockAbnormalRefrigeration"];
            this.workingTimeRefrigeration = _data["workingTimeRefrigeration"];
            this.ma_hasRefillSensor = _data["ma_hasRefillSensor"];
            this.ma_turnOnledRefill = _data["ma_turnOnledRefill"];
            this.ma_minFillOneTime = _data["ma_minFillOneTime"];
            this.ma_maxTankRefill = _data["ma_maxTankRefill"];
            this.workingTimeLedRefill = _data["workingTimeLedRefill"];
            this.ma_commandVending = _data["ma_commandVending"];
            this.ma_commandRefill = _data["ma_commandRefill"];
            this.ma_restartPaymentAfter = _data["ma_restartPaymentAfter"];
            this.ma_activeCashPayment = _data["ma_activeCashPayment"];
            this.ma_activeQrCodePayment = _data["ma_activeQrCodePayment"];
            this.ma_activeRifdPayment = _data["ma_activeRifdPayment"];
            this.ma_activeMomoPayment = _data["ma_activeMomoPayment"];
            this.ma_activeMIGPayment = _data["ma_activeMIGPayment"];
            this.ma_activeVNPayment = _data["ma_activeVNPayment"];
            this.ma_activeRefill = _data["ma_activeRefill"];
            this.ma_unitPayment = _data["ma_unitPayment"];
            this.ma_status = _data["ma_status"];
            this.ma_is_debug = _data["ma_is_debug"];
            this.ma_layout = _data["ma_layout"];
            this.ma_is_active = _data["ma_is_active"];
            this.ma_is_locked = _data["ma_is_locked"];
            this.ma_is_deleted = _data["ma_is_deleted"];
            this.ma_cameraUrl = _data["ma_cameraUrl"];
            this.ma_cameraUserName = _data["ma_cameraUserName"];
            this.ma_cameraPassword = _data["ma_cameraPassword"];
            this.ma_created_at = _data["ma_created_at"] ? new Date(_data["ma_created_at"].toString()) : <any>undefined;
            this.ma_last_withdraw_at = _data["ma_last_withdraw_at"] ? new Date(_data["ma_last_withdraw_at"].toString()) : <any>undefined;
            this.ma_updated_at = _data["ma_updated_at"] ? new Date(_data["ma_updated_at"].toString()) : <any>undefined;
            this.ma_delete_at = _data["ma_delete_at"] ? new Date(_data["ma_delete_at"].toString()) : <any>undefined;
            this.ma_lastOnline_at = _data["ma_lastOnline_at"] ? new Date(_data["ma_lastOnline_at"].toString()) : <any>undefined;
            this.ma_lastBuyCash_at = _data["ma_lastBuyCash_at"] ? new Date(_data["ma_lastBuyCash_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listBillings"])) {
                this.listBillings = [] as any;
                for (let item of _data["listBillings"])
                    this.listBillings!.push(Billing.fromJS(item));
            }
            if (Array.isArray(_data["listSwallowCashMachines"])) {
                this.listSwallowCashMachines = [] as any;
                for (let item of _data["listSwallowCashMachines"])
                    this.listSwallowCashMachines!.push(SwallowCashMachine.fromJS(item));
            }
            if (Array.isArray(_data["listExportRepository"])) {
                this.listExportRepository = [] as any;
                for (let item of _data["listExportRepository"])
                    this.listExportRepository!.push(ExportRepository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Machine {
        data = typeof data === 'object' ? data : {};
        let result = new Machine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ma_id"] = this.ma_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["ma_code"] = this.ma_code;
        data["ma_passcode_admin"] = this.ma_passcode_admin;
        data["ma_passcode_replenish"] = this.ma_passcode_replenish;
        data["ma_display_name"] = this.ma_display_name;
        data["ma_mac"] = this.ma_mac;
        data["ma_hardware_version_name"] = this.ma_hardware_version_name;
        data["ma_hardware_version_code"] = this.ma_hardware_version_code;
        data["us_id_login"] = this.us_id_login;
        data["us_id_operator"] = this.us_id_operator;
        data["tenantId"] = this.tenantId;
        data["ma_money_drink"] = this.ma_money_drink;
        data["ma_money_freshdrink"] = this.ma_money_freshdrink;
        data["ma_no_drink"] = this.ma_no_drink;
        data["ma_no_fr_drink"] = this.ma_no_fr_drink;
        data["ma_no_drink_change"] = this.ma_no_drink_change;
        data["ma_no_frdrink_change"] = this.ma_no_frdrink_change;
        data["ma_total_current_cash"] = this.ma_total_current_cash;
        data["ma_bg_image"] = this.ma_bg_image;
        data["ma_gps_lat"] = this.ma_gps_lat;
        data["ma_gps_lng"] = this.ma_gps_lng;
        data["ma_mapUrl"] = this.ma_mapUrl;
        data["ma_mapName"] = this.ma_mapName;
        data["ma_isApplyDiscountCode"] = this.ma_isApplyDiscountCode;
        data["ma_timeRepeatBootCheck"] = this.ma_timeRepeatBootCheck;
        data["ma_timeRepeatCheckQRQueue"] = this.ma_timeRepeatCheckQRQueue;
        data["ma_restartMachineAt"] = this.ma_restartMachineAt;
        data["ma_rangeDisplayVending"] = this.ma_rangeDisplayVending;
        data["ma_turnOnGlassHeat"] = this.ma_turnOnGlassHeat;
        data["workingTimeGlassHeat"] = this.workingTimeGlassHeat;
        data["ma_hasDropSensor"] = this.ma_hasDropSensor;
        data["ma_self_inspection_shipment"] = this.ma_self_inspection_shipment;
        data["ma_turnOnLedVending"] = this.ma_turnOnLedVending;
        data["ma_maxTrayVending"] = this.ma_maxTrayVending;
        data["workingTimeLedVending"] = this.workingTimeLedVending;
        data["turnOnRefrigeration"] = this.turnOnRefrigeration;
        data["ma_targetTempRefrigeration"] = this.ma_targetTempRefrigeration;
        data["ma_workingModeRefrigeration"] = this.ma_workingModeRefrigeration;
        data["ma_lockAbnormalRefrigeration"] = this.ma_lockAbnormalRefrigeration;
        data["workingTimeRefrigeration"] = this.workingTimeRefrigeration;
        data["ma_hasRefillSensor"] = this.ma_hasRefillSensor;
        data["ma_turnOnledRefill"] = this.ma_turnOnledRefill;
        data["ma_minFillOneTime"] = this.ma_minFillOneTime;
        data["ma_maxTankRefill"] = this.ma_maxTankRefill;
        data["workingTimeLedRefill"] = this.workingTimeLedRefill;
        data["ma_commandVending"] = this.ma_commandVending;
        data["ma_commandRefill"] = this.ma_commandRefill;
        data["ma_restartPaymentAfter"] = this.ma_restartPaymentAfter;
        data["ma_activeCashPayment"] = this.ma_activeCashPayment;
        data["ma_activeQrCodePayment"] = this.ma_activeQrCodePayment;
        data["ma_activeRifdPayment"] = this.ma_activeRifdPayment;
        data["ma_activeMomoPayment"] = this.ma_activeMomoPayment;
        data["ma_activeMIGPayment"] = this.ma_activeMIGPayment;
        data["ma_activeVNPayment"] = this.ma_activeVNPayment;
        data["ma_activeRefill"] = this.ma_activeRefill;
        data["ma_unitPayment"] = this.ma_unitPayment;
        data["ma_status"] = this.ma_status;
        data["ma_is_debug"] = this.ma_is_debug;
        data["ma_layout"] = this.ma_layout;
        data["ma_is_active"] = this.ma_is_active;
        data["ma_is_locked"] = this.ma_is_locked;
        data["ma_is_deleted"] = this.ma_is_deleted;
        data["ma_cameraUrl"] = this.ma_cameraUrl;
        data["ma_cameraUserName"] = this.ma_cameraUserName;
        data["ma_cameraPassword"] = this.ma_cameraPassword;
        data["ma_created_at"] = this.ma_created_at ? this.ma_created_at.toISOString() : <any>undefined;
        data["ma_last_withdraw_at"] = this.ma_last_withdraw_at ? this.ma_last_withdraw_at.toISOString() : <any>undefined;
        data["ma_updated_at"] = this.ma_updated_at ? this.ma_updated_at.toISOString() : <any>undefined;
        data["ma_delete_at"] = this.ma_delete_at ? this.ma_delete_at.toISOString() : <any>undefined;
        data["ma_lastOnline_at"] = this.ma_lastOnline_at ? this.ma_lastOnline_at.toISOString() : <any>undefined;
        data["ma_lastBuyCash_at"] = this.ma_lastBuyCash_at ? this.ma_lastBuyCash_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listBillings)) {
            data["listBillings"] = [];
            for (let item of this.listBillings)
                data["listBillings"].push(item.toJSON());
        }
        if (Array.isArray(this.listSwallowCashMachines)) {
            data["listSwallowCashMachines"] = [];
            for (let item of this.listSwallowCashMachines)
                data["listSwallowCashMachines"].push(item.toJSON());
        }
        if (Array.isArray(this.listExportRepository)) {
            data["listExportRepository"] = [];
            for (let item of this.listExportRepository)
                data["listExportRepository"].push(item.toJSON());
        }
        return data;
    }

    clone(): Machine {
        const json = this.toJSON();
        let result = new Machine();
        result.init(json);
        return result;
    }
}

export interface IMachine {
    id: number;
    ma_id: number;
    gr_ma_id: number;
    ma_code: string | undefined;
    ma_passcode_admin: string | undefined;
    ma_passcode_replenish: string | undefined;
    ma_display_name: string | undefined;
    ma_mac: string | undefined;
    ma_hardware_version_name: string | undefined;
    ma_hardware_version_code: number;
    us_id_login: number;
    us_id_operator: number;
    tenantId: number;
    ma_money_drink: number;
    ma_money_freshdrink: number;
    ma_no_drink: number;
    ma_no_fr_drink: number;
    ma_no_drink_change: number;
    ma_no_frdrink_change: number;
    ma_total_current_cash: number;
    ma_bg_image: number;
    ma_gps_lat: string | undefined;
    ma_gps_lng: string | undefined;
    ma_mapUrl: string | undefined;
    ma_mapName: string | undefined;
    ma_isApplyDiscountCode: boolean;
    ma_timeRepeatBootCheck: number;
    ma_timeRepeatCheckQRQueue: number;
    ma_restartMachineAt: string | undefined;
    ma_rangeDisplayVending: number;
    ma_turnOnGlassHeat: boolean;
    workingTimeGlassHeat: string | undefined;
    ma_hasDropSensor: boolean;
    ma_self_inspection_shipment: boolean;
    ma_turnOnLedVending: boolean;
    ma_maxTrayVending: number;
    workingTimeLedVending: string | undefined;
    turnOnRefrigeration: boolean;
    ma_targetTempRefrigeration: number;
    ma_workingModeRefrigeration: string | undefined;
    ma_lockAbnormalRefrigeration: boolean;
    workingTimeRefrigeration: string | undefined;
    ma_hasRefillSensor: boolean;
    ma_turnOnledRefill: boolean;
    ma_minFillOneTime: number;
    ma_maxTankRefill: number;
    workingTimeLedRefill: string | undefined;
    ma_commandVending: EMainBoard;
    ma_commandRefill: EMainBoard;
    ma_restartPaymentAfter: MachineResetPayment;
    ma_activeCashPayment: boolean;
    ma_activeQrCodePayment: boolean;
    ma_activeRifdPayment: boolean;
    ma_activeMomoPayment: boolean;
    ma_activeMIGPayment: boolean;
    ma_activeVNPayment: boolean;
    ma_activeRefill: boolean;
    ma_unitPayment: string | undefined;
    ma_status: MachineStatus;
    ma_is_debug: boolean;
    ma_layout: string | undefined;
    ma_is_active: boolean;
    ma_is_locked: boolean;
    ma_is_deleted: boolean;
    ma_cameraUrl: string | undefined;
    ma_cameraUserName: string | undefined;
    ma_cameraPassword: string | undefined;
    ma_created_at: Date;
    ma_last_withdraw_at: Date;
    ma_updated_at: Date;
    ma_delete_at: Date | undefined;
    ma_lastOnline_at: Date;
    ma_lastBuyCash_at: Date | undefined;
    listBillings: Billing[] | undefined;
    listSwallowCashMachines: SwallowCashMachine[] | undefined;
    listExportRepository: ExportRepository[] | undefined;
}

export class MachineAbstractDto implements IMachineAbstractDto {
    ma_id!: number;
    gr_ma_id!: number;
    ma_code!: string | undefined;
    ma_display_name!: string | undefined;
    ma_is_active!: boolean;
    us_id_operator!: number;
    ma_commandVending!: EMainBoard;
    ma_commandRefill!: EMainBoard;
    ma_is_deleted!: boolean;
    ma_gps_lat!: string | undefined;
    ma_gps_lng!: string | undefined;
    ma_mapUrl!: string | undefined;

    constructor(data?: IMachineAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.ma_code = _data["ma_code"];
            this.ma_display_name = _data["ma_display_name"];
            this.ma_is_active = _data["ma_is_active"];
            this.us_id_operator = _data["us_id_operator"];
            this.ma_commandVending = _data["ma_commandVending"];
            this.ma_commandRefill = _data["ma_commandRefill"];
            this.ma_is_deleted = _data["ma_is_deleted"];
            this.ma_gps_lat = _data["ma_gps_lat"];
            this.ma_gps_lng = _data["ma_gps_lng"];
            this.ma_mapUrl = _data["ma_mapUrl"];
        }
    }

    static fromJS(data: any): MachineAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["ma_code"] = this.ma_code;
        data["ma_display_name"] = this.ma_display_name;
        data["ma_is_active"] = this.ma_is_active;
        data["us_id_operator"] = this.us_id_operator;
        data["ma_commandVending"] = this.ma_commandVending;
        data["ma_commandRefill"] = this.ma_commandRefill;
        data["ma_is_deleted"] = this.ma_is_deleted;
        data["ma_gps_lat"] = this.ma_gps_lat;
        data["ma_gps_lng"] = this.ma_gps_lng;
        data["ma_mapUrl"] = this.ma_mapUrl;
        return data;
    }

    clone(): MachineAbstractDto {
        const json = this.toJSON();
        let result = new MachineAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IMachineAbstractDto {
    ma_id: number;
    gr_ma_id: number;
    ma_code: string | undefined;
    ma_display_name: string | undefined;
    ma_is_active: boolean;
    us_id_operator: number;
    ma_commandVending: EMainBoard;
    ma_commandRefill: EMainBoard;
    ma_is_deleted: boolean;
    ma_gps_lat: string | undefined;
    ma_gps_lng: string | undefined;
    ma_mapUrl: string | undefined;
}

export class MachineDetailDto implements IMachineDetailDto {
    ma_de_id!: number;
    ma_id!: number;
    ma_de_cur!: number;
    ma_de_max!: number;
    dr_type!: DrinkType;
    ma_de_slot_id!: number;
    pr_id!: number;
    productDto!: ProductDto;
    pr_name!: string | undefined;
    pr_money!: number;
    product_money_original!: number;
    isError!: boolean;
    ma_de_is_deleted!: boolean;

    constructor(data?: IMachineDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_de_id = _data["ma_de_id"];
            this.ma_id = _data["ma_id"];
            this.ma_de_cur = _data["ma_de_cur"];
            this.ma_de_max = _data["ma_de_max"];
            this.dr_type = _data["dr_type"];
            this.ma_de_slot_id = _data["ma_de_slot_id"];
            this.pr_id = _data["pr_id"];
            this.productDto = _data["productDto"] ? ProductDto.fromJS(_data["productDto"]) : <any>undefined;
            this.pr_name = _data["pr_name"];
            this.pr_money = _data["pr_money"];
            this.product_money_original = _data["product_money_original"];
            this.isError = _data["isError"];
            this.ma_de_is_deleted = _data["ma_de_is_deleted"];
        }
    }

    static fromJS(data: any): MachineDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_de_id"] = this.ma_de_id;
        data["ma_id"] = this.ma_id;
        data["ma_de_cur"] = this.ma_de_cur;
        data["ma_de_max"] = this.ma_de_max;
        data["dr_type"] = this.dr_type;
        data["ma_de_slot_id"] = this.ma_de_slot_id;
        data["pr_id"] = this.pr_id;
        data["productDto"] = this.productDto ? this.productDto.toJSON() : <any>undefined;
        data["pr_name"] = this.pr_name;
        data["pr_money"] = this.pr_money;
        data["product_money_original"] = this.product_money_original;
        data["isError"] = this.isError;
        data["ma_de_is_deleted"] = this.ma_de_is_deleted;
        return data;
    }

    clone(): MachineDetailDto {
        const json = this.toJSON();
        let result = new MachineDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMachineDetailDto {
    ma_de_id: number;
    ma_id: number;
    ma_de_cur: number;
    ma_de_max: number;
    dr_type: DrinkType;
    ma_de_slot_id: number;
    pr_id: number;
    productDto: ProductDto;
    pr_name: string | undefined;
    pr_money: number;
    product_money_original: number;
    isError: boolean;
    ma_de_is_deleted: boolean;
}

export class MachineDetailDtoListResultDto implements IMachineDetailDtoListResultDto {
    items!: MachineDetailDto[] | undefined;

    constructor(data?: IMachineDetailDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MachineDetailDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineDetailDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MachineDetailDtoListResultDto {
        const json = this.toJSON();
        let result = new MachineDetailDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineDetailDtoListResultDto {
    items: MachineDetailDto[] | undefined;
}

export class MachineDto implements IMachineDto {
    ma_id!: number;
    gr_ma_id!: number;
    ma_code!: string | undefined;
    ma_passcode_admin!: string | undefined;
    ma_passcode_replenish!: string | undefined;
    ma_display_name!: string | undefined;
    ma_mac!: string | undefined;
    us_id_login!: number;
    us_id_operator!: number;
    ma_money_drink!: number;
    ma_money_freshdrink!: number;
    ma_no_drink!: number;
    ma_no_fr_drink!: number;
    ma_no_drink_change!: number;
    ma_no_frdrink_change!: number;
    ma_bg_image!: number;
    ma_gps_lat!: string | undefined;
    ma_gps_lng!: string | undefined;
    ma_mapUrl!: string | undefined;
    ma_mapName!: string | undefined;
    ma_isApplyDiscountCode!: boolean;
    ma_timeRepeatBootCheck!: number;
    ma_timeRepeatCheckQRQueue!: number;
    ma_restartMachineAt!: string | undefined;
    ma_rangeDisplayVending!: number;
    ma_turnOnGlassHeat!: boolean;
    workingTimeGlassHeat!: string | undefined;
    ma_hasDropSensor!: boolean;
    ma_self_inspection_shipment!: boolean;
    ma_turnOnLedVending!: boolean;
    ma_maxTrayVending!: number;
    workingTimeLedVending!: string | undefined;
    turnOnRefrigeration!: boolean;
    ma_targetTempRefrigeration!: number;
    ma_workingModeRefrigeration!: string | undefined;
    ma_lockAbnormalRefrigeration!: boolean;
    workingTimeRefrigeration!: string | undefined;
    ma_hasRefillSensor!: boolean;
    ma_turnOnledRefill!: boolean;
    ma_minFillOneTime!: number;
    ma_maxTankRefill!: number;
    workingTimeLedRefill!: string | undefined;
    ma_commandVending!: EMainBoard;
    ma_commandRefill!: EMainBoard;
    ma_restartPaymentAfter!: MachineResetPayment;
    ma_activeCashPayment!: boolean;
    ma_activeQrCodePayment!: boolean;
    ma_activeRifdPayment!: boolean;
    ma_activeRefill!: boolean;
    ma_unitPayment!: string | undefined;
    ma_is_debug!: boolean;
    ma_is_active!: boolean;
    ma_layout!: string | undefined;
    ma_is_locked!: boolean;
    ma_is_deleted!: boolean;
    ma_cameraUrl!: string | undefined;
    ma_cameraUserName!: string | undefined;
    ma_cameraPassword!: string | undefined;
    ma_hardware_version_name!: string | undefined;
    ma_hardware_version_code!: number;
    ma_created_at!: Date;
    ma_updated_at!: Date;
    ma_last_withdraw_at!: Date;
    ma_delete_at!: Date | undefined;
    ma_total_current_cash!: number;
    ma_activeMomoPayment!: boolean;
    ma_activeMIGPayment!: boolean;
    ma_activeVNPayment!: boolean;
    ma_networkStatus!: MachineNetworkStatus;
    ma_lastOnline_at!: Date | undefined;
    ma_lastBuyCash_at!: Date | undefined;
    ma_status!: MachineStatus;

    constructor(data?: IMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.ma_code = _data["ma_code"];
            this.ma_passcode_admin = _data["ma_passcode_admin"];
            this.ma_passcode_replenish = _data["ma_passcode_replenish"];
            this.ma_display_name = _data["ma_display_name"];
            this.ma_mac = _data["ma_mac"];
            this.us_id_login = _data["us_id_login"];
            this.us_id_operator = _data["us_id_operator"];
            this.ma_money_drink = _data["ma_money_drink"];
            this.ma_money_freshdrink = _data["ma_money_freshdrink"];
            this.ma_no_drink = _data["ma_no_drink"];
            this.ma_no_fr_drink = _data["ma_no_fr_drink"];
            this.ma_no_drink_change = _data["ma_no_drink_change"];
            this.ma_no_frdrink_change = _data["ma_no_frdrink_change"];
            this.ma_bg_image = _data["ma_bg_image"];
            this.ma_gps_lat = _data["ma_gps_lat"];
            this.ma_gps_lng = _data["ma_gps_lng"];
            this.ma_mapUrl = _data["ma_mapUrl"];
            this.ma_mapName = _data["ma_mapName"];
            this.ma_isApplyDiscountCode = _data["ma_isApplyDiscountCode"];
            this.ma_timeRepeatBootCheck = _data["ma_timeRepeatBootCheck"];
            this.ma_timeRepeatCheckQRQueue = _data["ma_timeRepeatCheckQRQueue"];
            this.ma_restartMachineAt = _data["ma_restartMachineAt"];
            this.ma_rangeDisplayVending = _data["ma_rangeDisplayVending"];
            this.ma_turnOnGlassHeat = _data["ma_turnOnGlassHeat"];
            this.workingTimeGlassHeat = _data["workingTimeGlassHeat"];
            this.ma_hasDropSensor = _data["ma_hasDropSensor"];
            this.ma_self_inspection_shipment = _data["ma_self_inspection_shipment"];
            this.ma_turnOnLedVending = _data["ma_turnOnLedVending"];
            this.ma_maxTrayVending = _data["ma_maxTrayVending"];
            this.workingTimeLedVending = _data["workingTimeLedVending"];
            this.turnOnRefrigeration = _data["turnOnRefrigeration"];
            this.ma_targetTempRefrigeration = _data["ma_targetTempRefrigeration"];
            this.ma_workingModeRefrigeration = _data["ma_workingModeRefrigeration"];
            this.ma_lockAbnormalRefrigeration = _data["ma_lockAbnormalRefrigeration"];
            this.workingTimeRefrigeration = _data["workingTimeRefrigeration"];
            this.ma_hasRefillSensor = _data["ma_hasRefillSensor"];
            this.ma_turnOnledRefill = _data["ma_turnOnledRefill"];
            this.ma_minFillOneTime = _data["ma_minFillOneTime"];
            this.ma_maxTankRefill = _data["ma_maxTankRefill"];
            this.workingTimeLedRefill = _data["workingTimeLedRefill"];
            this.ma_commandVending = _data["ma_commandVending"];
            this.ma_commandRefill = _data["ma_commandRefill"];
            this.ma_restartPaymentAfter = _data["ma_restartPaymentAfter"];
            this.ma_activeCashPayment = _data["ma_activeCashPayment"];
            this.ma_activeQrCodePayment = _data["ma_activeQrCodePayment"];
            this.ma_activeRifdPayment = _data["ma_activeRifdPayment"];
            this.ma_activeRefill = _data["ma_activeRefill"];
            this.ma_unitPayment = _data["ma_unitPayment"];
            this.ma_is_debug = _data["ma_is_debug"];
            this.ma_is_active = _data["ma_is_active"];
            this.ma_layout = _data["ma_layout"];
            this.ma_is_locked = _data["ma_is_locked"];
            this.ma_is_deleted = _data["ma_is_deleted"];
            this.ma_cameraUrl = _data["ma_cameraUrl"];
            this.ma_cameraUserName = _data["ma_cameraUserName"];
            this.ma_cameraPassword = _data["ma_cameraPassword"];
            this.ma_hardware_version_name = _data["ma_hardware_version_name"];
            this.ma_hardware_version_code = _data["ma_hardware_version_code"];
            this.ma_created_at = _data["ma_created_at"] ? new Date(_data["ma_created_at"].toString()) : <any>undefined;
            this.ma_updated_at = _data["ma_updated_at"] ? new Date(_data["ma_updated_at"].toString()) : <any>undefined;
            this.ma_last_withdraw_at = _data["ma_last_withdraw_at"] ? new Date(_data["ma_last_withdraw_at"].toString()) : <any>undefined;
            this.ma_delete_at = _data["ma_delete_at"] ? new Date(_data["ma_delete_at"].toString()) : <any>undefined;
            this.ma_total_current_cash = _data["ma_total_current_cash"];
            this.ma_activeMomoPayment = _data["ma_activeMomoPayment"];
            this.ma_activeMIGPayment = _data["ma_activeMIGPayment"];
            this.ma_activeVNPayment = _data["ma_activeVNPayment"];
            this.ma_networkStatus = _data["ma_networkStatus"];
            this.ma_lastOnline_at = _data["ma_lastOnline_at"] ? new Date(_data["ma_lastOnline_at"].toString()) : <any>undefined;
            this.ma_lastBuyCash_at = _data["ma_lastBuyCash_at"] ? new Date(_data["ma_lastBuyCash_at"].toString()) : <any>undefined;
            this.ma_status = _data["ma_status"];
        }
    }

    static fromJS(data: any): MachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["ma_code"] = this.ma_code;
        data["ma_passcode_admin"] = this.ma_passcode_admin;
        data["ma_passcode_replenish"] = this.ma_passcode_replenish;
        data["ma_display_name"] = this.ma_display_name;
        data["ma_mac"] = this.ma_mac;
        data["us_id_login"] = this.us_id_login;
        data["us_id_operator"] = this.us_id_operator;
        data["ma_money_drink"] = this.ma_money_drink;
        data["ma_money_freshdrink"] = this.ma_money_freshdrink;
        data["ma_no_drink"] = this.ma_no_drink;
        data["ma_no_fr_drink"] = this.ma_no_fr_drink;
        data["ma_no_drink_change"] = this.ma_no_drink_change;
        data["ma_no_frdrink_change"] = this.ma_no_frdrink_change;
        data["ma_bg_image"] = this.ma_bg_image;
        data["ma_gps_lat"] = this.ma_gps_lat;
        data["ma_gps_lng"] = this.ma_gps_lng;
        data["ma_mapUrl"] = this.ma_mapUrl;
        data["ma_mapName"] = this.ma_mapName;
        data["ma_isApplyDiscountCode"] = this.ma_isApplyDiscountCode;
        data["ma_timeRepeatBootCheck"] = this.ma_timeRepeatBootCheck;
        data["ma_timeRepeatCheckQRQueue"] = this.ma_timeRepeatCheckQRQueue;
        data["ma_restartMachineAt"] = this.ma_restartMachineAt;
        data["ma_rangeDisplayVending"] = this.ma_rangeDisplayVending;
        data["ma_turnOnGlassHeat"] = this.ma_turnOnGlassHeat;
        data["workingTimeGlassHeat"] = this.workingTimeGlassHeat;
        data["ma_hasDropSensor"] = this.ma_hasDropSensor;
        data["ma_self_inspection_shipment"] = this.ma_self_inspection_shipment;
        data["ma_turnOnLedVending"] = this.ma_turnOnLedVending;
        data["ma_maxTrayVending"] = this.ma_maxTrayVending;
        data["workingTimeLedVending"] = this.workingTimeLedVending;
        data["turnOnRefrigeration"] = this.turnOnRefrigeration;
        data["ma_targetTempRefrigeration"] = this.ma_targetTempRefrigeration;
        data["ma_workingModeRefrigeration"] = this.ma_workingModeRefrigeration;
        data["ma_lockAbnormalRefrigeration"] = this.ma_lockAbnormalRefrigeration;
        data["workingTimeRefrigeration"] = this.workingTimeRefrigeration;
        data["ma_hasRefillSensor"] = this.ma_hasRefillSensor;
        data["ma_turnOnledRefill"] = this.ma_turnOnledRefill;
        data["ma_minFillOneTime"] = this.ma_minFillOneTime;
        data["ma_maxTankRefill"] = this.ma_maxTankRefill;
        data["workingTimeLedRefill"] = this.workingTimeLedRefill;
        data["ma_commandVending"] = this.ma_commandVending;
        data["ma_commandRefill"] = this.ma_commandRefill;
        data["ma_restartPaymentAfter"] = this.ma_restartPaymentAfter;
        data["ma_activeCashPayment"] = this.ma_activeCashPayment;
        data["ma_activeQrCodePayment"] = this.ma_activeQrCodePayment;
        data["ma_activeRifdPayment"] = this.ma_activeRifdPayment;
        data["ma_activeRefill"] = this.ma_activeRefill;
        data["ma_unitPayment"] = this.ma_unitPayment;
        data["ma_is_debug"] = this.ma_is_debug;
        data["ma_is_active"] = this.ma_is_active;
        data["ma_layout"] = this.ma_layout;
        data["ma_is_locked"] = this.ma_is_locked;
        data["ma_is_deleted"] = this.ma_is_deleted;
        data["ma_cameraUrl"] = this.ma_cameraUrl;
        data["ma_cameraUserName"] = this.ma_cameraUserName;
        data["ma_cameraPassword"] = this.ma_cameraPassword;
        data["ma_hardware_version_name"] = this.ma_hardware_version_name;
        data["ma_hardware_version_code"] = this.ma_hardware_version_code;
        data["ma_created_at"] = this.ma_created_at ? this.ma_created_at.toISOString() : <any>undefined;
        data["ma_updated_at"] = this.ma_updated_at ? this.ma_updated_at.toISOString() : <any>undefined;
        data["ma_last_withdraw_at"] = this.ma_last_withdraw_at ? this.ma_last_withdraw_at.toISOString() : <any>undefined;
        data["ma_delete_at"] = this.ma_delete_at ? this.ma_delete_at.toISOString() : <any>undefined;
        data["ma_total_current_cash"] = this.ma_total_current_cash;
        data["ma_activeMomoPayment"] = this.ma_activeMomoPayment;
        data["ma_activeMIGPayment"] = this.ma_activeMIGPayment;
        data["ma_activeVNPayment"] = this.ma_activeVNPayment;
        data["ma_networkStatus"] = this.ma_networkStatus;
        data["ma_lastOnline_at"] = this.ma_lastOnline_at ? this.ma_lastOnline_at.toISOString() : <any>undefined;
        data["ma_lastBuyCash_at"] = this.ma_lastBuyCash_at ? this.ma_lastBuyCash_at.toISOString() : <any>undefined;
        data["ma_status"] = this.ma_status;
        return data;
    }

    clone(): MachineDto {
        const json = this.toJSON();
        let result = new MachineDto();
        result.init(json);
        return result;
    }
}

export interface IMachineDto {
    ma_id: number;
    gr_ma_id: number;
    ma_code: string | undefined;
    ma_passcode_admin: string | undefined;
    ma_passcode_replenish: string | undefined;
    ma_display_name: string | undefined;
    ma_mac: string | undefined;
    us_id_login: number;
    us_id_operator: number;
    ma_money_drink: number;
    ma_money_freshdrink: number;
    ma_no_drink: number;
    ma_no_fr_drink: number;
    ma_no_drink_change: number;
    ma_no_frdrink_change: number;
    ma_bg_image: number;
    ma_gps_lat: string | undefined;
    ma_gps_lng: string | undefined;
    ma_mapUrl: string | undefined;
    ma_mapName: string | undefined;
    ma_isApplyDiscountCode: boolean;
    ma_timeRepeatBootCheck: number;
    ma_timeRepeatCheckQRQueue: number;
    ma_restartMachineAt: string | undefined;
    ma_rangeDisplayVending: number;
    ma_turnOnGlassHeat: boolean;
    workingTimeGlassHeat: string | undefined;
    ma_hasDropSensor: boolean;
    ma_self_inspection_shipment: boolean;
    ma_turnOnLedVending: boolean;
    ma_maxTrayVending: number;
    workingTimeLedVending: string | undefined;
    turnOnRefrigeration: boolean;
    ma_targetTempRefrigeration: number;
    ma_workingModeRefrigeration: string | undefined;
    ma_lockAbnormalRefrigeration: boolean;
    workingTimeRefrigeration: string | undefined;
    ma_hasRefillSensor: boolean;
    ma_turnOnledRefill: boolean;
    ma_minFillOneTime: number;
    ma_maxTankRefill: number;
    workingTimeLedRefill: string | undefined;
    ma_commandVending: EMainBoard;
    ma_commandRefill: EMainBoard;
    ma_restartPaymentAfter: MachineResetPayment;
    ma_activeCashPayment: boolean;
    ma_activeQrCodePayment: boolean;
    ma_activeRifdPayment: boolean;
    ma_activeRefill: boolean;
    ma_unitPayment: string | undefined;
    ma_is_debug: boolean;
    ma_is_active: boolean;
    ma_layout: string | undefined;
    ma_is_locked: boolean;
    ma_is_deleted: boolean;
    ma_cameraUrl: string | undefined;
    ma_cameraUserName: string | undefined;
    ma_cameraPassword: string | undefined;
    ma_hardware_version_name: string | undefined;
    ma_hardware_version_code: number;
    ma_created_at: Date;
    ma_updated_at: Date;
    ma_last_withdraw_at: Date;
    ma_delete_at: Date | undefined;
    ma_total_current_cash: number;
    ma_activeMomoPayment: boolean;
    ma_activeMIGPayment: boolean;
    ma_activeVNPayment: boolean;
    ma_networkStatus: MachineNetworkStatus;
    ma_lastOnline_at: Date | undefined;
    ma_lastBuyCash_at: Date | undefined;
    ma_status: MachineStatus;
}

export class MachineDtoPagedResultDto implements IMachineDtoPagedResultDto {
    items!: MachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineDtoPagedResultDto {
    items: MachineDto[] | undefined;
    totalCount: number;
}

export class MachineInrepositoryAbstractDto implements IMachineInrepositoryAbstractDto {
    ma_id!: number;
    re_id!: number;
    gr_ma_id!: number;
    ma_code!: string | undefined;
    ma_display_name!: string | undefined;
    ma_is_inrepository!: boolean;
    us_id_operator!: number;
    ma_is_deleted!: boolean;

    constructor(data?: IMachineInrepositoryAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.re_id = _data["re_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.ma_code = _data["ma_code"];
            this.ma_display_name = _data["ma_display_name"];
            this.ma_is_inrepository = _data["ma_is_inrepository"];
            this.us_id_operator = _data["us_id_operator"];
            this.ma_is_deleted = _data["ma_is_deleted"];
        }
    }

    static fromJS(data: any): MachineInrepositoryAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineInrepositoryAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["re_id"] = this.re_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["ma_code"] = this.ma_code;
        data["ma_display_name"] = this.ma_display_name;
        data["ma_is_inrepository"] = this.ma_is_inrepository;
        data["us_id_operator"] = this.us_id_operator;
        data["ma_is_deleted"] = this.ma_is_deleted;
        return data;
    }

    clone(): MachineInrepositoryAbstractDto {
        const json = this.toJSON();
        let result = new MachineInrepositoryAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IMachineInrepositoryAbstractDto {
    ma_id: number;
    re_id: number;
    gr_ma_id: number;
    ma_code: string | undefined;
    ma_display_name: string | undefined;
    ma_is_inrepository: boolean;
    us_id_operator: number;
    ma_is_deleted: boolean;
}

export class MachineLocationLogDto implements IMachineLocationLogDto {
    ma_lo_log_id!: number;
    ma_id!: number;
    ma_lo_log_mapName!: string | undefined;
    ma_lo_log_mapUrl!: string | undefined;
    ma_lo_log_created_at!: Date;
    ma_lo_log_from!: Date;
    ma_lo_log_to!: Date | undefined;

    constructor(data?: IMachineLocationLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_lo_log_id = _data["ma_lo_log_id"];
            this.ma_id = _data["ma_id"];
            this.ma_lo_log_mapName = _data["ma_lo_log_mapName"];
            this.ma_lo_log_mapUrl = _data["ma_lo_log_mapUrl"];
            this.ma_lo_log_created_at = _data["ma_lo_log_created_at"] ? new Date(_data["ma_lo_log_created_at"].toString()) : <any>undefined;
            this.ma_lo_log_from = _data["ma_lo_log_from"] ? new Date(_data["ma_lo_log_from"].toString()) : <any>undefined;
            this.ma_lo_log_to = _data["ma_lo_log_to"] ? new Date(_data["ma_lo_log_to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MachineLocationLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineLocationLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_lo_log_id"] = this.ma_lo_log_id;
        data["ma_id"] = this.ma_id;
        data["ma_lo_log_mapName"] = this.ma_lo_log_mapName;
        data["ma_lo_log_mapUrl"] = this.ma_lo_log_mapUrl;
        data["ma_lo_log_created_at"] = this.ma_lo_log_created_at ? this.ma_lo_log_created_at.toISOString() : <any>undefined;
        data["ma_lo_log_from"] = this.ma_lo_log_from ? this.ma_lo_log_from.toISOString() : <any>undefined;
        data["ma_lo_log_to"] = this.ma_lo_log_to ? this.ma_lo_log_to.toISOString() : <any>undefined;
        return data;
    }

    clone(): MachineLocationLogDto {
        const json = this.toJSON();
        let result = new MachineLocationLogDto();
        result.init(json);
        return result;
    }
}

export interface IMachineLocationLogDto {
    ma_lo_log_id: number;
    ma_id: number;
    ma_lo_log_mapName: string | undefined;
    ma_lo_log_mapUrl: string | undefined;
    ma_lo_log_created_at: Date;
    ma_lo_log_from: Date;
    ma_lo_log_to: Date | undefined;
}

export class MachineLocationLogDtoPagedResultDto implements IMachineLocationLogDtoPagedResultDto {
    items!: MachineLocationLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineLocationLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineLocationLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineLocationLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineLocationLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineLocationLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineLocationLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineLocationLogDtoPagedResultDto {
    items: MachineLocationLogDto[] | undefined;
    totalCount: number;
}

export class MachineLogsDto implements IMachineLogsDto {
    ma_lo_id!: number;
    entities_id!: number;
    ma_lo_type!: MachineLogsType;
    ma_lo_data!: string | undefined;
    ma_log_display!: string | undefined;
    ma_lo_created_at!: Date;

    constructor(data?: IMachineLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_lo_id = _data["ma_lo_id"];
            this.entities_id = _data["entities_id"];
            this.ma_lo_type = _data["ma_lo_type"];
            this.ma_lo_data = _data["ma_lo_data"];
            this.ma_log_display = _data["ma_log_display"];
            this.ma_lo_created_at = _data["ma_lo_created_at"] ? new Date(_data["ma_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MachineLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_lo_id"] = this.ma_lo_id;
        data["entities_id"] = this.entities_id;
        data["ma_lo_type"] = this.ma_lo_type;
        data["ma_lo_data"] = this.ma_lo_data;
        data["ma_log_display"] = this.ma_log_display;
        data["ma_lo_created_at"] = this.ma_lo_created_at ? this.ma_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MachineLogsDto {
        const json = this.toJSON();
        let result = new MachineLogsDto();
        result.init(json);
        return result;
    }
}

export interface IMachineLogsDto {
    ma_lo_id: number;
    entities_id: number;
    ma_lo_type: MachineLogsType;
    ma_lo_data: string | undefined;
    ma_log_display: string | undefined;
    ma_lo_created_at: Date;
}

export class MachineLogsDtoPagedResultDto implements IMachineLogsDtoPagedResultDto {
    items!: MachineLogsDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineLogsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineLogsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineLogsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineLogsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineLogsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineLogsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineLogsDtoPagedResultDto {
    items: MachineLogsDto[] | undefined;
    totalCount: number;
}

export enum MachineLogsType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum MachineNetworkStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class MachineOutOfStockQueryDto implements IMachineOutOfStockQueryDto {
    key!: string | undefined;
    ten_nhom!: string | undefined;
    ma_may!: string | undefined;
    ten_may!: string | undefined;
    commandVending!: EMainBoard;
    commandRefill!: EMainBoard;
    ma_id!: number;
    us_id_operator!: number | undefined;
    vending_so_luong_tong!: number[] | undefined;
    vending_so_luong_loi!: number[] | undefined;
    vending_so_luong_sap_het_hang!: number[] | undefined;
    vending_so_luong_het_hang!: number[] | undefined;
    refill_so_luong_loi!: number[] | undefined;
    refill_so_luong_het_hang!: number[] | undefined;
    refill_so_luong_sap_het_hang!: number[] | undefined;
    refill_so_luong_tong!: number[] | undefined;
    ma_gps_lat!: string | undefined;
    ma_gps_lng!: string | undefined;
    ma_mapUrl!: string | undefined;

    constructor(data?: IMachineOutOfStockQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.ten_nhom = _data["ten_nhom"];
            this.ma_may = _data["ma_may"];
            this.ten_may = _data["ten_may"];
            this.commandVending = _data["commandVending"];
            this.commandRefill = _data["commandRefill"];
            this.ma_id = _data["ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            if (Array.isArray(_data["vending_so_luong_tong"])) {
                this.vending_so_luong_tong = [] as any;
                for (let item of _data["vending_so_luong_tong"])
                    this.vending_so_luong_tong!.push(item);
            }
            if (Array.isArray(_data["vending_so_luong_loi"])) {
                this.vending_so_luong_loi = [] as any;
                for (let item of _data["vending_so_luong_loi"])
                    this.vending_so_luong_loi!.push(item);
            }
            if (Array.isArray(_data["vending_so_luong_sap_het_hang"])) {
                this.vending_so_luong_sap_het_hang = [] as any;
                for (let item of _data["vending_so_luong_sap_het_hang"])
                    this.vending_so_luong_sap_het_hang!.push(item);
            }
            if (Array.isArray(_data["vending_so_luong_het_hang"])) {
                this.vending_so_luong_het_hang = [] as any;
                for (let item of _data["vending_so_luong_het_hang"])
                    this.vending_so_luong_het_hang!.push(item);
            }
            if (Array.isArray(_data["refill_so_luong_loi"])) {
                this.refill_so_luong_loi = [] as any;
                for (let item of _data["refill_so_luong_loi"])
                    this.refill_so_luong_loi!.push(item);
            }
            if (Array.isArray(_data["refill_so_luong_het_hang"])) {
                this.refill_so_luong_het_hang = [] as any;
                for (let item of _data["refill_so_luong_het_hang"])
                    this.refill_so_luong_het_hang!.push(item);
            }
            if (Array.isArray(_data["refill_so_luong_sap_het_hang"])) {
                this.refill_so_luong_sap_het_hang = [] as any;
                for (let item of _data["refill_so_luong_sap_het_hang"])
                    this.refill_so_luong_sap_het_hang!.push(item);
            }
            if (Array.isArray(_data["refill_so_luong_tong"])) {
                this.refill_so_luong_tong = [] as any;
                for (let item of _data["refill_so_luong_tong"])
                    this.refill_so_luong_tong!.push(item);
            }
            this.ma_gps_lat = _data["ma_gps_lat"];
            this.ma_gps_lng = _data["ma_gps_lng"];
            this.ma_mapUrl = _data["ma_mapUrl"];
        }
    }

    static fromJS(data: any): MachineOutOfStockQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineOutOfStockQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["ten_nhom"] = this.ten_nhom;
        data["ma_may"] = this.ma_may;
        data["ten_may"] = this.ten_may;
        data["commandVending"] = this.commandVending;
        data["commandRefill"] = this.commandRefill;
        data["ma_id"] = this.ma_id;
        data["us_id_operator"] = this.us_id_operator;
        if (Array.isArray(this.vending_so_luong_tong)) {
            data["vending_so_luong_tong"] = [];
            for (let item of this.vending_so_luong_tong)
                data["vending_so_luong_tong"].push(item);
        }
        if (Array.isArray(this.vending_so_luong_loi)) {
            data["vending_so_luong_loi"] = [];
            for (let item of this.vending_so_luong_loi)
                data["vending_so_luong_loi"].push(item);
        }
        if (Array.isArray(this.vending_so_luong_sap_het_hang)) {
            data["vending_so_luong_sap_het_hang"] = [];
            for (let item of this.vending_so_luong_sap_het_hang)
                data["vending_so_luong_sap_het_hang"].push(item);
        }
        if (Array.isArray(this.vending_so_luong_het_hang)) {
            data["vending_so_luong_het_hang"] = [];
            for (let item of this.vending_so_luong_het_hang)
                data["vending_so_luong_het_hang"].push(item);
        }
        if (Array.isArray(this.refill_so_luong_loi)) {
            data["refill_so_luong_loi"] = [];
            for (let item of this.refill_so_luong_loi)
                data["refill_so_luong_loi"].push(item);
        }
        if (Array.isArray(this.refill_so_luong_het_hang)) {
            data["refill_so_luong_het_hang"] = [];
            for (let item of this.refill_so_luong_het_hang)
                data["refill_so_luong_het_hang"].push(item);
        }
        if (Array.isArray(this.refill_so_luong_sap_het_hang)) {
            data["refill_so_luong_sap_het_hang"] = [];
            for (let item of this.refill_so_luong_sap_het_hang)
                data["refill_so_luong_sap_het_hang"].push(item);
        }
        if (Array.isArray(this.refill_so_luong_tong)) {
            data["refill_so_luong_tong"] = [];
            for (let item of this.refill_so_luong_tong)
                data["refill_so_luong_tong"].push(item);
        }
        data["ma_gps_lat"] = this.ma_gps_lat;
        data["ma_gps_lng"] = this.ma_gps_lng;
        data["ma_mapUrl"] = this.ma_mapUrl;
        return data;
    }

    clone(): MachineOutOfStockQueryDto {
        const json = this.toJSON();
        let result = new MachineOutOfStockQueryDto();
        result.init(json);
        return result;
    }
}

export interface IMachineOutOfStockQueryDto {
    key: string | undefined;
    ten_nhom: string | undefined;
    ma_may: string | undefined;
    ten_may: string | undefined;
    commandVending: EMainBoard;
    commandRefill: EMainBoard;
    ma_id: number;
    us_id_operator: number | undefined;
    vending_so_luong_tong: number[] | undefined;
    vending_so_luong_loi: number[] | undefined;
    vending_so_luong_sap_het_hang: number[] | undefined;
    vending_so_luong_het_hang: number[] | undefined;
    refill_so_luong_loi: number[] | undefined;
    refill_so_luong_het_hang: number[] | undefined;
    refill_so_luong_sap_het_hang: number[] | undefined;
    refill_so_luong_tong: number[] | undefined;
    ma_gps_lat: string | undefined;
    ma_gps_lng: string | undefined;
    ma_mapUrl: string | undefined;
}

export class MachineOutOfStockQueryDtoPagedResultDto implements IMachineOutOfStockQueryDtoPagedResultDto {
    items!: MachineOutOfStockQueryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineOutOfStockQueryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineOutOfStockQueryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineOutOfStockQueryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineOutOfStockQueryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineOutOfStockQueryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineOutOfStockQueryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineOutOfStockQueryDtoPagedResultDto {
    items: MachineOutOfStockQueryDto[] | undefined;
    totalCount: number;
}

export enum MachineResetPayment {
    _0 = 0,
    _15000 = 15000,
    _30000 = 30000,
    _45000 = 45000,
    _60000 = 60000,
    _120000 = 120000,
    _300000 = 300000,
    __1 = -1,
}

export class MachineSoftDto implements IMachineSoftDto {
    ma_so_id!: number;
    ma_so_version_name!: string | undefined;
    ma_so_version_code!: number;
    fi_id!: AttachmentItem;
    ma_so_nr!: number;
    ma_so_created_at!: Date;
    ma_so_updated_at!: Date;
    machineSoftLogs!: MachineSoftLogs[] | undefined;

    constructor(data?: IMachineSoftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_so_id = _data["ma_so_id"];
            this.ma_so_version_name = _data["ma_so_version_name"];
            this.ma_so_version_code = _data["ma_so_version_code"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.ma_so_nr = _data["ma_so_nr"];
            this.ma_so_created_at = _data["ma_so_created_at"] ? new Date(_data["ma_so_created_at"].toString()) : <any>undefined;
            this.ma_so_updated_at = _data["ma_so_updated_at"] ? new Date(_data["ma_so_updated_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["machineSoftLogs"])) {
                this.machineSoftLogs = [] as any;
                for (let item of _data["machineSoftLogs"])
                    this.machineSoftLogs!.push(MachineSoftLogs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MachineSoftDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineSoftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_so_id"] = this.ma_so_id;
        data["ma_so_version_name"] = this.ma_so_version_name;
        data["ma_so_version_code"] = this.ma_so_version_code;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["ma_so_nr"] = this.ma_so_nr;
        data["ma_so_created_at"] = this.ma_so_created_at ? this.ma_so_created_at.toISOString() : <any>undefined;
        data["ma_so_updated_at"] = this.ma_so_updated_at ? this.ma_so_updated_at.toISOString() : <any>undefined;
        if (Array.isArray(this.machineSoftLogs)) {
            data["machineSoftLogs"] = [];
            for (let item of this.machineSoftLogs)
                data["machineSoftLogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): MachineSoftDto {
        const json = this.toJSON();
        let result = new MachineSoftDto();
        result.init(json);
        return result;
    }
}

export interface IMachineSoftDto {
    ma_so_id: number;
    ma_so_version_name: string | undefined;
    ma_so_version_code: number;
    fi_id: AttachmentItem;
    ma_so_nr: number;
    ma_so_created_at: Date;
    ma_so_updated_at: Date;
    machineSoftLogs: MachineSoftLogs[] | undefined;
}

export class MachineSoftDtoPagedResultDto implements IMachineSoftDtoPagedResultDto {
    items!: MachineSoftDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineSoftDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineSoftDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineSoftDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineSoftDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineSoftDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineSoftDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineSoftDtoPagedResultDto {
    items: MachineSoftDto[] | undefined;
    totalCount: number;
}

export class MachineSoftLogs implements IMachineSoftLogs {
    id!: number;
    readonly ma_so_lo_id!: number;
    ma_so_id!: number;
    ma_so_lo_preversion_code!: number;
    ma_so_lo_preversion_name!: string | undefined;
    ma_so_lo_token!: string | undefined;
    ma_so_lo_ma_id!: number;
    ma_so_lo_status!: EMachineSoftLogsStatus;
    ma_so_lo_created_at!: Date;
    ma_so_lo_upgrade_at!: Date | undefined;
    tenantId!: number;

    constructor(data?: IMachineSoftLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).ma_so_lo_id = _data["ma_so_lo_id"];
            this.ma_so_id = _data["ma_so_id"];
            this.ma_so_lo_preversion_code = _data["ma_so_lo_preversion_code"];
            this.ma_so_lo_preversion_name = _data["ma_so_lo_preversion_name"];
            this.ma_so_lo_token = _data["ma_so_lo_token"];
            this.ma_so_lo_ma_id = _data["ma_so_lo_ma_id"];
            this.ma_so_lo_status = _data["ma_so_lo_status"];
            this.ma_so_lo_created_at = _data["ma_so_lo_created_at"] ? new Date(_data["ma_so_lo_created_at"].toString()) : <any>undefined;
            this.ma_so_lo_upgrade_at = _data["ma_so_lo_upgrade_at"] ? new Date(_data["ma_so_lo_upgrade_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): MachineSoftLogs {
        data = typeof data === 'object' ? data : {};
        let result = new MachineSoftLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ma_so_lo_id"] = this.ma_so_lo_id;
        data["ma_so_id"] = this.ma_so_id;
        data["ma_so_lo_preversion_code"] = this.ma_so_lo_preversion_code;
        data["ma_so_lo_preversion_name"] = this.ma_so_lo_preversion_name;
        data["ma_so_lo_token"] = this.ma_so_lo_token;
        data["ma_so_lo_ma_id"] = this.ma_so_lo_ma_id;
        data["ma_so_lo_status"] = this.ma_so_lo_status;
        data["ma_so_lo_created_at"] = this.ma_so_lo_created_at ? this.ma_so_lo_created_at.toISOString() : <any>undefined;
        data["ma_so_lo_upgrade_at"] = this.ma_so_lo_upgrade_at ? this.ma_so_lo_upgrade_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): MachineSoftLogs {
        const json = this.toJSON();
        let result = new MachineSoftLogs();
        result.init(json);
        return result;
    }
}

export interface IMachineSoftLogs {
    id: number;
    ma_so_lo_id: number;
    ma_so_id: number;
    ma_so_lo_preversion_code: number;
    ma_so_lo_preversion_name: string | undefined;
    ma_so_lo_token: string | undefined;
    ma_so_lo_ma_id: number;
    ma_so_lo_status: EMachineSoftLogsStatus;
    ma_so_lo_created_at: Date;
    ma_so_lo_upgrade_at: Date | undefined;
    tenantId: number;
}

export class MachineSoftLogsDto implements IMachineSoftLogsDto {
    ma_so_lo_id!: number;
    ma_so_id!: number;
    ma_so_lo_preversion_code!: number;
    ma_so_lo_preversion_name!: string | undefined;
    ma_so_lo_token!: string | undefined;
    ma_so_lo_ma_id!: number;
    ma_so_lo_status!: EMachineSoftLogsStatus;
    ma_so_lo_created_at!: Date;
    ma_so_lo_upgrade_at!: Date | undefined;

    constructor(data?: IMachineSoftLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_so_lo_id = _data["ma_so_lo_id"];
            this.ma_so_id = _data["ma_so_id"];
            this.ma_so_lo_preversion_code = _data["ma_so_lo_preversion_code"];
            this.ma_so_lo_preversion_name = _data["ma_so_lo_preversion_name"];
            this.ma_so_lo_token = _data["ma_so_lo_token"];
            this.ma_so_lo_ma_id = _data["ma_so_lo_ma_id"];
            this.ma_so_lo_status = _data["ma_so_lo_status"];
            this.ma_so_lo_created_at = _data["ma_so_lo_created_at"] ? new Date(_data["ma_so_lo_created_at"].toString()) : <any>undefined;
            this.ma_so_lo_upgrade_at = _data["ma_so_lo_upgrade_at"] ? new Date(_data["ma_so_lo_upgrade_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MachineSoftLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineSoftLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_so_lo_id"] = this.ma_so_lo_id;
        data["ma_so_id"] = this.ma_so_id;
        data["ma_so_lo_preversion_code"] = this.ma_so_lo_preversion_code;
        data["ma_so_lo_preversion_name"] = this.ma_so_lo_preversion_name;
        data["ma_so_lo_token"] = this.ma_so_lo_token;
        data["ma_so_lo_ma_id"] = this.ma_so_lo_ma_id;
        data["ma_so_lo_status"] = this.ma_so_lo_status;
        data["ma_so_lo_created_at"] = this.ma_so_lo_created_at ? this.ma_so_lo_created_at.toISOString() : <any>undefined;
        data["ma_so_lo_upgrade_at"] = this.ma_so_lo_upgrade_at ? this.ma_so_lo_upgrade_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MachineSoftLogsDto {
        const json = this.toJSON();
        let result = new MachineSoftLogsDto();
        result.init(json);
        return result;
    }
}

export interface IMachineSoftLogsDto {
    ma_so_lo_id: number;
    ma_so_id: number;
    ma_so_lo_preversion_code: number;
    ma_so_lo_preversion_name: string | undefined;
    ma_so_lo_token: string | undefined;
    ma_so_lo_ma_id: number;
    ma_so_lo_status: EMachineSoftLogsStatus;
    ma_so_lo_created_at: Date;
    ma_so_lo_upgrade_at: Date | undefined;
}

export class MachineSoftLogsDtoPagedResultDto implements IMachineSoftLogsDtoPagedResultDto {
    items!: MachineSoftLogsDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMachineSoftLogsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MachineSoftLogsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MachineSoftLogsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MachineSoftLogsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MachineSoftLogsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MachineSoftLogsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMachineSoftLogsDtoPagedResultDto {
    items: MachineSoftLogsDto[] | undefined;
    totalCount: number;
}

export enum MachineStatus {
    _0 = 0,
    _1 = 1,
}

export class MemberInfo implements IMemberInfo {
    memberType!: MemberTypes;
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): MemberInfo {
        const json = this.toJSON();
        let result = new MemberInfo();
        result.init(json);
        return result;
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export class MethodBase implements IMethodBase {
    memberType!: MemberTypes;
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        return data;
    }

    clone(): MethodBase {
        const json = this.toJSON();
        let result = new MethodBase();
        result.init(json);
        return result;
    }
}

export interface IMethodBase {
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export class MethodInfo implements IMethodInfo {
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    memberType!: MemberTypes;
    returnParameter!: ParameterInfo;
    returnType!: Type;
    returnTypeCustomAttributes!: ICustomAttributeProvider;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        return data;
    }

    clone(): MethodInfo {
        const json = this.toJSON();
        let result = new MethodInfo();
        result.init(json);
        return result;
    }
}

export interface IMethodInfo {
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: Type;
    returnTypeCustomAttributes: ICustomAttributeProvider;
}

export class MoMoInformationPayment implements IMoMoInformationPayment {
    partnerCode!: string | undefined;
    accessKey!: string | undefined;
    secretKey!: string | undefined;

    constructor(data?: IMoMoInformationPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partnerCode = _data["partnerCode"];
            this.accessKey = _data["accessKey"];
            this.secretKey = _data["secretKey"];
        }
    }

    static fromJS(data: any): MoMoInformationPayment {
        data = typeof data === 'object' ? data : {};
        let result = new MoMoInformationPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerCode"] = this.partnerCode;
        data["accessKey"] = this.accessKey;
        data["secretKey"] = this.secretKey;
        return data;
    }

    clone(): MoMoInformationPayment {
        const json = this.toJSON();
        let result = new MoMoInformationPayment();
        result.init(json);
        return result;
    }
}

export interface IMoMoInformationPayment {
    partnerCode: string | undefined;
    accessKey: string | undefined;
    secretKey: string | undefined;
}

export class Module implements IModule {
    assembly!: Assembly;
    readonly fullyQualifiedName!: string | undefined;
    readonly name!: string | undefined;
    readonly mdStreamVersion!: number;
    readonly moduleVersionId!: string;
    readonly scopeName!: string | undefined;
    moduleHandle!: ModuleHandle;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): Module {
        const json = this.toJSON();
        let result = new Module();
        result.init(json);
        return result;
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string | undefined;
    name: string | undefined;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion!: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }

    clone(): ModuleHandle {
        const json = this.toJSON();
        let result = new ModuleHandle();
        result.init(json);
        return result;
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
    items!: NameValueDto[] | undefined;
    totalCount!: number;

    constructor(data?: INameValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NameValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NameValueDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NameValueDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDtoPagedResultDto {
    items: NameValueDto[] | undefined;
    totalCount: number;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Oid implements IOid {
    value!: string | undefined;
    friendlyName!: string | undefined;

    constructor(data?: IOid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.friendlyName = _data["friendlyName"];
        }
    }

    static fromJS(data: any): Oid {
        data = typeof data === 'object' ? data : {};
        let result = new Oid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["friendlyName"] = this.friendlyName;
        return data;
    }

    clone(): Oid {
        const json = this.toJSON();
        let result = new Oid();
        result.init(json);
        return result;
    }
}

export interface IOid {
    value: string | undefined;
    friendlyName: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    lastModificationTime!: Date | undefined;
    lastModifierUserId!: number | undefined;
    parentId!: number | undefined;
    parentName!: string | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.parentId = _data["parentId"];
            this.parentName = _data["parentName"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        return data;
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    parentId: number | undefined;
    parentName: string | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrganizationUnitDtoListResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    id!: number;
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: Date;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? new Date(_data["addedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    id: number;
    displayName: string | undefined;
    name: string | undefined;
    addedTime: Date;
}

export class OrganizationUnitRoleListDtoPagedResultDto implements IOrganizationUnitRoleListDtoPagedResultDto {
    items!: OrganizationUnitRoleListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOrganizationUnitRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrganizationUnitRoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDtoPagedResultDto {
    items: OrganizationUnitRoleListDto[] | undefined;
    totalCount: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: Date;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? new Date(_data["addedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: Date;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    items!: OrganizationUnitUserListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrganizationUnitUserListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    items: OrganizationUnitUserListDto[] | undefined;
    totalCount: number;
}

export class PageResultNotificationDto implements IPageResultNotificationDto {
    items!: CustomUserNotification[] | undefined;
    totalCount!: number;
    numberOfUnreadMessage!: number;

    constructor(data?: IPageResultNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomUserNotification.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.numberOfUnreadMessage = _data["numberOfUnreadMessage"];
        }
    }

    static fromJS(data: any): PageResultNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["numberOfUnreadMessage"] = this.numberOfUnreadMessage;
        return data;
    }

    clone(): PageResultNotificationDto {
        const json = this.toJSON();
        let result = new PageResultNotificationDto();
        result.init(json);
        return result;
    }
}

export interface IPageResultNotificationDto {
    items: CustomUserNotification[] | undefined;
    totalCount: number;
    numberOfUnreadMessage: number;
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes!: ParameterAttributes;
    member!: MemberInfo;
    readonly name!: string | undefined;
    parameterType!: Type;
    readonly position!: number;
    readonly isIn!: boolean;
    readonly isLcid!: boolean;
    readonly isOptional!: boolean;
    readonly isOut!: boolean;
    readonly isRetval!: boolean;
    readonly defaultValue!: any | undefined;
    readonly rawDefaultValue!: any | undefined;
    readonly hasDefaultValue!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): ParameterInfo {
        const json = this.toJSON();
        let result = new ParameterInfo();
        result.init(json);
        return result;
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | undefined;
    parameterType: Type;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | undefined;
    rawDefaultValue: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    readonly allowedMinimumLength!: number;
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).allowedMinimumLength = _data["allowedMinimumLength"];
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedMinimumLength"] = this.allowedMinimumLength;
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    allowedMinimumLength: number;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PathString implements IPathString {
    value!: string | undefined;
    readonly hasValue!: boolean;

    constructor(data?: IPathString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).hasValue = _data["hasValue"];
        }
    }

    static fromJS(data: any): PathString {
        data = typeof data === 'object' ? data : {};
        let result = new PathString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["hasValue"] = this.hasValue;
        return data;
    }

    clone(): PathString {
        const json = this.toJSON();
        let result = new PathString();
        result.init(json);
        return result;
    }
}

export interface IPathString {
    value: string | undefined;
    hasValue: boolean;
}

export class PaySupplierInput implements IPaySupplierInput {
    su_id!: number;
    money!: number;
    note!: string | undefined;
    paymentMethod!: BillMethod;

    constructor(data?: IPaySupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.money = _data["money"];
            this.note = _data["note"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): PaySupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new PaySupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["money"] = this.money;
        data["note"] = this.note;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }

    clone(): PaySupplierInput {
        const json = this.toJSON();
        let result = new PaySupplierInput();
        result.init(json);
        return result;
    }
}

export interface IPaySupplierInput {
    su_id: number;
    money: number;
    note: string | undefined;
    paymentMethod: BillMethod;
}

export class PaymentBank implements IPaymentBank {
    id!: number;
    readonly pa_ba_id!: number;
    pa_ba_bankId!: EBank;
    pa_ba_tranId!: string | undefined;
    bi_code!: string | undefined;
    pa_ba_tranHeader!: string | undefined;
    pa_ba_tranRespond!: string | undefined;
    pa_ba_error!: string | undefined;
    ma_id!: number;
    us_id!: number;
    pa_ba_money!: number;
    pa_ba_for!: EPaymentFor;
    pa_ba_status!: EPaymentStatus;
    pa_ba_is_reconcile!: boolean;
    fi_id!: number;
    pa_ba_reconcile_at!: Date | undefined;
    pa_ba_created_at!: Date;
    pa_ba_payment_at!: Date | undefined;
    tenantId!: number;

    constructor(data?: IPaymentBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).pa_ba_id = _data["pa_ba_id"];
            this.pa_ba_bankId = _data["pa_ba_bankId"];
            this.pa_ba_tranId = _data["pa_ba_tranId"];
            this.bi_code = _data["bi_code"];
            this.pa_ba_tranHeader = _data["pa_ba_tranHeader"];
            this.pa_ba_tranRespond = _data["pa_ba_tranRespond"];
            this.pa_ba_error = _data["pa_ba_error"];
            this.ma_id = _data["ma_id"];
            this.us_id = _data["us_id"];
            this.pa_ba_money = _data["pa_ba_money"];
            this.pa_ba_for = _data["pa_ba_for"];
            this.pa_ba_status = _data["pa_ba_status"];
            this.pa_ba_is_reconcile = _data["pa_ba_is_reconcile"];
            this.fi_id = _data["fi_id"];
            this.pa_ba_reconcile_at = _data["pa_ba_reconcile_at"] ? new Date(_data["pa_ba_reconcile_at"].toString()) : <any>undefined;
            this.pa_ba_created_at = _data["pa_ba_created_at"] ? new Date(_data["pa_ba_created_at"].toString()) : <any>undefined;
            this.pa_ba_payment_at = _data["pa_ba_payment_at"] ? new Date(_data["pa_ba_payment_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): PaymentBank {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentBank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pa_ba_id"] = this.pa_ba_id;
        data["pa_ba_bankId"] = this.pa_ba_bankId;
        data["pa_ba_tranId"] = this.pa_ba_tranId;
        data["bi_code"] = this.bi_code;
        data["pa_ba_tranHeader"] = this.pa_ba_tranHeader;
        data["pa_ba_tranRespond"] = this.pa_ba_tranRespond;
        data["pa_ba_error"] = this.pa_ba_error;
        data["ma_id"] = this.ma_id;
        data["us_id"] = this.us_id;
        data["pa_ba_money"] = this.pa_ba_money;
        data["pa_ba_for"] = this.pa_ba_for;
        data["pa_ba_status"] = this.pa_ba_status;
        data["pa_ba_is_reconcile"] = this.pa_ba_is_reconcile;
        data["fi_id"] = this.fi_id;
        data["pa_ba_reconcile_at"] = this.pa_ba_reconcile_at ? this.pa_ba_reconcile_at.toISOString() : <any>undefined;
        data["pa_ba_created_at"] = this.pa_ba_created_at ? this.pa_ba_created_at.toISOString() : <any>undefined;
        data["pa_ba_payment_at"] = this.pa_ba_payment_at ? this.pa_ba_payment_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): PaymentBank {
        const json = this.toJSON();
        let result = new PaymentBank();
        result.init(json);
        return result;
    }
}

export interface IPaymentBank {
    id: number;
    pa_ba_id: number;
    pa_ba_bankId: EBank;
    pa_ba_tranId: string | undefined;
    bi_code: string | undefined;
    pa_ba_tranHeader: string | undefined;
    pa_ba_tranRespond: string | undefined;
    pa_ba_error: string | undefined;
    ma_id: number;
    us_id: number;
    pa_ba_money: number;
    pa_ba_for: EPaymentFor;
    pa_ba_status: EPaymentStatus;
    pa_ba_is_reconcile: boolean;
    fi_id: number;
    pa_ba_reconcile_at: Date | undefined;
    pa_ba_created_at: Date;
    pa_ba_payment_at: Date | undefined;
    tenantId: number;
}

export class PaymentBankDto implements IPaymentBankDto {
    pa_ba_id!: number;
    pa_ba_bankId!: EBank;
    pa_ba_tranId!: string | undefined;
    bi_code!: string | undefined;
    ma_id!: number;
    billing!: BillingDto;
    us_id!: number;
    pa_ba_money!: number;
    pa_ba_status!: EPaymentStatus;
    pa_ba_tranHeader!: string | undefined;
    pa_ba_tranRespond!: string | undefined;
    pa_ba_error!: string | undefined;
    pa_ba_is_reconcile!: boolean;
    fi_id!: number;
    pa_ba_reconcile_at!: Date | undefined;
    pa_ba_created_at!: Date;
    pa_ba_payment_at!: Date | undefined;

    constructor(data?: IPaymentBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pa_ba_id = _data["pa_ba_id"];
            this.pa_ba_bankId = _data["pa_ba_bankId"];
            this.pa_ba_tranId = _data["pa_ba_tranId"];
            this.bi_code = _data["bi_code"];
            this.ma_id = _data["ma_id"];
            this.billing = _data["billing"] ? BillingDto.fromJS(_data["billing"]) : <any>undefined;
            this.us_id = _data["us_id"];
            this.pa_ba_money = _data["pa_ba_money"];
            this.pa_ba_status = _data["pa_ba_status"];
            this.pa_ba_tranHeader = _data["pa_ba_tranHeader"];
            this.pa_ba_tranRespond = _data["pa_ba_tranRespond"];
            this.pa_ba_error = _data["pa_ba_error"];
            this.pa_ba_is_reconcile = _data["pa_ba_is_reconcile"];
            this.fi_id = _data["fi_id"];
            this.pa_ba_reconcile_at = _data["pa_ba_reconcile_at"] ? new Date(_data["pa_ba_reconcile_at"].toString()) : <any>undefined;
            this.pa_ba_created_at = _data["pa_ba_created_at"] ? new Date(_data["pa_ba_created_at"].toString()) : <any>undefined;
            this.pa_ba_payment_at = _data["pa_ba_payment_at"] ? new Date(_data["pa_ba_payment_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pa_ba_id"] = this.pa_ba_id;
        data["pa_ba_bankId"] = this.pa_ba_bankId;
        data["pa_ba_tranId"] = this.pa_ba_tranId;
        data["bi_code"] = this.bi_code;
        data["ma_id"] = this.ma_id;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["us_id"] = this.us_id;
        data["pa_ba_money"] = this.pa_ba_money;
        data["pa_ba_status"] = this.pa_ba_status;
        data["pa_ba_tranHeader"] = this.pa_ba_tranHeader;
        data["pa_ba_tranRespond"] = this.pa_ba_tranRespond;
        data["pa_ba_error"] = this.pa_ba_error;
        data["pa_ba_is_reconcile"] = this.pa_ba_is_reconcile;
        data["fi_id"] = this.fi_id;
        data["pa_ba_reconcile_at"] = this.pa_ba_reconcile_at ? this.pa_ba_reconcile_at.toISOString() : <any>undefined;
        data["pa_ba_created_at"] = this.pa_ba_created_at ? this.pa_ba_created_at.toISOString() : <any>undefined;
        data["pa_ba_payment_at"] = this.pa_ba_payment_at ? this.pa_ba_payment_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PaymentBankDto {
        const json = this.toJSON();
        let result = new PaymentBankDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentBankDto {
    pa_ba_id: number;
    pa_ba_bankId: EBank;
    pa_ba_tranId: string | undefined;
    bi_code: string | undefined;
    ma_id: number;
    billing: BillingDto;
    us_id: number;
    pa_ba_money: number;
    pa_ba_status: EPaymentStatus;
    pa_ba_tranHeader: string | undefined;
    pa_ba_tranRespond: string | undefined;
    pa_ba_error: string | undefined;
    pa_ba_is_reconcile: boolean;
    fi_id: number;
    pa_ba_reconcile_at: Date | undefined;
    pa_ba_created_at: Date;
    pa_ba_payment_at: Date | undefined;
}

export class PaymentBankDtoPagedResultDto implements IPaymentBankDtoPagedResultDto {
    items!: PaymentBankDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPaymentBankDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentBankDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PaymentBankDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentBankDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PaymentBankDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentBankDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentBankDtoPagedResultDto {
    items: PaymentBankDto[] | undefined;
    totalCount: number;
}

export class PermissionDto implements IPermissionDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items!: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class PingToServerInput implements IPingToServerInput {
    deviceID!: string | undefined;
    lat!: number;
    lng!: number;

    constructor(data?: IPingToServerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceID = _data["deviceID"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
        }
    }

    static fromJS(data: any): PingToServerInput {
        data = typeof data === 'object' ? data : {};
        let result = new PingToServerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceID"] = this.deviceID;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        return data;
    }

    clone(): PingToServerInput {
        const json = this.toJSON();
        let result = new PingToServerInput();
        result.init(json);
        return result;
    }
}

export interface IPingToServerInput {
    deviceID: string | undefined;
    lat: number;
    lng: number;
}

export class PipeReader implements IPipeReader {

    constructor(data?: IPipeReader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PipeReader {
        data = typeof data === 'object' ? data : {};
        let result = new PipeReader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): PipeReader {
        const json = this.toJSON();
        let result = new PipeReader();
        result.init(json);
        return result;
    }
}

export interface IPipeReader {
}

export class PipeWriter implements IPipeWriter {
    readonly canGetUnflushedBytes!: boolean;
    readonly unflushedBytes!: number;

    constructor(data?: IPipeWriter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canGetUnflushedBytes = _data["canGetUnflushedBytes"];
            (<any>this).unflushedBytes = _data["unflushedBytes"];
        }
    }

    static fromJS(data: any): PipeWriter {
        data = typeof data === 'object' ? data : {};
        let result = new PipeWriter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canGetUnflushedBytes"] = this.canGetUnflushedBytes;
        data["unflushedBytes"] = this.unflushedBytes;
        return data;
    }

    clone(): PipeWriter {
        const json = this.toJSON();
        let result = new PipeWriter();
        result.init(json);
        return result;
    }
}

export interface IPipeWriter {
    canGetUnflushedBytes: boolean;
    unflushedBytes: number;
}

export class Product implements IProduct {
    id!: number;
    readonly pr_id!: number;
    pr_name!: string | undefined;
    pr_code!: string | undefined;
    pr_price!: number;
    pr_type!: EDrinkType;
    pr_unit!: string | undefined;
    us_id_create!: number;
    pr_desc!: string | undefined;
    pr_is_active!: boolean;
    pr_is_deleted!: boolean;
    pr_created_at!: Date;
    tenantId!: number;
    fi_id!: string | undefined;
    listImportingDetails!: ImportingDetail[] | undefined;
    listBillingProduct!: BillingProduct[] | undefined;
    repositoryDetails!: RepositoryDetails[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.pr_code = _data["pr_code"];
            this.pr_price = _data["pr_price"];
            this.pr_type = _data["pr_type"];
            this.pr_unit = _data["pr_unit"];
            this.us_id_create = _data["us_id_create"];
            this.pr_desc = _data["pr_desc"];
            this.pr_is_active = _data["pr_is_active"];
            this.pr_is_deleted = _data["pr_is_deleted"];
            this.pr_created_at = _data["pr_created_at"] ? new Date(_data["pr_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.fi_id = _data["fi_id"];
            if (Array.isArray(_data["listImportingDetails"])) {
                this.listImportingDetails = [] as any;
                for (let item of _data["listImportingDetails"])
                    this.listImportingDetails!.push(ImportingDetail.fromJS(item));
            }
            if (Array.isArray(_data["listBillingProduct"])) {
                this.listBillingProduct = [] as any;
                for (let item of _data["listBillingProduct"])
                    this.listBillingProduct!.push(BillingProduct.fromJS(item));
            }
            if (Array.isArray(_data["repositoryDetails"])) {
                this.repositoryDetails = [] as any;
                for (let item of _data["repositoryDetails"])
                    this.repositoryDetails!.push(RepositoryDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["pr_code"] = this.pr_code;
        data["pr_price"] = this.pr_price;
        data["pr_type"] = this.pr_type;
        data["pr_unit"] = this.pr_unit;
        data["us_id_create"] = this.us_id_create;
        data["pr_desc"] = this.pr_desc;
        data["pr_is_active"] = this.pr_is_active;
        data["pr_is_deleted"] = this.pr_is_deleted;
        data["pr_created_at"] = this.pr_created_at ? this.pr_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["fi_id"] = this.fi_id;
        if (Array.isArray(this.listImportingDetails)) {
            data["listImportingDetails"] = [];
            for (let item of this.listImportingDetails)
                data["listImportingDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.listBillingProduct)) {
            data["listBillingProduct"] = [];
            for (let item of this.listBillingProduct)
                data["listBillingProduct"].push(item.toJSON());
        }
        if (Array.isArray(this.repositoryDetails)) {
            data["repositoryDetails"] = [];
            for (let item of this.repositoryDetails)
                data["repositoryDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): Product {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export interface IProduct {
    id: number;
    pr_id: number;
    pr_name: string | undefined;
    pr_code: string | undefined;
    pr_price: number;
    pr_type: EDrinkType;
    pr_unit: string | undefined;
    us_id_create: number;
    pr_desc: string | undefined;
    pr_is_active: boolean;
    pr_is_deleted: boolean;
    pr_created_at: Date;
    tenantId: number;
    fi_id: string | undefined;
    listImportingDetails: ImportingDetail[] | undefined;
    listBillingProduct: BillingProduct[] | undefined;
    repositoryDetails: RepositoryDetails[] | undefined;
}

export class ProductAbstractDto implements IProductAbstractDto {
    pr_id!: number;
    pr_name!: string | undefined;
    pr_unit!: string | undefined;
    pr_code!: string | undefined;
    pr_price!: number;
    pr_type!: EDrinkType;
    pr_is_deleted!: boolean;
    fi_id!: AttachmentItem;

    constructor(data?: IProductAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.pr_unit = _data["pr_unit"];
            this.pr_code = _data["pr_code"];
            this.pr_price = _data["pr_price"];
            this.pr_type = _data["pr_type"];
            this.pr_is_deleted = _data["pr_is_deleted"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["pr_unit"] = this.pr_unit;
        data["pr_code"] = this.pr_code;
        data["pr_price"] = this.pr_price;
        data["pr_type"] = this.pr_type;
        data["pr_is_deleted"] = this.pr_is_deleted;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductAbstractDto {
        const json = this.toJSON();
        let result = new ProductAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IProductAbstractDto {
    pr_id: number;
    pr_name: string | undefined;
    pr_unit: string | undefined;
    pr_code: string | undefined;
    pr_price: number;
    pr_type: EDrinkType;
    pr_is_deleted: boolean;
    fi_id: AttachmentItem;
}

export class ProductAbstractDtoPagedResultDto implements IProductAbstractDtoPagedResultDto {
    items!: ProductAbstractDto[] | undefined;
    totalCount!: number;

    constructor(data?: IProductAbstractDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAbstractDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductAbstractDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAbstractDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductAbstractDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductAbstractDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductAbstractDtoPagedResultDto {
    items: ProductAbstractDto[] | undefined;
    totalCount: number;
}

export class ProductDailyMonitoringDto implements IProductDailyMonitoringDto {
    pr_name!: string | undefined;
    pr_price!: number;
    pr_is_active!: boolean;
    pr_quantityInMachine!: number;
    pr_quantityInRepository!: number;
    pr_slot_id!: number;
    ma_de_max!: number;

    constructor(data?: IProductDailyMonitoringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_name = _data["pr_name"];
            this.pr_price = _data["pr_price"];
            this.pr_is_active = _data["pr_is_active"];
            this.pr_quantityInMachine = _data["pr_quantityInMachine"];
            this.pr_quantityInRepository = _data["pr_quantityInRepository"];
            this.pr_slot_id = _data["pr_slot_id"];
            this.ma_de_max = _data["ma_de_max"];
        }
    }

    static fromJS(data: any): ProductDailyMonitoringDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDailyMonitoringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_name"] = this.pr_name;
        data["pr_price"] = this.pr_price;
        data["pr_is_active"] = this.pr_is_active;
        data["pr_quantityInMachine"] = this.pr_quantityInMachine;
        data["pr_quantityInRepository"] = this.pr_quantityInRepository;
        data["pr_slot_id"] = this.pr_slot_id;
        data["ma_de_max"] = this.ma_de_max;
        return data;
    }

    clone(): ProductDailyMonitoringDto {
        const json = this.toJSON();
        let result = new ProductDailyMonitoringDto();
        result.init(json);
        return result;
    }
}

export interface IProductDailyMonitoringDto {
    pr_name: string | undefined;
    pr_price: number;
    pr_is_active: boolean;
    pr_quantityInMachine: number;
    pr_quantityInRepository: number;
    pr_slot_id: number;
    ma_de_max: number;
}

export class ProductDailyMonitoringDtoPagedResultDto implements IProductDailyMonitoringDtoPagedResultDto {
    items!: ProductDailyMonitoringDto[] | undefined;
    totalCount!: number;

    constructor(data?: IProductDailyMonitoringDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDailyMonitoringDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductDailyMonitoringDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDailyMonitoringDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductDailyMonitoringDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductDailyMonitoringDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductDailyMonitoringDtoPagedResultDto {
    items: ProductDailyMonitoringDto[] | undefined;
    totalCount: number;
}

export class ProductDto implements IProductDto {
    pr_id!: number;
    pr_name!: string | undefined;
    pr_code!: string | undefined;
    pr_price!: number;
    pr_type!: EDrinkType;
    pr_unit!: string | undefined;
    su_id!: number;
    us_id_create!: number;
    pr_is_active!: boolean;
    pr_is_deleted!: boolean;
    pr_desc!: string | undefined;
    fi_id!: AttachmentItem;
    pr_created_at!: Date;
    listImportingDetails!: ImportingDetailAbstractDto[] | undefined;
    listBillingProduct!: BillingProduct[] | undefined;
    repositoryDetailDto!: RepositoryDetailDto;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.pr_code = _data["pr_code"];
            this.pr_price = _data["pr_price"];
            this.pr_type = _data["pr_type"];
            this.pr_unit = _data["pr_unit"];
            this.su_id = _data["su_id"];
            this.us_id_create = _data["us_id_create"];
            this.pr_is_active = _data["pr_is_active"];
            this.pr_is_deleted = _data["pr_is_deleted"];
            this.pr_desc = _data["pr_desc"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.pr_created_at = _data["pr_created_at"] ? new Date(_data["pr_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listImportingDetails"])) {
                this.listImportingDetails = [] as any;
                for (let item of _data["listImportingDetails"])
                    this.listImportingDetails!.push(ImportingDetailAbstractDto.fromJS(item));
            }
            if (Array.isArray(_data["listBillingProduct"])) {
                this.listBillingProduct = [] as any;
                for (let item of _data["listBillingProduct"])
                    this.listBillingProduct!.push(BillingProduct.fromJS(item));
            }
            this.repositoryDetailDto = _data["repositoryDetailDto"] ? RepositoryDetailDto.fromJS(_data["repositoryDetailDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["pr_code"] = this.pr_code;
        data["pr_price"] = this.pr_price;
        data["pr_type"] = this.pr_type;
        data["pr_unit"] = this.pr_unit;
        data["su_id"] = this.su_id;
        data["us_id_create"] = this.us_id_create;
        data["pr_is_active"] = this.pr_is_active;
        data["pr_is_deleted"] = this.pr_is_deleted;
        data["pr_desc"] = this.pr_desc;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["pr_created_at"] = this.pr_created_at ? this.pr_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listImportingDetails)) {
            data["listImportingDetails"] = [];
            for (let item of this.listImportingDetails)
                data["listImportingDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.listBillingProduct)) {
            data["listBillingProduct"] = [];
            for (let item of this.listBillingProduct)
                data["listBillingProduct"].push(item.toJSON());
        }
        data["repositoryDetailDto"] = this.repositoryDetailDto ? this.repositoryDetailDto.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    pr_id: number;
    pr_name: string | undefined;
    pr_code: string | undefined;
    pr_price: number;
    pr_type: EDrinkType;
    pr_unit: string | undefined;
    su_id: number;
    us_id_create: number;
    pr_is_active: boolean;
    pr_is_deleted: boolean;
    pr_desc: string | undefined;
    fi_id: AttachmentItem;
    pr_created_at: Date;
    listImportingDetails: ImportingDetailAbstractDto[] | undefined;
    listBillingProduct: BillingProduct[] | undefined;
    repositoryDetailDto: RepositoryDetailDto;
}

export class ProductDtoListResultDto implements IProductDtoListResultDto {
    items!: ProductDto[] | undefined;

    constructor(data?: IProductDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductDtoListResultDto {
        const json = this.toJSON();
        let result = new ProductDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductDtoListResultDto {
    items: ProductDto[] | undefined;
}

export class ProductDtoPagedResultDto implements IProductDtoPagedResultDto {
    items!: ProductDto[] | undefined;
    totalCount!: number;

    constructor(data?: IProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductDtoPagedResultDto {
    items: ProductDto[] | undefined;
    totalCount: number;
}

export class ProductExportDto implements IProductExportDto {
    pr_ex_no!: number;
    pr_id!: number;
    pr_name!: string | undefined;
    pr_ex_quantity!: number;
    pr_ex_unit_quydoi!: string | undefined;
    pr_ex_quantityBeforeExport!: number;

    constructor(data?: IProductExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_ex_no = _data["pr_ex_no"];
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.pr_ex_quantity = _data["pr_ex_quantity"];
            this.pr_ex_unit_quydoi = _data["pr_ex_unit_quydoi"];
            this.pr_ex_quantityBeforeExport = _data["pr_ex_quantityBeforeExport"];
        }
    }

    static fromJS(data: any): ProductExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_ex_no"] = this.pr_ex_no;
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["pr_ex_quantity"] = this.pr_ex_quantity;
        data["pr_ex_unit_quydoi"] = this.pr_ex_unit_quydoi;
        data["pr_ex_quantityBeforeExport"] = this.pr_ex_quantityBeforeExport;
        return data;
    }

    clone(): ProductExportDto {
        const json = this.toJSON();
        let result = new ProductExportDto();
        result.init(json);
        return result;
    }
}

export interface IProductExportDto {
    pr_ex_no: number;
    pr_id: number;
    pr_name: string | undefined;
    pr_ex_quantity: number;
    pr_ex_unit_quydoi: string | undefined;
    pr_ex_quantityBeforeExport: number;
}

export class ProductHandoverInput implements IProductHandoverInput {
    pr_id!: number;
    pr_quantity!: number;

    constructor(data?: IProductHandoverInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_id = _data["pr_id"];
            this.pr_quantity = _data["pr_quantity"];
        }
    }

    static fromJS(data: any): ProductHandoverInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProductHandoverInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_id"] = this.pr_id;
        data["pr_quantity"] = this.pr_quantity;
        return data;
    }

    clone(): ProductHandoverInput {
        const json = this.toJSON();
        let result = new ProductHandoverInput();
        result.init(json);
        return result;
    }
}

export interface IProductHandoverInput {
    pr_id: number;
    pr_quantity: number;
}

export class ProductImportDto implements IProductImportDto {
    pr_im_no!: number;
    pr_im_name!: string | undefined;
    pr_im_code!: string | undefined;
    pr_im_quantity!: number;
    pr_im_unit!: string | undefined;
    pr_im_unit_price!: number;
    pr_im_quantity_quydoi!: number;
    pr_im_unit_quydoi!: string | undefined;
    pr_im_total_money!: number;
    pr_remain_in_repository!: number;
    pr_im_reconcile_status!: EBillReconcileStatus;
    pr_im_reconcile_reason!: string | undefined;
    pr_im_reconcile_at!: Date | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IProductImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_im_no = _data["pr_im_no"];
            this.pr_im_name = _data["pr_im_name"];
            this.pr_im_code = _data["pr_im_code"];
            this.pr_im_quantity = _data["pr_im_quantity"];
            this.pr_im_unit = _data["pr_im_unit"];
            this.pr_im_unit_price = _data["pr_im_unit_price"];
            this.pr_im_quantity_quydoi = _data["pr_im_quantity_quydoi"];
            this.pr_im_unit_quydoi = _data["pr_im_unit_quydoi"];
            this.pr_im_total_money = _data["pr_im_total_money"];
            this.pr_remain_in_repository = _data["pr_remain_in_repository"];
            this.pr_im_reconcile_status = _data["pr_im_reconcile_status"];
            this.pr_im_reconcile_reason = _data["pr_im_reconcile_reason"];
            this.pr_im_reconcile_at = _data["pr_im_reconcile_at"] ? new Date(_data["pr_im_reconcile_at"].toString()) : <any>undefined;
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_im_no"] = this.pr_im_no;
        data["pr_im_name"] = this.pr_im_name;
        data["pr_im_code"] = this.pr_im_code;
        data["pr_im_quantity"] = this.pr_im_quantity;
        data["pr_im_unit"] = this.pr_im_unit;
        data["pr_im_unit_price"] = this.pr_im_unit_price;
        data["pr_im_quantity_quydoi"] = this.pr_im_quantity_quydoi;
        data["pr_im_unit_quydoi"] = this.pr_im_unit_quydoi;
        data["pr_im_total_money"] = this.pr_im_total_money;
        data["pr_remain_in_repository"] = this.pr_remain_in_repository;
        data["pr_im_reconcile_status"] = this.pr_im_reconcile_status;
        data["pr_im_reconcile_reason"] = this.pr_im_reconcile_reason;
        data["pr_im_reconcile_at"] = this.pr_im_reconcile_at ? this.pr_im_reconcile_at.toISOString() : <any>undefined;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductImportDto {
        const json = this.toJSON();
        let result = new ProductImportDto();
        result.init(json);
        return result;
    }
}

export interface IProductImportDto {
    pr_im_no: number;
    pr_im_name: string | undefined;
    pr_im_code: string | undefined;
    pr_im_quantity: number;
    pr_im_unit: string | undefined;
    pr_im_unit_price: number;
    pr_im_quantity_quydoi: number;
    pr_im_unit_quydoi: string | undefined;
    pr_im_total_money: number;
    pr_remain_in_repository: number;
    pr_im_reconcile_status: EBillReconcileStatus;
    pr_im_reconcile_reason: string | undefined;
    pr_im_reconcile_at: Date | undefined;
    fi_id: AttachmentItem;
}

export class ProductInRepositoryAbtractDto implements IProductInRepositoryAbtractDto {
    re_de_id!: number;
    re_id!: number;
    pr_id!: number;
    pr_name!: string | undefined;
    us_id!: number;
    pr_quantity!: number;
    pr_unit!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IProductInRepositoryAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_de_id = _data["re_de_id"];
            this.re_id = _data["re_id"];
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.us_id = _data["us_id"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_unit = _data["pr_unit"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductInRepositoryAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInRepositoryAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_de_id"] = this.re_de_id;
        data["re_id"] = this.re_id;
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["us_id"] = this.us_id;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_unit"] = this.pr_unit;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductInRepositoryAbtractDto {
        const json = this.toJSON();
        let result = new ProductInRepositoryAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IProductInRepositoryAbtractDto {
    re_de_id: number;
    re_id: number;
    pr_id: number;
    pr_name: string | undefined;
    us_id: number;
    pr_quantity: number;
    pr_unit: string | undefined;
    fi_id: AttachmentItem;
}

export class ProductLossDto implements IProductLossDto {
    pr_lo_no!: number;
    pr_lo_name!: string | undefined;
    pr_lo_code!: string | undefined;
    pr_lo_quantity!: number;
    pr_lo_quantity_quydoi!: number;
    pr_lo_unit!: string | undefined;
    pr_lo_unit_quydoi!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IProductLossDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_lo_no = _data["pr_lo_no"];
            this.pr_lo_name = _data["pr_lo_name"];
            this.pr_lo_code = _data["pr_lo_code"];
            this.pr_lo_quantity = _data["pr_lo_quantity"];
            this.pr_lo_quantity_quydoi = _data["pr_lo_quantity_quydoi"];
            this.pr_lo_unit = _data["pr_lo_unit"];
            this.pr_lo_unit_quydoi = _data["pr_lo_unit_quydoi"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductLossDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductLossDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_lo_no"] = this.pr_lo_no;
        data["pr_lo_name"] = this.pr_lo_name;
        data["pr_lo_code"] = this.pr_lo_code;
        data["pr_lo_quantity"] = this.pr_lo_quantity;
        data["pr_lo_quantity_quydoi"] = this.pr_lo_quantity_quydoi;
        data["pr_lo_unit"] = this.pr_lo_unit;
        data["pr_lo_unit_quydoi"] = this.pr_lo_unit_quydoi;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductLossDto {
        const json = this.toJSON();
        let result = new ProductLossDto();
        result.init(json);
        return result;
    }
}

export interface IProductLossDto {
    pr_lo_no: number;
    pr_lo_name: string | undefined;
    pr_lo_code: string | undefined;
    pr_lo_quantity: number;
    pr_lo_quantity_quydoi: number;
    pr_lo_unit: string | undefined;
    pr_lo_unit_quydoi: string | undefined;
    fi_id: AttachmentItem;
}

export class ProductTranferDto implements IProductTranferDto {
    pr_tr_no!: number;
    pr_id!: number;
    pr_tr_name!: string | undefined;
    pr_tr_code!: string | undefined;
    pr_tr_quantity!: number;
    pr_tr_unit!: string | undefined;
    pr_tr_total_money!: number;
    pr_tr_unit_price!: number;
    pr_tr_quantity_quydoi!: number;
    pr_tr_unit_quydoi!: string | undefined;
    pr_remain_in_repository!: number;
    fi_id!: AttachmentItem;

    constructor(data?: IProductTranferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_tr_no = _data["pr_tr_no"];
            this.pr_id = _data["pr_id"];
            this.pr_tr_name = _data["pr_tr_name"];
            this.pr_tr_code = _data["pr_tr_code"];
            this.pr_tr_quantity = _data["pr_tr_quantity"];
            this.pr_tr_unit = _data["pr_tr_unit"];
            this.pr_tr_total_money = _data["pr_tr_total_money"];
            this.pr_tr_unit_price = _data["pr_tr_unit_price"];
            this.pr_tr_quantity_quydoi = _data["pr_tr_quantity_quydoi"];
            this.pr_tr_unit_quydoi = _data["pr_tr_unit_quydoi"];
            this.pr_remain_in_repository = _data["pr_remain_in_repository"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductTranferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTranferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_tr_no"] = this.pr_tr_no;
        data["pr_id"] = this.pr_id;
        data["pr_tr_name"] = this.pr_tr_name;
        data["pr_tr_code"] = this.pr_tr_code;
        data["pr_tr_quantity"] = this.pr_tr_quantity;
        data["pr_tr_unit"] = this.pr_tr_unit;
        data["pr_tr_total_money"] = this.pr_tr_total_money;
        data["pr_tr_unit_price"] = this.pr_tr_unit_price;
        data["pr_tr_quantity_quydoi"] = this.pr_tr_quantity_quydoi;
        data["pr_tr_unit_quydoi"] = this.pr_tr_unit_quydoi;
        data["pr_remain_in_repository"] = this.pr_remain_in_repository;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductTranferDto {
        const json = this.toJSON();
        let result = new ProductTranferDto();
        result.init(json);
        return result;
    }
}

export interface IProductTranferDto {
    pr_tr_no: number;
    pr_id: number;
    pr_tr_name: string | undefined;
    pr_tr_code: string | undefined;
    pr_tr_quantity: number;
    pr_tr_unit: string | undefined;
    pr_tr_total_money: number;
    pr_tr_unit_price: number;
    pr_tr_quantity_quydoi: number;
    pr_tr_unit_quydoi: string | undefined;
    pr_remain_in_repository: number;
    fi_id: AttachmentItem;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    readonly name!: string | undefined;
    declaringType!: Type;
    reflectedType!: Type;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    memberType!: MemberTypes;
    propertyType!: Type;
    attributes!: PropertyAttributes;
    readonly isSpecialName!: boolean;
    readonly canRead!: boolean;
    readonly canWrite!: boolean;
    getMethod!: MethodInfo;
    setMethod!: MethodInfo;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        return data;
    }

    clone(): PropertyInfo {
        const json = this.toJSON();
        let result = new PropertyInfo();
        result.init(json);
        return result;
    }
}

export interface IPropertyInfo {
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    memberType: MemberTypes;
    propertyType: Type;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
}

export class PublicKey implements IPublicKey {
    encodedKeyValue!: AsnEncodedData;
    encodedParameters!: AsnEncodedData;
    key!: AsymmetricAlgorithm;
    oid!: Oid;

    constructor(data?: IPublicKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.encodedKeyValue = _data["encodedKeyValue"] ? AsnEncodedData.fromJS(_data["encodedKeyValue"]) : <any>undefined;
            this.encodedParameters = _data["encodedParameters"] ? AsnEncodedData.fromJS(_data["encodedParameters"]) : <any>undefined;
            this.key = _data["key"] ? AsymmetricAlgorithm.fromJS(_data["key"]) : <any>undefined;
            this.oid = _data["oid"] ? Oid.fromJS(_data["oid"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PublicKey {
        data = typeof data === 'object' ? data : {};
        let result = new PublicKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["encodedKeyValue"] = this.encodedKeyValue ? this.encodedKeyValue.toJSON() : <any>undefined;
        data["encodedParameters"] = this.encodedParameters ? this.encodedParameters.toJSON() : <any>undefined;
        data["key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        return data;
    }

    clone(): PublicKey {
        const json = this.toJSON();
        let result = new PublicKey();
        result.init(json);
        return result;
    }
}

export interface IPublicKey {
    encodedKeyValue: AsnEncodedData;
    encodedParameters: AsnEncodedData;
    key: AsymmetricAlgorithm;
    oid: Oid;
}

export class QueryString implements IQueryString {
    value!: string | undefined;
    readonly hasValue!: boolean;

    constructor(data?: IQueryString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).hasValue = _data["hasValue"];
        }
    }

    static fromJS(data: any): QueryString {
        data = typeof data === 'object' ? data : {};
        let result = new QueryString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["hasValue"] = this.hasValue;
        return data;
    }

    clone(): QueryString {
        const json = this.toJSON();
        let result = new QueryString();
        result.init(json);
        return result;
    }
}

export interface IQueryString {
    value: string | undefined;
    hasValue: boolean;
}

export enum RFIDTypeDrinkPayment {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum RFIDTypeRecharge {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class RechargeMoneyInput implements IRechargeMoneyInput {
    rf_code!: string;
    rf_money!: number;
    deviceID!: string | undefined;

    constructor(data?: IRechargeMoneyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_code = _data["rf_code"];
            this.rf_money = _data["rf_money"];
            this.deviceID = _data["deviceID"];
        }
    }

    static fromJS(data: any): RechargeMoneyInput {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeMoneyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_code"] = this.rf_code;
        data["rf_money"] = this.rf_money;
        data["deviceID"] = this.deviceID;
        return data;
    }

    clone(): RechargeMoneyInput {
        const json = this.toJSON();
        let result = new RechargeMoneyInput();
        result.init(json);
        return result;
    }
}

export interface IRechargeMoneyInput {
    rf_code: string;
    rf_money: number;
    deviceID: string | undefined;
}

export class ReconcileBankDto implements IReconcileBankDto {
    recb_id!: number;
    ma_id!: number;
    us_id_operator!: number;
    recb_type!: EReconcileType;
    recb_total_money_calculated!: number;
    recb_total_money_reality!: number;
    recb_total_money_billingofrfid!: number;
    recb_total_money_sale_billingofrfid!: number;
    recb_status!: EReconcileStatus;
    recb_from!: Date | undefined;
    recb_to!: Date | undefined;
    recb_created_at!: Date;
    fi_id!: AttachmentItem;
    listBillingId!: number[] | undefined;
    listRfidLogsId!: number[] | undefined;
    listBillingOnlyInExcel!: ExcelReconcileDto[] | undefined;
    recb_month!: string | undefined;
    listReconcileBank!: ReconcileBankDto[] | undefined;

    constructor(data?: IReconcileBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recb_id = _data["recb_id"];
            this.ma_id = _data["ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.recb_type = _data["recb_type"];
            this.recb_total_money_calculated = _data["recb_total_money_calculated"];
            this.recb_total_money_reality = _data["recb_total_money_reality"];
            this.recb_total_money_billingofrfid = _data["recb_total_money_billingofrfid"];
            this.recb_total_money_sale_billingofrfid = _data["recb_total_money_sale_billingofrfid"];
            this.recb_status = _data["recb_status"];
            this.recb_from = _data["recb_from"] ? new Date(_data["recb_from"].toString()) : <any>undefined;
            this.recb_to = _data["recb_to"] ? new Date(_data["recb_to"].toString()) : <any>undefined;
            this.recb_created_at = _data["recb_created_at"] ? new Date(_data["recb_created_at"].toString()) : <any>undefined;
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            if (Array.isArray(_data["listBillingId"])) {
                this.listBillingId = [] as any;
                for (let item of _data["listBillingId"])
                    this.listBillingId!.push(item);
            }
            if (Array.isArray(_data["listRfidLogsId"])) {
                this.listRfidLogsId = [] as any;
                for (let item of _data["listRfidLogsId"])
                    this.listRfidLogsId!.push(item);
            }
            if (Array.isArray(_data["listBillingOnlyInExcel"])) {
                this.listBillingOnlyInExcel = [] as any;
                for (let item of _data["listBillingOnlyInExcel"])
                    this.listBillingOnlyInExcel!.push(ExcelReconcileDto.fromJS(item));
            }
            this.recb_month = _data["recb_month"];
            if (Array.isArray(_data["listReconcileBank"])) {
                this.listReconcileBank = [] as any;
                for (let item of _data["listReconcileBank"])
                    this.listReconcileBank!.push(ReconcileBankDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReconcileBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recb_id"] = this.recb_id;
        data["ma_id"] = this.ma_id;
        data["us_id_operator"] = this.us_id_operator;
        data["recb_type"] = this.recb_type;
        data["recb_total_money_calculated"] = this.recb_total_money_calculated;
        data["recb_total_money_reality"] = this.recb_total_money_reality;
        data["recb_total_money_billingofrfid"] = this.recb_total_money_billingofrfid;
        data["recb_total_money_sale_billingofrfid"] = this.recb_total_money_sale_billingofrfid;
        data["recb_status"] = this.recb_status;
        data["recb_from"] = this.recb_from ? this.recb_from.toISOString() : <any>undefined;
        data["recb_to"] = this.recb_to ? this.recb_to.toISOString() : <any>undefined;
        data["recb_created_at"] = this.recb_created_at ? this.recb_created_at.toISOString() : <any>undefined;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        if (Array.isArray(this.listBillingId)) {
            data["listBillingId"] = [];
            for (let item of this.listBillingId)
                data["listBillingId"].push(item);
        }
        if (Array.isArray(this.listRfidLogsId)) {
            data["listRfidLogsId"] = [];
            for (let item of this.listRfidLogsId)
                data["listRfidLogsId"].push(item);
        }
        if (Array.isArray(this.listBillingOnlyInExcel)) {
            data["listBillingOnlyInExcel"] = [];
            for (let item of this.listBillingOnlyInExcel)
                data["listBillingOnlyInExcel"].push(item.toJSON());
        }
        data["recb_month"] = this.recb_month;
        if (Array.isArray(this.listReconcileBank)) {
            data["listReconcileBank"] = [];
            for (let item of this.listReconcileBank)
                data["listReconcileBank"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReconcileBankDto {
        const json = this.toJSON();
        let result = new ReconcileBankDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileBankDto {
    recb_id: number;
    ma_id: number;
    us_id_operator: number;
    recb_type: EReconcileType;
    recb_total_money_calculated: number;
    recb_total_money_reality: number;
    recb_total_money_billingofrfid: number;
    recb_total_money_sale_billingofrfid: number;
    recb_status: EReconcileStatus;
    recb_from: Date | undefined;
    recb_to: Date | undefined;
    recb_created_at: Date;
    fi_id: AttachmentItem;
    listBillingId: number[] | undefined;
    listRfidLogsId: number[] | undefined;
    listBillingOnlyInExcel: ExcelReconcileDto[] | undefined;
    recb_month: string | undefined;
    listReconcileBank: ReconcileBankDto[] | undefined;
}

export class ReconcileBankDtoPagedResultDto implements IReconcileBankDtoPagedResultDto {
    items!: ReconcileBankDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReconcileBankDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReconcileBankDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReconcileBankDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileBankDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReconcileBankDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReconcileBankDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileBankDtoPagedResultDto {
    items: ReconcileBankDto[] | undefined;
    totalCount: number;
}

export class ReconcileBankInput implements IReconcileBankInput {
    excelReconcileInput!: ExcelReconcileBankInput[] | undefined;
    reconcileInput!: ReconcileInput;

    constructor(data?: IReconcileBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["excelReconcileInput"])) {
                this.excelReconcileInput = [] as any;
                for (let item of _data["excelReconcileInput"])
                    this.excelReconcileInput!.push(ExcelReconcileBankInput.fromJS(item));
            }
            this.reconcileInput = _data["reconcileInput"] ? ReconcileInput.fromJS(_data["reconcileInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.excelReconcileInput)) {
            data["excelReconcileInput"] = [];
            for (let item of this.excelReconcileInput)
                data["excelReconcileInput"].push(item.toJSON());
        }
        data["reconcileInput"] = this.reconcileInput ? this.reconcileInput.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReconcileBankInput {
        const json = this.toJSON();
        let result = new ReconcileBankInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileBankInput {
    excelReconcileInput: ExcelReconcileBankInput[] | undefined;
    reconcileInput: ReconcileInput;
}

export class ReconcileCashInput implements IReconcileCashInput {
    rec_to!: Date;
    rec_code!: string | undefined;
    rec_total_money_reality!: number;
    rec_total_money_calculated!: number;
    deviceID!: string | undefined;

    constructor(data?: IReconcileCashInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_to = _data["rec_to"] ? new Date(_data["rec_to"].toString()) : <any>undefined;
            this.rec_code = _data["rec_code"];
            this.rec_total_money_reality = _data["rec_total_money_reality"];
            this.rec_total_money_calculated = _data["rec_total_money_calculated"];
            this.deviceID = _data["deviceID"];
        }
    }

    static fromJS(data: any): ReconcileCashInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileCashInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_to"] = this.rec_to ? this.rec_to.toISOString() : <any>undefined;
        data["rec_code"] = this.rec_code;
        data["rec_total_money_reality"] = this.rec_total_money_reality;
        data["rec_total_money_calculated"] = this.rec_total_money_calculated;
        data["deviceID"] = this.deviceID;
        return data;
    }

    clone(): ReconcileCashInput {
        const json = this.toJSON();
        let result = new ReconcileCashInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileCashInput {
    rec_to: Date;
    rec_code: string | undefined;
    rec_total_money_reality: number;
    rec_total_money_calculated: number;
    deviceID: string | undefined;
}

export class ReconcileDto implements IReconcileDto {
    key!: string | undefined;
    name!: string | undefined;
    rec_id!: number;
    ma_id!: number;
    us_id_operator!: number;
    rec_total_money_calculated!: number;
    rec_total_money_reality!: number;
    rec_money_reality!: number;
    rec_refund_money!: number;
    rec_swallow_money!: number;
    listBillingId!: number[] | undefined;
    listRefundId!: number[] | undefined;
    listSwallowId!: number[] | undefined;
    children!: ReconcileDto[] | undefined;
    rec_created_at!: Date | undefined;
    rec_import_at!: Date | undefined;

    constructor(data?: IReconcileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.rec_id = _data["rec_id"];
            this.ma_id = _data["ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.rec_total_money_calculated = _data["rec_total_money_calculated"];
            this.rec_total_money_reality = _data["rec_total_money_reality"];
            this.rec_money_reality = _data["rec_money_reality"];
            this.rec_refund_money = _data["rec_refund_money"];
            this.rec_swallow_money = _data["rec_swallow_money"];
            if (Array.isArray(_data["listBillingId"])) {
                this.listBillingId = [] as any;
                for (let item of _data["listBillingId"])
                    this.listBillingId!.push(item);
            }
            if (Array.isArray(_data["listRefundId"])) {
                this.listRefundId = [] as any;
                for (let item of _data["listRefundId"])
                    this.listRefundId!.push(item);
            }
            if (Array.isArray(_data["listSwallowId"])) {
                this.listSwallowId = [] as any;
                for (let item of _data["listSwallowId"])
                    this.listSwallowId!.push(item);
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ReconcileDto.fromJS(item));
            }
            this.rec_created_at = _data["rec_created_at"] ? new Date(_data["rec_created_at"].toString()) : <any>undefined;
            this.rec_import_at = _data["rec_import_at"] ? new Date(_data["rec_import_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["rec_id"] = this.rec_id;
        data["ma_id"] = this.ma_id;
        data["us_id_operator"] = this.us_id_operator;
        data["rec_total_money_calculated"] = this.rec_total_money_calculated;
        data["rec_total_money_reality"] = this.rec_total_money_reality;
        data["rec_money_reality"] = this.rec_money_reality;
        data["rec_refund_money"] = this.rec_refund_money;
        data["rec_swallow_money"] = this.rec_swallow_money;
        if (Array.isArray(this.listBillingId)) {
            data["listBillingId"] = [];
            for (let item of this.listBillingId)
                data["listBillingId"].push(item);
        }
        if (Array.isArray(this.listRefundId)) {
            data["listRefundId"] = [];
            for (let item of this.listRefundId)
                data["listRefundId"].push(item);
        }
        if (Array.isArray(this.listSwallowId)) {
            data["listSwallowId"] = [];
            for (let item of this.listSwallowId)
                data["listSwallowId"].push(item);
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["rec_created_at"] = this.rec_created_at ? this.rec_created_at.toISOString() : <any>undefined;
        data["rec_import_at"] = this.rec_import_at ? this.rec_import_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ReconcileDto {
        const json = this.toJSON();
        let result = new ReconcileDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileDto {
    key: string | undefined;
    name: string | undefined;
    rec_id: number;
    ma_id: number;
    us_id_operator: number;
    rec_total_money_calculated: number;
    rec_total_money_reality: number;
    rec_money_reality: number;
    rec_refund_money: number;
    rec_swallow_money: number;
    listBillingId: number[] | undefined;
    listRefundId: number[] | undefined;
    listSwallowId: number[] | undefined;
    children: ReconcileDto[] | undefined;
    rec_created_at: Date | undefined;
    rec_import_at: Date | undefined;
}

export class ReconcileDtoPagedResultDto implements IReconcileDtoPagedResultDto {
    items!: ReconcileDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReconcileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReconcileDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReconcileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReconcileDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReconcileDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileDtoPagedResultDto {
    items: ReconcileDto[] | undefined;
    totalCount: number;
}

export class ReconcileInput implements IReconcileInput {
    recb_from!: Date;
    recb_to!: Date;
    fi_id!: AttachmentItem;

    constructor(data?: IReconcileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recb_from = _data["recb_from"] ? new Date(_data["recb_from"].toString()) : <any>undefined;
            this.recb_to = _data["recb_to"] ? new Date(_data["recb_to"].toString()) : <any>undefined;
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recb_from"] = this.recb_from ? this.recb_from.toISOString() : <any>undefined;
        data["recb_to"] = this.recb_to ? this.recb_to.toISOString() : <any>undefined;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReconcileInput {
        const json = this.toJSON();
        let result = new ReconcileInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileInput {
    recb_from: Date;
    recb_to: Date;
    fi_id: AttachmentItem;
}

export class ReconcileLogsDto implements IReconcileLogsDto {
    rec_id!: number;
    rec_lo_code!: string | undefined;
    rec_lo_reconcile_status!: EBillReconcileStatus;
    rec_lo_reconcile_reason!: string | undefined;
    rec_lo_created_at!: Date;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IReconcileLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.rec_lo_code = _data["rec_lo_code"];
            this.rec_lo_reconcile_status = _data["rec_lo_reconcile_status"];
            this.rec_lo_reconcile_reason = _data["rec_lo_reconcile_reason"];
            this.rec_lo_created_at = _data["rec_lo_created_at"] ? new Date(_data["rec_lo_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReconcileLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["rec_lo_code"] = this.rec_lo_code;
        data["rec_lo_reconcile_status"] = this.rec_lo_reconcile_status;
        data["rec_lo_reconcile_reason"] = this.rec_lo_reconcile_reason;
        data["rec_lo_created_at"] = this.rec_lo_created_at ? this.rec_lo_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReconcileLogsDto {
        const json = this.toJSON();
        let result = new ReconcileLogsDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileLogsDto {
    rec_id: number;
    rec_lo_code: string | undefined;
    rec_lo_reconcile_status: EBillReconcileStatus;
    rec_lo_reconcile_reason: string | undefined;
    rec_lo_created_at: Date;
    fi_id_list: AttachmentItem[] | undefined;
}

export class ReconcileLogsDtoPagedResultDto implements IReconcileLogsDtoPagedResultDto {
    items!: ReconcileLogsDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReconcileLogsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReconcileLogsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReconcileLogsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileLogsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReconcileLogsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReconcileLogsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileLogsDtoPagedResultDto {
    items: ReconcileLogsDto[] | undefined;
    totalCount: number;
}

export class ReconcileProductSupplierDebtDto implements IReconcileProductSupplierDebtDto {
    pr_code!: string | undefined;
    pr_name!: string | undefined;
    pr_quantity!: number;
    pr_unit_price!: number;
    pr_total_money!: number;
    pr_im_reconcile_status!: EBillReconcileStatus;
    pr_im_reconcile_reason!: string | undefined;
    pr_im_reconcile_at!: Date | undefined;

    constructor(data?: IReconcileProductSupplierDebtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_code = _data["pr_code"];
            this.pr_name = _data["pr_name"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_unit_price = _data["pr_unit_price"];
            this.pr_total_money = _data["pr_total_money"];
            this.pr_im_reconcile_status = _data["pr_im_reconcile_status"];
            this.pr_im_reconcile_reason = _data["pr_im_reconcile_reason"];
            this.pr_im_reconcile_at = _data["pr_im_reconcile_at"] ? new Date(_data["pr_im_reconcile_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileProductSupplierDebtDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileProductSupplierDebtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_code"] = this.pr_code;
        data["pr_name"] = this.pr_name;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_unit_price"] = this.pr_unit_price;
        data["pr_total_money"] = this.pr_total_money;
        data["pr_im_reconcile_status"] = this.pr_im_reconcile_status;
        data["pr_im_reconcile_reason"] = this.pr_im_reconcile_reason;
        data["pr_im_reconcile_at"] = this.pr_im_reconcile_at ? this.pr_im_reconcile_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ReconcileProductSupplierDebtDto {
        const json = this.toJSON();
        let result = new ReconcileProductSupplierDebtDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileProductSupplierDebtDto {
    pr_code: string | undefined;
    pr_name: string | undefined;
    pr_quantity: number;
    pr_unit_price: number;
    pr_total_money: number;
    pr_im_reconcile_status: EBillReconcileStatus;
    pr_im_reconcile_reason: string | undefined;
    pr_im_reconcile_at: Date | undefined;
}

export class ReconcileProductSupplierDebtInput implements IReconcileProductSupplierDebtInput {
    pr_code!: string | undefined;
    pr_name!: string | undefined;
    pr_quantity!: number;
    pr_unit!: string | undefined;
    pr_total_money!: number;

    constructor(data?: IReconcileProductSupplierDebtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_code = _data["pr_code"];
            this.pr_name = _data["pr_name"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_unit = _data["pr_unit"];
            this.pr_total_money = _data["pr_total_money"];
        }
    }

    static fromJS(data: any): ReconcileProductSupplierDebtInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileProductSupplierDebtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_code"] = this.pr_code;
        data["pr_name"] = this.pr_name;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_unit"] = this.pr_unit;
        data["pr_total_money"] = this.pr_total_money;
        return data;
    }

    clone(): ReconcileProductSupplierDebtInput {
        const json = this.toJSON();
        let result = new ReconcileProductSupplierDebtInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileProductSupplierDebtInput {
    pr_code: string | undefined;
    pr_name: string | undefined;
    pr_quantity: number;
    pr_unit: string | undefined;
    pr_total_money: number;
}

export class ReconcileRFIDDto implements IReconcileRFIDDto {
    recb_id!: number;
    ma_id!: number;
    us_id_operator!: number;
    recb_type!: EReconcileType;
    recb_total_money_calculated!: number;
    recb_total_money_reality!: number;
    recb_total_money_billingofrfid!: number;
    recb_total_money_sale_billingofrfid!: number;
    recb_status!: EReconcileStatus;
    recb_from!: Date | undefined;
    recb_to!: Date | undefined;
    recb_created_at!: Date;
    fi_id!: AttachmentItem;
    listBillingId!: number[] | undefined;
    listRfidLogsId!: number[] | undefined;
    listBillingOnlyInExcel!: ExcelReconcileDto[] | undefined;
    recb_month!: string | undefined;
    listReconcileBank!: ReconcileBankDto[] | undefined;

    constructor(data?: IReconcileRFIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recb_id = _data["recb_id"];
            this.ma_id = _data["ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.recb_type = _data["recb_type"];
            this.recb_total_money_calculated = _data["recb_total_money_calculated"];
            this.recb_total_money_reality = _data["recb_total_money_reality"];
            this.recb_total_money_billingofrfid = _data["recb_total_money_billingofrfid"];
            this.recb_total_money_sale_billingofrfid = _data["recb_total_money_sale_billingofrfid"];
            this.recb_status = _data["recb_status"];
            this.recb_from = _data["recb_from"] ? new Date(_data["recb_from"].toString()) : <any>undefined;
            this.recb_to = _data["recb_to"] ? new Date(_data["recb_to"].toString()) : <any>undefined;
            this.recb_created_at = _data["recb_created_at"] ? new Date(_data["recb_created_at"].toString()) : <any>undefined;
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            if (Array.isArray(_data["listBillingId"])) {
                this.listBillingId = [] as any;
                for (let item of _data["listBillingId"])
                    this.listBillingId!.push(item);
            }
            if (Array.isArray(_data["listRfidLogsId"])) {
                this.listRfidLogsId = [] as any;
                for (let item of _data["listRfidLogsId"])
                    this.listRfidLogsId!.push(item);
            }
            if (Array.isArray(_data["listBillingOnlyInExcel"])) {
                this.listBillingOnlyInExcel = [] as any;
                for (let item of _data["listBillingOnlyInExcel"])
                    this.listBillingOnlyInExcel!.push(ExcelReconcileDto.fromJS(item));
            }
            this.recb_month = _data["recb_month"];
            if (Array.isArray(_data["listReconcileBank"])) {
                this.listReconcileBank = [] as any;
                for (let item of _data["listReconcileBank"])
                    this.listReconcileBank!.push(ReconcileBankDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReconcileRFIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileRFIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recb_id"] = this.recb_id;
        data["ma_id"] = this.ma_id;
        data["us_id_operator"] = this.us_id_operator;
        data["recb_type"] = this.recb_type;
        data["recb_total_money_calculated"] = this.recb_total_money_calculated;
        data["recb_total_money_reality"] = this.recb_total_money_reality;
        data["recb_total_money_billingofrfid"] = this.recb_total_money_billingofrfid;
        data["recb_total_money_sale_billingofrfid"] = this.recb_total_money_sale_billingofrfid;
        data["recb_status"] = this.recb_status;
        data["recb_from"] = this.recb_from ? this.recb_from.toISOString() : <any>undefined;
        data["recb_to"] = this.recb_to ? this.recb_to.toISOString() : <any>undefined;
        data["recb_created_at"] = this.recb_created_at ? this.recb_created_at.toISOString() : <any>undefined;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        if (Array.isArray(this.listBillingId)) {
            data["listBillingId"] = [];
            for (let item of this.listBillingId)
                data["listBillingId"].push(item);
        }
        if (Array.isArray(this.listRfidLogsId)) {
            data["listRfidLogsId"] = [];
            for (let item of this.listRfidLogsId)
                data["listRfidLogsId"].push(item);
        }
        if (Array.isArray(this.listBillingOnlyInExcel)) {
            data["listBillingOnlyInExcel"] = [];
            for (let item of this.listBillingOnlyInExcel)
                data["listBillingOnlyInExcel"].push(item.toJSON());
        }
        data["recb_month"] = this.recb_month;
        if (Array.isArray(this.listReconcileBank)) {
            data["listReconcileBank"] = [];
            for (let item of this.listReconcileBank)
                data["listReconcileBank"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReconcileRFIDDto {
        const json = this.toJSON();
        let result = new ReconcileRFIDDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileRFIDDto {
    recb_id: number;
    ma_id: number;
    us_id_operator: number;
    recb_type: EReconcileType;
    recb_total_money_calculated: number;
    recb_total_money_reality: number;
    recb_total_money_billingofrfid: number;
    recb_total_money_sale_billingofrfid: number;
    recb_status: EReconcileStatus;
    recb_from: Date | undefined;
    recb_to: Date | undefined;
    recb_created_at: Date;
    fi_id: AttachmentItem;
    listBillingId: number[] | undefined;
    listRfidLogsId: number[] | undefined;
    listBillingOnlyInExcel: ExcelReconcileDto[] | undefined;
    recb_month: string | undefined;
    listReconcileBank: ReconcileBankDto[] | undefined;
}

export class ReconcileRFIDDtoPagedResultDto implements IReconcileRFIDDtoPagedResultDto {
    items!: ReconcileRFIDDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReconcileRFIDDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReconcileRFIDDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReconcileRFIDDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileRFIDDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReconcileRFIDDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReconcileRFIDDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileRFIDDtoPagedResultDto {
    items: ReconcileRFIDDto[] | undefined;
    totalCount: number;
}

export class ReconcileRFIDInput implements IReconcileRFIDInput {
    excelReconcileInput!: ExcelReconcileRFIDInput[] | undefined;
    reconcileInput!: ReconcileInput;

    constructor(data?: IReconcileRFIDInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["excelReconcileInput"])) {
                this.excelReconcileInput = [] as any;
                for (let item of _data["excelReconcileInput"])
                    this.excelReconcileInput!.push(ExcelReconcileRFIDInput.fromJS(item));
            }
            this.reconcileInput = _data["reconcileInput"] ? ReconcileInput.fromJS(_data["reconcileInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileRFIDInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileRFIDInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.excelReconcileInput)) {
            data["excelReconcileInput"] = [];
            for (let item of this.excelReconcileInput)
                data["excelReconcileInput"].push(item.toJSON());
        }
        data["reconcileInput"] = this.reconcileInput ? this.reconcileInput.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReconcileRFIDInput {
        const json = this.toJSON();
        let result = new ReconcileRFIDInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileRFIDInput {
    excelReconcileInput: ExcelReconcileRFIDInput[] | undefined;
    reconcileInput: ReconcileInput;
}

export class ReconcileSupplierDebtDetailDto implements IReconcileSupplierDebtDetailDto {
    recb_id!: number;
    su_id!: number;
    recb_type!: EReconcileType;
    recb_total_money_calculated!: number;
    recb_remain_supplier_debt!: number;
    recb_im_re_code!: string | undefined;
    listSupplierDebtOnlyInExcel!: ReconcileProductSupplierDebtDto[] | undefined;
    listProductImport!: ProductImportDto[] | undefined;
    recb_total_money_reality!: number;
    recb_status!: EReconcileStatus;
    recb_from!: Date | undefined;
    recb_to!: Date | undefined;
    recb_created_at!: Date;
    fi_id!: AttachmentItem;

    constructor(data?: IReconcileSupplierDebtDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recb_id = _data["recb_id"];
            this.su_id = _data["su_id"];
            this.recb_type = _data["recb_type"];
            this.recb_total_money_calculated = _data["recb_total_money_calculated"];
            this.recb_remain_supplier_debt = _data["recb_remain_supplier_debt"];
            this.recb_im_re_code = _data["recb_im_re_code"];
            if (Array.isArray(_data["listSupplierDebtOnlyInExcel"])) {
                this.listSupplierDebtOnlyInExcel = [] as any;
                for (let item of _data["listSupplierDebtOnlyInExcel"])
                    this.listSupplierDebtOnlyInExcel!.push(ReconcileProductSupplierDebtDto.fromJS(item));
            }
            if (Array.isArray(_data["listProductImport"])) {
                this.listProductImport = [] as any;
                for (let item of _data["listProductImport"])
                    this.listProductImport!.push(ProductImportDto.fromJS(item));
            }
            this.recb_total_money_reality = _data["recb_total_money_reality"];
            this.recb_status = _data["recb_status"];
            this.recb_from = _data["recb_from"] ? new Date(_data["recb_from"].toString()) : <any>undefined;
            this.recb_to = _data["recb_to"] ? new Date(_data["recb_to"].toString()) : <any>undefined;
            this.recb_created_at = _data["recb_created_at"] ? new Date(_data["recb_created_at"].toString()) : <any>undefined;
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileSupplierDebtDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileSupplierDebtDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recb_id"] = this.recb_id;
        data["su_id"] = this.su_id;
        data["recb_type"] = this.recb_type;
        data["recb_total_money_calculated"] = this.recb_total_money_calculated;
        data["recb_remain_supplier_debt"] = this.recb_remain_supplier_debt;
        data["recb_im_re_code"] = this.recb_im_re_code;
        if (Array.isArray(this.listSupplierDebtOnlyInExcel)) {
            data["listSupplierDebtOnlyInExcel"] = [];
            for (let item of this.listSupplierDebtOnlyInExcel)
                data["listSupplierDebtOnlyInExcel"].push(item.toJSON());
        }
        if (Array.isArray(this.listProductImport)) {
            data["listProductImport"] = [];
            for (let item of this.listProductImport)
                data["listProductImport"].push(item.toJSON());
        }
        data["recb_total_money_reality"] = this.recb_total_money_reality;
        data["recb_status"] = this.recb_status;
        data["recb_from"] = this.recb_from ? this.recb_from.toISOString() : <any>undefined;
        data["recb_to"] = this.recb_to ? this.recb_to.toISOString() : <any>undefined;
        data["recb_created_at"] = this.recb_created_at ? this.recb_created_at.toISOString() : <any>undefined;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReconcileSupplierDebtDetailDto {
        const json = this.toJSON();
        let result = new ReconcileSupplierDebtDetailDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileSupplierDebtDetailDto {
    recb_id: number;
    su_id: number;
    recb_type: EReconcileType;
    recb_total_money_calculated: number;
    recb_remain_supplier_debt: number;
    recb_im_re_code: string | undefined;
    listSupplierDebtOnlyInExcel: ReconcileProductSupplierDebtDto[] | undefined;
    listProductImport: ProductImportDto[] | undefined;
    recb_total_money_reality: number;
    recb_status: EReconcileStatus;
    recb_from: Date | undefined;
    recb_to: Date | undefined;
    recb_created_at: Date;
    fi_id: AttachmentItem;
}

export class ReconcileSupplierDebtDto implements IReconcileSupplierDebtDto {
    su_id!: number;
    recb_status!: EReconcileStatus;
    recb_total_money_calculated!: number;
    recb_remain_supplier_debt!: number;
    recb_total_money_reality!: number;
    recb_month!: string | undefined;
    recb_is_deleted!: boolean;
    listReconcileBank!: ReconcileSupplierDebtDetailDto[] | undefined;

    constructor(data?: IReconcileSupplierDebtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.recb_status = _data["recb_status"];
            this.recb_total_money_calculated = _data["recb_total_money_calculated"];
            this.recb_remain_supplier_debt = _data["recb_remain_supplier_debt"];
            this.recb_total_money_reality = _data["recb_total_money_reality"];
            this.recb_month = _data["recb_month"];
            this.recb_is_deleted = _data["recb_is_deleted"];
            if (Array.isArray(_data["listReconcileBank"])) {
                this.listReconcileBank = [] as any;
                for (let item of _data["listReconcileBank"])
                    this.listReconcileBank!.push(ReconcileSupplierDebtDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReconcileSupplierDebtDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileSupplierDebtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["recb_status"] = this.recb_status;
        data["recb_total_money_calculated"] = this.recb_total_money_calculated;
        data["recb_remain_supplier_debt"] = this.recb_remain_supplier_debt;
        data["recb_total_money_reality"] = this.recb_total_money_reality;
        data["recb_month"] = this.recb_month;
        data["recb_is_deleted"] = this.recb_is_deleted;
        if (Array.isArray(this.listReconcileBank)) {
            data["listReconcileBank"] = [];
            for (let item of this.listReconcileBank)
                data["listReconcileBank"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReconcileSupplierDebtDto {
        const json = this.toJSON();
        let result = new ReconcileSupplierDebtDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileSupplierDebtDto {
    su_id: number;
    recb_status: EReconcileStatus;
    recb_total_money_calculated: number;
    recb_remain_supplier_debt: number;
    recb_total_money_reality: number;
    recb_month: string | undefined;
    recb_is_deleted: boolean;
    listReconcileBank: ReconcileSupplierDebtDetailDto[] | undefined;
}

export class ReconcileSupplierDebtDtoPagedResultDto implements IReconcileSupplierDebtDtoPagedResultDto {
    items!: ReconcileSupplierDebtDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReconcileSupplierDebtDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReconcileSupplierDebtDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReconcileSupplierDebtDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileSupplierDebtDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReconcileSupplierDebtDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReconcileSupplierDebtDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReconcileSupplierDebtDtoPagedResultDto {
    items: ReconcileSupplierDebtDto[] | undefined;
    totalCount: number;
}

export class ReconcileSupplierDebtInput implements IReconcileSupplierDebtInput {
    excelReconcileInput!: ExcelReconcileSupplierDebtInput[] | undefined;
    reconcileInput!: ReconcileInput;

    constructor(data?: IReconcileSupplierDebtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["excelReconcileInput"])) {
                this.excelReconcileInput = [] as any;
                for (let item of _data["excelReconcileInput"])
                    this.excelReconcileInput!.push(ExcelReconcileSupplierDebtInput.fromJS(item));
            }
            this.reconcileInput = _data["reconcileInput"] ? ReconcileInput.fromJS(_data["reconcileInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReconcileSupplierDebtInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReconcileSupplierDebtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.excelReconcileInput)) {
            data["excelReconcileInput"] = [];
            for (let item of this.excelReconcileInput)
                data["excelReconcileInput"].push(item.toJSON());
        }
        data["reconcileInput"] = this.reconcileInput ? this.reconcileInput.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReconcileSupplierDebtInput {
        const json = this.toJSON();
        let result = new ReconcileSupplierDebtInput();
        result.init(json);
        return result;
    }
}

export interface IReconcileSupplierDebtInput {
    excelReconcileInput: ExcelReconcileSupplierDebtInput[] | undefined;
    reconcileInput: ReconcileInput;
}

export class Refund implements IRefund {
    id!: number;
    readonly ref_id!: number;
    bi_code!: string | undefined;
    ref_code!: string | undefined;
    ma_id!: number;
    ref_reason_type!: ERefundReasonType;
    ref_refund_type!: BillMethod;
    ref_reason!: string | undefined;
    ref_money!: number;
    ref_namebank!: string | undefined;
    ref_codebank!: string | undefined;
    ref_nameAccountBank!: string | undefined;
    ref_phone!: string | undefined;
    ref_status!: ERefundStatus;
    ref_refund_at!: Date | undefined;
    ref_created_at!: Date;
    fi_id_list!: string | undefined;
    tenantId!: number;
    billing!: Billing;

    constructor(data?: IRefund) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).ref_id = _data["ref_id"];
            this.bi_code = _data["bi_code"];
            this.ref_code = _data["ref_code"];
            this.ma_id = _data["ma_id"];
            this.ref_reason_type = _data["ref_reason_type"];
            this.ref_refund_type = _data["ref_refund_type"];
            this.ref_reason = _data["ref_reason"];
            this.ref_money = _data["ref_money"];
            this.ref_namebank = _data["ref_namebank"];
            this.ref_codebank = _data["ref_codebank"];
            this.ref_nameAccountBank = _data["ref_nameAccountBank"];
            this.ref_phone = _data["ref_phone"];
            this.ref_status = _data["ref_status"];
            this.ref_refund_at = _data["ref_refund_at"] ? new Date(_data["ref_refund_at"].toString()) : <any>undefined;
            this.ref_created_at = _data["ref_created_at"] ? new Date(_data["ref_created_at"].toString()) : <any>undefined;
            this.fi_id_list = _data["fi_id_list"];
            this.tenantId = _data["tenantId"];
            this.billing = _data["billing"] ? Billing.fromJS(_data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Refund {
        data = typeof data === 'object' ? data : {};
        let result = new Refund();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ref_id"] = this.ref_id;
        data["bi_code"] = this.bi_code;
        data["ref_code"] = this.ref_code;
        data["ma_id"] = this.ma_id;
        data["ref_reason_type"] = this.ref_reason_type;
        data["ref_refund_type"] = this.ref_refund_type;
        data["ref_reason"] = this.ref_reason;
        data["ref_money"] = this.ref_money;
        data["ref_namebank"] = this.ref_namebank;
        data["ref_codebank"] = this.ref_codebank;
        data["ref_nameAccountBank"] = this.ref_nameAccountBank;
        data["ref_phone"] = this.ref_phone;
        data["ref_status"] = this.ref_status;
        data["ref_refund_at"] = this.ref_refund_at ? this.ref_refund_at.toISOString() : <any>undefined;
        data["ref_created_at"] = this.ref_created_at ? this.ref_created_at.toISOString() : <any>undefined;
        data["fi_id_list"] = this.fi_id_list;
        data["tenantId"] = this.tenantId;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data;
    }

    clone(): Refund {
        const json = this.toJSON();
        let result = new Refund();
        result.init(json);
        return result;
    }
}

export interface IRefund {
    id: number;
    ref_id: number;
    bi_code: string | undefined;
    ref_code: string | undefined;
    ma_id: number;
    ref_reason_type: ERefundReasonType;
    ref_refund_type: BillMethod;
    ref_reason: string | undefined;
    ref_money: number;
    ref_namebank: string | undefined;
    ref_codebank: string | undefined;
    ref_nameAccountBank: string | undefined;
    ref_phone: string | undefined;
    ref_status: ERefundStatus;
    ref_refund_at: Date | undefined;
    ref_created_at: Date;
    fi_id_list: string | undefined;
    tenantId: number;
    billing: Billing;
}

export class RefundDto implements IRefundDto {
    ref_id!: number;
    ref_money!: number;
    bi_code!: string | undefined;
    ref_code!: string | undefined;
    ma_id!: number;
    ref_reason_type!: ERefundReasonType;
    ref_refund_type!: BillMethod;
    ref_reason!: string | undefined;
    ref_namebank!: string | undefined;
    ref_codebank!: string | undefined;
    ref_nameAccountBank!: string | undefined;
    ref_phone!: string | undefined;
    ref_status!: ERefundStatus;
    ref_refund_at!: Date | undefined;
    ref_created_at!: Date;
    billing!: BillingDto;
    paymentBankDto!: PaymentBankDto;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ref_id = _data["ref_id"];
            this.ref_money = _data["ref_money"];
            this.bi_code = _data["bi_code"];
            this.ref_code = _data["ref_code"];
            this.ma_id = _data["ma_id"];
            this.ref_reason_type = _data["ref_reason_type"];
            this.ref_refund_type = _data["ref_refund_type"];
            this.ref_reason = _data["ref_reason"];
            this.ref_namebank = _data["ref_namebank"];
            this.ref_codebank = _data["ref_codebank"];
            this.ref_nameAccountBank = _data["ref_nameAccountBank"];
            this.ref_phone = _data["ref_phone"];
            this.ref_status = _data["ref_status"];
            this.ref_refund_at = _data["ref_refund_at"] ? new Date(_data["ref_refund_at"].toString()) : <any>undefined;
            this.ref_created_at = _data["ref_created_at"] ? new Date(_data["ref_created_at"].toString()) : <any>undefined;
            this.billing = _data["billing"] ? BillingDto.fromJS(_data["billing"]) : <any>undefined;
            this.paymentBankDto = _data["paymentBankDto"] ? PaymentBankDto.fromJS(_data["paymentBankDto"]) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ref_id"] = this.ref_id;
        data["ref_money"] = this.ref_money;
        data["bi_code"] = this.bi_code;
        data["ref_code"] = this.ref_code;
        data["ma_id"] = this.ma_id;
        data["ref_reason_type"] = this.ref_reason_type;
        data["ref_refund_type"] = this.ref_refund_type;
        data["ref_reason"] = this.ref_reason;
        data["ref_namebank"] = this.ref_namebank;
        data["ref_codebank"] = this.ref_codebank;
        data["ref_nameAccountBank"] = this.ref_nameAccountBank;
        data["ref_phone"] = this.ref_phone;
        data["ref_status"] = this.ref_status;
        data["ref_refund_at"] = this.ref_refund_at ? this.ref_refund_at.toISOString() : <any>undefined;
        data["ref_created_at"] = this.ref_created_at ? this.ref_created_at.toISOString() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["paymentBankDto"] = this.paymentBankDto ? this.paymentBankDto.toJSON() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): RefundDto {
        const json = this.toJSON();
        let result = new RefundDto();
        result.init(json);
        return result;
    }
}

export interface IRefundDto {
    ref_id: number;
    ref_money: number;
    bi_code: string | undefined;
    ref_code: string | undefined;
    ma_id: number;
    ref_reason_type: ERefundReasonType;
    ref_refund_type: BillMethod;
    ref_reason: string | undefined;
    ref_namebank: string | undefined;
    ref_codebank: string | undefined;
    ref_nameAccountBank: string | undefined;
    ref_phone: string | undefined;
    ref_status: ERefundStatus;
    ref_refund_at: Date | undefined;
    ref_created_at: Date;
    billing: BillingDto;
    paymentBankDto: PaymentBankDto;
    fi_id_list: AttachmentItem[] | undefined;
}

export class RefundDtoPagedResultDto implements IRefundDtoPagedResultDto {
    items!: RefundDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRefundDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RefundDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RefundDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefundDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RefundDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RefundDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRefundDtoPagedResultDto {
    items: RefundDto[] | undefined;
    totalCount: number;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterMemberInput implements IRegisterMemberInput {
    me_code!: string | undefined;
    me_name!: string | undefined;
    me_sur_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    emailAddress!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IRegisterMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_code = _data["me_code"];
            this.me_name = _data["me_name"];
            this.me_sur_name = _data["me_sur_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_code"] = this.me_code;
        data["me_name"] = this.me_name;
        data["me_sur_name"] = this.me_sur_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): RegisterMemberInput {
        const json = this.toJSON();
        let result = new RegisterMemberInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterMemberInput {
    me_code: string | undefined;
    me_name: string | undefined;
    me_sur_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    fi_id: AttachmentItem;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class RenameFileInput implements IRenameFileInput {
    fi_id!: number;
    fi_name!: string | undefined;

    constructor(data?: IRenameFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_id = _data["fi_id"];
            this.fi_name = _data["fi_name"];
        }
    }

    static fromJS(data: any): RenameFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_id"] = this.fi_id;
        data["fi_name"] = this.fi_name;
        return data;
    }

    clone(): RenameFileInput {
        const json = this.toJSON();
        let result = new RenameFileInput();
        result.init(json);
        return result;
    }
}

export interface IRenameFileInput {
    fi_id: number;
    fi_name: string | undefined;
}

export class RenameFileMediaInput implements IRenameFileMediaInput {
    fi_me_id!: number;
    fi_me_name!: string | undefined;

    constructor(data?: IRenameFileMediaInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_me_id = _data["fi_me_id"];
            this.fi_me_name = _data["fi_me_name"];
        }
    }

    static fromJS(data: any): RenameFileMediaInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameFileMediaInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_me_id"] = this.fi_me_id;
        data["fi_me_name"] = this.fi_me_name;
        return data;
    }

    clone(): RenameFileMediaInput {
        const json = this.toJSON();
        let result = new RenameFileMediaInput();
        result.init(json);
        return result;
    }
}

export interface IRenameFileMediaInput {
    fi_me_id: number;
    fi_me_name: string | undefined;
}

export class ReportDeviceInput implements IReportDeviceInput {
    deviceID!: string | undefined;
    re_code!: string | undefined;
    re_display!: string | undefined;
    re_level!: ReportLevel;
    bi_code!: string | undefined;

    constructor(data?: IReportDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceID = _data["deviceID"];
            this.re_code = _data["re_code"];
            this.re_display = _data["re_display"];
            this.re_level = _data["re_level"];
            this.bi_code = _data["bi_code"];
        }
    }

    static fromJS(data: any): ReportDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceID"] = this.deviceID;
        data["re_code"] = this.re_code;
        data["re_display"] = this.re_display;
        data["re_level"] = this.re_level;
        data["bi_code"] = this.bi_code;
        return data;
    }

    clone(): ReportDeviceInput {
        const json = this.toJSON();
        let result = new ReportDeviceInput();
        result.init(json);
        return result;
    }
}

export interface IReportDeviceInput {
    deviceID: string | undefined;
    re_code: string | undefined;
    re_display: string | undefined;
    re_level: ReportLevel;
    bi_code: string | undefined;
}

export enum ReportLevel {
    _0 = 0,
    _1 = 1,
}

export class ReportOfMachineDto implements IReportOfMachineDto {
    re_id!: number;
    re_code!: string | undefined;
    re_display!: string | undefined;
    re_note!: string | undefined;
    re_status!: ReportStatus;
    re_level!: ReportLevel;
    ma_id!: number;
    ma_de_id!: number;
    machineDetail!: MachineDetailDto;
    us_id_report!: number;
    bi_code!: string | undefined;
    billing!: BillingDto;
    re_created_at!: Date;
    re_updated_at!: Date;
    reportOfMachineLogs!: ReportOfMachineLogs[] | undefined;

    constructor(data?: IReportOfMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_code = _data["re_code"];
            this.re_display = _data["re_display"];
            this.re_note = _data["re_note"];
            this.re_status = _data["re_status"];
            this.re_level = _data["re_level"];
            this.ma_id = _data["ma_id"];
            this.ma_de_id = _data["ma_de_id"];
            this.machineDetail = _data["machineDetail"] ? MachineDetailDto.fromJS(_data["machineDetail"]) : <any>undefined;
            this.us_id_report = _data["us_id_report"];
            this.bi_code = _data["bi_code"];
            this.billing = _data["billing"] ? BillingDto.fromJS(_data["billing"]) : <any>undefined;
            this.re_created_at = _data["re_created_at"] ? new Date(_data["re_created_at"].toString()) : <any>undefined;
            this.re_updated_at = _data["re_updated_at"] ? new Date(_data["re_updated_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["reportOfMachineLogs"])) {
                this.reportOfMachineLogs = [] as any;
                for (let item of _data["reportOfMachineLogs"])
                    this.reportOfMachineLogs!.push(ReportOfMachineLogs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportOfMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportOfMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_code"] = this.re_code;
        data["re_display"] = this.re_display;
        data["re_note"] = this.re_note;
        data["re_status"] = this.re_status;
        data["re_level"] = this.re_level;
        data["ma_id"] = this.ma_id;
        data["ma_de_id"] = this.ma_de_id;
        data["machineDetail"] = this.machineDetail ? this.machineDetail.toJSON() : <any>undefined;
        data["us_id_report"] = this.us_id_report;
        data["bi_code"] = this.bi_code;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["re_created_at"] = this.re_created_at ? this.re_created_at.toISOString() : <any>undefined;
        data["re_updated_at"] = this.re_updated_at ? this.re_updated_at.toISOString() : <any>undefined;
        if (Array.isArray(this.reportOfMachineLogs)) {
            data["reportOfMachineLogs"] = [];
            for (let item of this.reportOfMachineLogs)
                data["reportOfMachineLogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReportOfMachineDto {
        const json = this.toJSON();
        let result = new ReportOfMachineDto();
        result.init(json);
        return result;
    }
}

export interface IReportOfMachineDto {
    re_id: number;
    re_code: string | undefined;
    re_display: string | undefined;
    re_note: string | undefined;
    re_status: ReportStatus;
    re_level: ReportLevel;
    ma_id: number;
    ma_de_id: number;
    machineDetail: MachineDetailDto;
    us_id_report: number;
    bi_code: string | undefined;
    billing: BillingDto;
    re_created_at: Date;
    re_updated_at: Date;
    reportOfMachineLogs: ReportOfMachineLogs[] | undefined;
}

export class ReportOfMachineDtoPagedResultDto implements IReportOfMachineDtoPagedResultDto {
    items!: ReportOfMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReportOfMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReportOfMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReportOfMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportOfMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReportOfMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReportOfMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReportOfMachineDtoPagedResultDto {
    items: ReportOfMachineDto[] | undefined;
    totalCount: number;
}

export class ReportOfMachineLogs implements IReportOfMachineLogs {
    id!: number;
    readonly re_ma_lo_id!: number;
    re_id!: number;
    re_status!: ReportStatus;
    re_ma_lo_desc!: string | undefined;
    re_ma_lo_created_at!: Date;
    tenantId!: number;

    constructor(data?: IReportOfMachineLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).re_ma_lo_id = _data["re_ma_lo_id"];
            this.re_id = _data["re_id"];
            this.re_status = _data["re_status"];
            this.re_ma_lo_desc = _data["re_ma_lo_desc"];
            this.re_ma_lo_created_at = _data["re_ma_lo_created_at"] ? new Date(_data["re_ma_lo_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ReportOfMachineLogs {
        data = typeof data === 'object' ? data : {};
        let result = new ReportOfMachineLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["re_ma_lo_id"] = this.re_ma_lo_id;
        data["re_id"] = this.re_id;
        data["re_status"] = this.re_status;
        data["re_ma_lo_desc"] = this.re_ma_lo_desc;
        data["re_ma_lo_created_at"] = this.re_ma_lo_created_at ? this.re_ma_lo_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ReportOfMachineLogs {
        const json = this.toJSON();
        let result = new ReportOfMachineLogs();
        result.init(json);
        return result;
    }
}

export interface IReportOfMachineLogs {
    id: number;
    re_ma_lo_id: number;
    re_id: number;
    re_status: ReportStatus;
    re_ma_lo_desc: string | undefined;
    re_ma_lo_created_at: Date;
    tenantId: number;
}

export enum ReportStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Repository implements IRepository {
    id!: number;
    readonly re_id!: number;
    re_parent_id!: number;
    us_id_operator!: number;
    re_type!: ERepositoryType;
    ma_id_arr!: string | undefined;
    re_name!: string | undefined;
    re_code!: string | undefined;
    re_desc!: string | undefined;
    re_is_deleted!: boolean;
    re_created_at!: Date;
    re_updated_at!: Date;
    re_deleted_at!: Date | undefined;
    tenantId!: number;
    repositoryDetails!: RepositoryDetails[] | undefined;
    listTranferRepositories!: TranferRepository[] | undefined;
    listReceiverRepositories!: TranferRepository[] | undefined;
    listImportRepositories!: ImportRepository[] | undefined;
    listLossRepositories!: LossRepository[] | undefined;
    listExportRepository!: ExportRepository[] | undefined;

    constructor(data?: IRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).re_id = _data["re_id"];
            this.re_parent_id = _data["re_parent_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.re_type = _data["re_type"];
            this.ma_id_arr = _data["ma_id_arr"];
            this.re_name = _data["re_name"];
            this.re_code = _data["re_code"];
            this.re_desc = _data["re_desc"];
            this.re_is_deleted = _data["re_is_deleted"];
            this.re_created_at = _data["re_created_at"] ? new Date(_data["re_created_at"].toString()) : <any>undefined;
            this.re_updated_at = _data["re_updated_at"] ? new Date(_data["re_updated_at"].toString()) : <any>undefined;
            this.re_deleted_at = _data["re_deleted_at"] ? new Date(_data["re_deleted_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["repositoryDetails"])) {
                this.repositoryDetails = [] as any;
                for (let item of _data["repositoryDetails"])
                    this.repositoryDetails!.push(RepositoryDetails.fromJS(item));
            }
            if (Array.isArray(_data["listTranferRepositories"])) {
                this.listTranferRepositories = [] as any;
                for (let item of _data["listTranferRepositories"])
                    this.listTranferRepositories!.push(TranferRepository.fromJS(item));
            }
            if (Array.isArray(_data["listReceiverRepositories"])) {
                this.listReceiverRepositories = [] as any;
                for (let item of _data["listReceiverRepositories"])
                    this.listReceiverRepositories!.push(TranferRepository.fromJS(item));
            }
            if (Array.isArray(_data["listImportRepositories"])) {
                this.listImportRepositories = [] as any;
                for (let item of _data["listImportRepositories"])
                    this.listImportRepositories!.push(ImportRepository.fromJS(item));
            }
            if (Array.isArray(_data["listLossRepositories"])) {
                this.listLossRepositories = [] as any;
                for (let item of _data["listLossRepositories"])
                    this.listLossRepositories!.push(LossRepository.fromJS(item));
            }
            if (Array.isArray(_data["listExportRepository"])) {
                this.listExportRepository = [] as any;
                for (let item of _data["listExportRepository"])
                    this.listExportRepository!.push(ExportRepository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Repository {
        data = typeof data === 'object' ? data : {};
        let result = new Repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["re_id"] = this.re_id;
        data["re_parent_id"] = this.re_parent_id;
        data["us_id_operator"] = this.us_id_operator;
        data["re_type"] = this.re_type;
        data["ma_id_arr"] = this.ma_id_arr;
        data["re_name"] = this.re_name;
        data["re_code"] = this.re_code;
        data["re_desc"] = this.re_desc;
        data["re_is_deleted"] = this.re_is_deleted;
        data["re_created_at"] = this.re_created_at ? this.re_created_at.toISOString() : <any>undefined;
        data["re_updated_at"] = this.re_updated_at ? this.re_updated_at.toISOString() : <any>undefined;
        data["re_deleted_at"] = this.re_deleted_at ? this.re_deleted_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.repositoryDetails)) {
            data["repositoryDetails"] = [];
            for (let item of this.repositoryDetails)
                data["repositoryDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.listTranferRepositories)) {
            data["listTranferRepositories"] = [];
            for (let item of this.listTranferRepositories)
                data["listTranferRepositories"].push(item.toJSON());
        }
        if (Array.isArray(this.listReceiverRepositories)) {
            data["listReceiverRepositories"] = [];
            for (let item of this.listReceiverRepositories)
                data["listReceiverRepositories"].push(item.toJSON());
        }
        if (Array.isArray(this.listImportRepositories)) {
            data["listImportRepositories"] = [];
            for (let item of this.listImportRepositories)
                data["listImportRepositories"].push(item.toJSON());
        }
        if (Array.isArray(this.listLossRepositories)) {
            data["listLossRepositories"] = [];
            for (let item of this.listLossRepositories)
                data["listLossRepositories"].push(item.toJSON());
        }
        if (Array.isArray(this.listExportRepository)) {
            data["listExportRepository"] = [];
            for (let item of this.listExportRepository)
                data["listExportRepository"].push(item.toJSON());
        }
        return data;
    }

    clone(): Repository {
        const json = this.toJSON();
        let result = new Repository();
        result.init(json);
        return result;
    }
}

export interface IRepository {
    id: number;
    re_id: number;
    re_parent_id: number;
    us_id_operator: number;
    re_type: ERepositoryType;
    ma_id_arr: string | undefined;
    re_name: string | undefined;
    re_code: string | undefined;
    re_desc: string | undefined;
    re_is_deleted: boolean;
    re_created_at: Date;
    re_updated_at: Date;
    re_deleted_at: Date | undefined;
    tenantId: number;
    repositoryDetails: RepositoryDetails[] | undefined;
    listTranferRepositories: TranferRepository[] | undefined;
    listReceiverRepositories: TranferRepository[] | undefined;
    listImportRepositories: ImportRepository[] | undefined;
    listLossRepositories: LossRepository[] | undefined;
    listExportRepository: ExportRepository[] | undefined;
}

export class RepositoryAbstractDto implements IRepositoryAbstractDto {
    re_id!: number;
    re_parent_id!: number;
    re_name!: string | undefined;
    re_code!: string | undefined;
    re_is_deleted!: boolean;

    constructor(data?: IRepositoryAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_parent_id = _data["re_parent_id"];
            this.re_name = _data["re_name"];
            this.re_code = _data["re_code"];
            this.re_is_deleted = _data["re_is_deleted"];
        }
    }

    static fromJS(data: any): RepositoryAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_parent_id"] = this.re_parent_id;
        data["re_name"] = this.re_name;
        data["re_code"] = this.re_code;
        data["re_is_deleted"] = this.re_is_deleted;
        return data;
    }

    clone(): RepositoryAbstractDto {
        const json = this.toJSON();
        let result = new RepositoryAbstractDto();
        result.init(json);
        return result;
    }
}

export interface IRepositoryAbstractDto {
    re_id: number;
    re_parent_id: number;
    re_name: string | undefined;
    re_code: string | undefined;
    re_is_deleted: boolean;
}

export class RepositoryDetailDto implements IRepositoryDetailDto {
    re_de_id!: number;
    pr_id!: number;
    pr_quantity!: number;
    pr_quantity_quydoi!: number;
    pr_total_quantity_quydoi!: number;
    pr_unit_quydoi!: string | undefined;
    pr_price!: number;
    re_de_product_status!: ERepositoryProductStatus;
    re_de_created_at!: Date;
    re_de_updated_at!: Date;
    product!: ProductDto;
    repositoryLogs!: RepositoryLogs[] | undefined;

    constructor(data?: IRepositoryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_de_id = _data["re_de_id"];
            this.pr_id = _data["pr_id"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_quantity_quydoi = _data["pr_quantity_quydoi"];
            this.pr_total_quantity_quydoi = _data["pr_total_quantity_quydoi"];
            this.pr_unit_quydoi = _data["pr_unit_quydoi"];
            this.pr_price = _data["pr_price"];
            this.re_de_product_status = _data["re_de_product_status"];
            this.re_de_created_at = _data["re_de_created_at"] ? new Date(_data["re_de_created_at"].toString()) : <any>undefined;
            this.re_de_updated_at = _data["re_de_updated_at"] ? new Date(_data["re_de_updated_at"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["repositoryLogs"])) {
                this.repositoryLogs = [] as any;
                for (let item of _data["repositoryLogs"])
                    this.repositoryLogs!.push(RepositoryLogs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RepositoryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_de_id"] = this.re_de_id;
        data["pr_id"] = this.pr_id;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_quantity_quydoi"] = this.pr_quantity_quydoi;
        data["pr_total_quantity_quydoi"] = this.pr_total_quantity_quydoi;
        data["pr_unit_quydoi"] = this.pr_unit_quydoi;
        data["pr_price"] = this.pr_price;
        data["re_de_product_status"] = this.re_de_product_status;
        data["re_de_created_at"] = this.re_de_created_at ? this.re_de_created_at.toISOString() : <any>undefined;
        data["re_de_updated_at"] = this.re_de_updated_at ? this.re_de_updated_at.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.repositoryLogs)) {
            data["repositoryLogs"] = [];
            for (let item of this.repositoryLogs)
                data["repositoryLogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): RepositoryDetailDto {
        const json = this.toJSON();
        let result = new RepositoryDetailDto();
        result.init(json);
        return result;
    }
}

export interface IRepositoryDetailDto {
    re_de_id: number;
    pr_id: number;
    pr_quantity: number;
    pr_quantity_quydoi: number;
    pr_total_quantity_quydoi: number;
    pr_unit_quydoi: string | undefined;
    pr_price: number;
    re_de_product_status: ERepositoryProductStatus;
    re_de_created_at: Date;
    re_de_updated_at: Date;
    product: ProductDto;
    repositoryLogs: RepositoryLogs[] | undefined;
}

export class RepositoryDetailDtoPagedResultDto implements IRepositoryDetailDtoPagedResultDto {
    items!: RepositoryDetailDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRepositoryDetailDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RepositoryDetailDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RepositoryDetailDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryDetailDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RepositoryDetailDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RepositoryDetailDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRepositoryDetailDtoPagedResultDto {
    items: RepositoryDetailDto[] | undefined;
    totalCount: number;
}

export class RepositoryDetails implements IRepositoryDetails {
    id!: number;
    readonly re_de_id!: number;
    re_id!: number;
    pr_id!: number;
    pr_quantity!: number;
    pr_quantity_quydoi!: number;
    pr_total_quantity_quydoi!: number;
    pr_unit_quydoi!: string | undefined;
    pr_price!: number;
    re_de_product_status!: ERepositoryProductStatus;
    re_de_created_at!: Date;
    re_de_updated_at!: Date;
    tenantId!: number;
    repositoryLogs!: RepositoryLogs[] | undefined;
    product!: Product;

    constructor(data?: IRepositoryDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).re_de_id = _data["re_de_id"];
            this.re_id = _data["re_id"];
            this.pr_id = _data["pr_id"];
            this.pr_quantity = _data["pr_quantity"];
            this.pr_quantity_quydoi = _data["pr_quantity_quydoi"];
            this.pr_total_quantity_quydoi = _data["pr_total_quantity_quydoi"];
            this.pr_unit_quydoi = _data["pr_unit_quydoi"];
            this.pr_price = _data["pr_price"];
            this.re_de_product_status = _data["re_de_product_status"];
            this.re_de_created_at = _data["re_de_created_at"] ? new Date(_data["re_de_created_at"].toString()) : <any>undefined;
            this.re_de_updated_at = _data["re_de_updated_at"] ? new Date(_data["re_de_updated_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["repositoryLogs"])) {
                this.repositoryLogs = [] as any;
                for (let item of _data["repositoryLogs"])
                    this.repositoryLogs!.push(RepositoryLogs.fromJS(item));
            }
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RepositoryDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["re_de_id"] = this.re_de_id;
        data["re_id"] = this.re_id;
        data["pr_id"] = this.pr_id;
        data["pr_quantity"] = this.pr_quantity;
        data["pr_quantity_quydoi"] = this.pr_quantity_quydoi;
        data["pr_total_quantity_quydoi"] = this.pr_total_quantity_quydoi;
        data["pr_unit_quydoi"] = this.pr_unit_quydoi;
        data["pr_price"] = this.pr_price;
        data["re_de_product_status"] = this.re_de_product_status;
        data["re_de_created_at"] = this.re_de_created_at ? this.re_de_created_at.toISOString() : <any>undefined;
        data["re_de_updated_at"] = this.re_de_updated_at ? this.re_de_updated_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.repositoryLogs)) {
            data["repositoryLogs"] = [];
            for (let item of this.repositoryLogs)
                data["repositoryLogs"].push(item.toJSON());
        }
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }

    clone(): RepositoryDetails {
        const json = this.toJSON();
        let result = new RepositoryDetails();
        result.init(json);
        return result;
    }
}

export interface IRepositoryDetails {
    id: number;
    re_de_id: number;
    re_id: number;
    pr_id: number;
    pr_quantity: number;
    pr_quantity_quydoi: number;
    pr_total_quantity_quydoi: number;
    pr_unit_quydoi: string | undefined;
    pr_price: number;
    re_de_product_status: ERepositoryProductStatus;
    re_de_created_at: Date;
    re_de_updated_at: Date;
    tenantId: number;
    repositoryLogs: RepositoryLogs[] | undefined;
    product: Product;
}

export class RepositoryDto implements IRepositoryDto {
    re_id!: number;
    gr_ma_id!: number;
    us_id_operator!: number;
    re_type!: ERepositoryType;
    re_parent_id!: number;
    re_name!: string | undefined;
    re_code!: string | undefined;
    re_desc!: string | undefined;
    so_luong_mat_hang!: number;
    so_luong_san_pham_trong_kho!: number;
    so_luong_san_pham_sap_het_hang!: number;
    so_luong_san_pham_het_hang!: number;
    re_created_at!: Date;
    re_updated_at!: Date;
    ma_id_arr!: number[] | undefined;
    re_is_deleted!: boolean;
    repositoryDetails!: RepositoryDetailDto[] | undefined;
    listExportRepositoryDto!: ExportRepositoryDto[] | undefined;
    listReceiverRepositoriesDto!: TranferRepositoryDto[] | undefined;

    constructor(data?: IRepositoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.re_type = _data["re_type"];
            this.re_parent_id = _data["re_parent_id"];
            this.re_name = _data["re_name"];
            this.re_code = _data["re_code"];
            this.re_desc = _data["re_desc"];
            this.so_luong_mat_hang = _data["so_luong_mat_hang"];
            this.so_luong_san_pham_trong_kho = _data["so_luong_san_pham_trong_kho"];
            this.so_luong_san_pham_sap_het_hang = _data["so_luong_san_pham_sap_het_hang"];
            this.so_luong_san_pham_het_hang = _data["so_luong_san_pham_het_hang"];
            this.re_created_at = _data["re_created_at"] ? new Date(_data["re_created_at"].toString()) : <any>undefined;
            this.re_updated_at = _data["re_updated_at"] ? new Date(_data["re_updated_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["ma_id_arr"])) {
                this.ma_id_arr = [] as any;
                for (let item of _data["ma_id_arr"])
                    this.ma_id_arr!.push(item);
            }
            this.re_is_deleted = _data["re_is_deleted"];
            if (Array.isArray(_data["repositoryDetails"])) {
                this.repositoryDetails = [] as any;
                for (let item of _data["repositoryDetails"])
                    this.repositoryDetails!.push(RepositoryDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["listExportRepositoryDto"])) {
                this.listExportRepositoryDto = [] as any;
                for (let item of _data["listExportRepositoryDto"])
                    this.listExportRepositoryDto!.push(ExportRepositoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listReceiverRepositoriesDto"])) {
                this.listReceiverRepositoriesDto = [] as any;
                for (let item of _data["listReceiverRepositoriesDto"])
                    this.listReceiverRepositoriesDto!.push(TranferRepositoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RepositoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["us_id_operator"] = this.us_id_operator;
        data["re_type"] = this.re_type;
        data["re_parent_id"] = this.re_parent_id;
        data["re_name"] = this.re_name;
        data["re_code"] = this.re_code;
        data["re_desc"] = this.re_desc;
        data["so_luong_mat_hang"] = this.so_luong_mat_hang;
        data["so_luong_san_pham_trong_kho"] = this.so_luong_san_pham_trong_kho;
        data["so_luong_san_pham_sap_het_hang"] = this.so_luong_san_pham_sap_het_hang;
        data["so_luong_san_pham_het_hang"] = this.so_luong_san_pham_het_hang;
        data["re_created_at"] = this.re_created_at ? this.re_created_at.toISOString() : <any>undefined;
        data["re_updated_at"] = this.re_updated_at ? this.re_updated_at.toISOString() : <any>undefined;
        if (Array.isArray(this.ma_id_arr)) {
            data["ma_id_arr"] = [];
            for (let item of this.ma_id_arr)
                data["ma_id_arr"].push(item);
        }
        data["re_is_deleted"] = this.re_is_deleted;
        if (Array.isArray(this.repositoryDetails)) {
            data["repositoryDetails"] = [];
            for (let item of this.repositoryDetails)
                data["repositoryDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.listExportRepositoryDto)) {
            data["listExportRepositoryDto"] = [];
            for (let item of this.listExportRepositoryDto)
                data["listExportRepositoryDto"].push(item.toJSON());
        }
        if (Array.isArray(this.listReceiverRepositoriesDto)) {
            data["listReceiverRepositoriesDto"] = [];
            for (let item of this.listReceiverRepositoriesDto)
                data["listReceiverRepositoriesDto"].push(item.toJSON());
        }
        return data;
    }

    clone(): RepositoryDto {
        const json = this.toJSON();
        let result = new RepositoryDto();
        result.init(json);
        return result;
    }
}

export interface IRepositoryDto {
    re_id: number;
    gr_ma_id: number;
    us_id_operator: number;
    re_type: ERepositoryType;
    re_parent_id: number;
    re_name: string | undefined;
    re_code: string | undefined;
    re_desc: string | undefined;
    so_luong_mat_hang: number;
    so_luong_san_pham_trong_kho: number;
    so_luong_san_pham_sap_het_hang: number;
    so_luong_san_pham_het_hang: number;
    re_created_at: Date;
    re_updated_at: Date;
    ma_id_arr: number[] | undefined;
    re_is_deleted: boolean;
    repositoryDetails: RepositoryDetailDto[] | undefined;
    listExportRepositoryDto: ExportRepositoryDto[] | undefined;
    listReceiverRepositoriesDto: TranferRepositoryDto[] | undefined;
}

export class RepositoryDtoPagedResultDto implements IRepositoryDtoPagedResultDto {
    items!: RepositoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRepositoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RepositoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RepositoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RepositoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RepositoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRepositoryDtoPagedResultDto {
    items: RepositoryDto[] | undefined;
    totalCount: number;
}

export class RepositoryLogs implements IRepositoryLogs {
    id!: number;
    readonly re_lo_id!: number;
    re_de_id!: number;
    re_lo_quantity!: number;
    re_lo_quantityInRepository!: number;
    re_lo_action!: ERepositoryLogAction;
    re_lo_desc!: string | undefined;
    re_lo_created_at!: Date;
    tenantId!: number;

    constructor(data?: IRepositoryLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).re_lo_id = _data["re_lo_id"];
            this.re_de_id = _data["re_de_id"];
            this.re_lo_quantity = _data["re_lo_quantity"];
            this.re_lo_quantityInRepository = _data["re_lo_quantityInRepository"];
            this.re_lo_action = _data["re_lo_action"];
            this.re_lo_desc = _data["re_lo_desc"];
            this.re_lo_created_at = _data["re_lo_created_at"] ? new Date(_data["re_lo_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): RepositoryLogs {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["re_lo_id"] = this.re_lo_id;
        data["re_de_id"] = this.re_de_id;
        data["re_lo_quantity"] = this.re_lo_quantity;
        data["re_lo_quantityInRepository"] = this.re_lo_quantityInRepository;
        data["re_lo_action"] = this.re_lo_action;
        data["re_lo_desc"] = this.re_lo_desc;
        data["re_lo_created_at"] = this.re_lo_created_at ? this.re_lo_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): RepositoryLogs {
        const json = this.toJSON();
        let result = new RepositoryLogs();
        result.init(json);
        return result;
    }
}

export interface IRepositoryLogs {
    id: number;
    re_lo_id: number;
    re_de_id: number;
    re_lo_quantity: number;
    re_lo_quantityInRepository: number;
    re_lo_action: ERepositoryLogAction;
    re_lo_desc: string | undefined;
    re_lo_created_at: Date;
    tenantId: number;
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId!: number;
    newPassword!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    userId: number;
    newPassword: string;
}

export class RfidDto implements IRfidDto {
    rf_id!: number;
    rf_code!: string | undefined;
    us_id_owner!: number;
    rf_money_current!: number;
    rf_money_current_sale!: number;
    rf_is_active!: boolean;
    rf_type_drink_payment!: RFIDTypeDrinkPayment;
    rf_created_at!: Date;

    constructor(data?: IRfidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_id = _data["rf_id"];
            this.rf_code = _data["rf_code"];
            this.us_id_owner = _data["us_id_owner"];
            this.rf_money_current = _data["rf_money_current"];
            this.rf_money_current_sale = _data["rf_money_current_sale"];
            this.rf_is_active = _data["rf_is_active"];
            this.rf_type_drink_payment = _data["rf_type_drink_payment"];
            this.rf_created_at = _data["rf_created_at"] ? new Date(_data["rf_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RfidDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_id"] = this.rf_id;
        data["rf_code"] = this.rf_code;
        data["us_id_owner"] = this.us_id_owner;
        data["rf_money_current"] = this.rf_money_current;
        data["rf_money_current_sale"] = this.rf_money_current_sale;
        data["rf_is_active"] = this.rf_is_active;
        data["rf_type_drink_payment"] = this.rf_type_drink_payment;
        data["rf_created_at"] = this.rf_created_at ? this.rf_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): RfidDto {
        const json = this.toJSON();
        let result = new RfidDto();
        result.init(json);
        return result;
    }
}

export interface IRfidDto {
    rf_id: number;
    rf_code: string | undefined;
    us_id_owner: number;
    rf_money_current: number;
    rf_money_current_sale: number;
    rf_is_active: boolean;
    rf_type_drink_payment: RFIDTypeDrinkPayment;
    rf_created_at: Date;
}

export class RfidDtoPagedResultDto implements IRfidDtoPagedResultDto {
    items!: RfidDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRfidDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RfidDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RfidDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RfidDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RfidDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRfidDtoPagedResultDto {
    items: RfidDto[] | undefined;
    totalCount: number;
}

export class RfidLogDto implements IRfidLogDto {
    rf_lo_id!: number;
    rf_code!: string | undefined;
    ma_id!: number;
    us_id!: number;
    rf_lo_action!: ERIFDAction;
    rf_lo_money!: number;
    rf_lo_content!: string | undefined;
    bi_paid_status!: EPaidStatus;
    rf_lo_created_at!: Date;
    rf_reconcile_status!: EBillReconcileStatus;
    rf_reconcile_reason!: string | undefined;
    rf_reconcile_at!: Date | undefined;

    constructor(data?: IRfidLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_lo_id = _data["rf_lo_id"];
            this.rf_code = _data["rf_code"];
            this.ma_id = _data["ma_id"];
            this.us_id = _data["us_id"];
            this.rf_lo_action = _data["rf_lo_action"];
            this.rf_lo_money = _data["rf_lo_money"];
            this.rf_lo_content = _data["rf_lo_content"];
            this.bi_paid_status = _data["bi_paid_status"];
            this.rf_lo_created_at = _data["rf_lo_created_at"] ? new Date(_data["rf_lo_created_at"].toString()) : <any>undefined;
            this.rf_reconcile_status = _data["rf_reconcile_status"];
            this.rf_reconcile_reason = _data["rf_reconcile_reason"];
            this.rf_reconcile_at = _data["rf_reconcile_at"] ? new Date(_data["rf_reconcile_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RfidLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_lo_id"] = this.rf_lo_id;
        data["rf_code"] = this.rf_code;
        data["ma_id"] = this.ma_id;
        data["us_id"] = this.us_id;
        data["rf_lo_action"] = this.rf_lo_action;
        data["rf_lo_money"] = this.rf_lo_money;
        data["rf_lo_content"] = this.rf_lo_content;
        data["bi_paid_status"] = this.bi_paid_status;
        data["rf_lo_created_at"] = this.rf_lo_created_at ? this.rf_lo_created_at.toISOString() : <any>undefined;
        data["rf_reconcile_status"] = this.rf_reconcile_status;
        data["rf_reconcile_reason"] = this.rf_reconcile_reason;
        data["rf_reconcile_at"] = this.rf_reconcile_at ? this.rf_reconcile_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): RfidLogDto {
        const json = this.toJSON();
        let result = new RfidLogDto();
        result.init(json);
        return result;
    }
}

export interface IRfidLogDto {
    rf_lo_id: number;
    rf_code: string | undefined;
    ma_id: number;
    us_id: number;
    rf_lo_action: ERIFDAction;
    rf_lo_money: number;
    rf_lo_content: string | undefined;
    bi_paid_status: EPaidStatus;
    rf_lo_created_at: Date;
    rf_reconcile_status: EBillReconcileStatus;
    rf_reconcile_reason: string | undefined;
    rf_reconcile_at: Date | undefined;
}

export class RfidLogDtoPagedResultDto implements IRfidLogDtoPagedResultDto {
    items!: RfidLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRfidLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RfidLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RfidLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RfidLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RfidLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRfidLogDtoPagedResultDto {
    items: RfidLogDto[] | undefined;
    totalCount: number;
}

export class RoleDto implements IRoleDto {
    id!: number;
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    isDefault!: boolean;
    isStatic!: boolean;
    grantedPermissions!: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    isStatic: boolean;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items!: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items!: RoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number;
    name!: string;
    displayName!: string;
    description!: string | undefined;
    isStatic!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: Date;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: Date;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value!: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeFieldHandle {
        const json = this.toJSON();
        let result = new RuntimeFieldHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeFieldHandle {
    value: IntPtr;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value!: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeMethodHandle {
        const json = this.toJSON();
        let result = new RuntimeMethodHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeMethodHandle {
    value: IntPtr;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value!: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeTypeHandle {
        const json = this.toJSON();
        let result = new RuntimeTypeHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeTypeHandle {
    value: IntPtr;
}

export enum SORT {
    _1 = 1,
    _2 = 2,
}

export class SafeWaitHandle implements ISafeWaitHandle {
    readonly isClosed!: boolean;
    readonly isInvalid!: boolean;

    constructor(data?: ISafeWaitHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isClosed = _data["isClosed"];
            (<any>this).isInvalid = _data["isInvalid"];
        }
    }

    static fromJS(data: any): SafeWaitHandle {
        data = typeof data === 'object' ? data : {};
        let result = new SafeWaitHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClosed"] = this.isClosed;
        data["isInvalid"] = this.isInvalid;
        return data;
    }

    clone(): SafeWaitHandle {
        const json = this.toJSON();
        let result = new SafeWaitHandle();
        result.init(json);
        return result;
    }
}

export interface ISafeWaitHandle {
    isClosed: boolean;
    isInvalid: boolean;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        return data;
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class SoLuongXuatTheoMay implements ISoLuongXuatTheoMay {
    idMay!: number;
    tenMay!: string | undefined;
    maMay!: string | undefined;
    soLuong!: number;

    constructor(data?: ISoLuongXuatTheoMay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMay = _data["idMay"];
            this.tenMay = _data["tenMay"];
            this.maMay = _data["maMay"];
            this.soLuong = _data["soLuong"];
        }
    }

    static fromJS(data: any): SoLuongXuatTheoMay {
        data = typeof data === 'object' ? data : {};
        let result = new SoLuongXuatTheoMay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMay"] = this.idMay;
        data["tenMay"] = this.tenMay;
        data["maMay"] = this.maMay;
        data["soLuong"] = this.soLuong;
        return data;
    }

    clone(): SoLuongXuatTheoMay {
        const json = this.toJSON();
        let result = new SoLuongXuatTheoMay();
        result.init(json);
        return result;
    }
}

export interface ISoLuongXuatTheoMay {
    idMay: number;
    tenMay: string | undefined;
    maMay: string | undefined;
    soLuong: number;
}

export class StatisticBillingOfMachineDto implements IStatisticBillingOfMachineDto {
    key!: string | undefined;
    nameMachine!: string | undefined;
    machineCode!: string | undefined;
    groupMachineName!: string | undefined;
    us_id_operator!: number;
    totalQuantity!: number;
    totalMoney!: number;
    totalMoneyProduct!: number;
    totalMoneyRefund!: number;
    totalMoneySwallow!: number;
    moneyTransaction!: number;
    moneyRFID!: number;
    moneyCash!: number;
    moneyPromo!: number;
    moneyMomo!: number;
    moneyVNPAY!: number;
    moneyError!: number;
    cash_count!: number;
    transaction_count!: number;
    rfid_count!: number;
    promo_count!: number;
    momo_count!: number;
    vnpay_count!: number;
    error_count!: number;

    constructor(data?: IStatisticBillingOfMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.nameMachine = _data["nameMachine"];
            this.machineCode = _data["machineCode"];
            this.groupMachineName = _data["groupMachineName"];
            this.us_id_operator = _data["us_id_operator"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalMoney = _data["totalMoney"];
            this.totalMoneyProduct = _data["totalMoneyProduct"];
            this.totalMoneyRefund = _data["totalMoneyRefund"];
            this.totalMoneySwallow = _data["totalMoneySwallow"];
            this.moneyTransaction = _data["moneyTransaction"];
            this.moneyRFID = _data["moneyRFID"];
            this.moneyCash = _data["moneyCash"];
            this.moneyPromo = _data["moneyPromo"];
            this.moneyMomo = _data["moneyMomo"];
            this.moneyVNPAY = _data["moneyVNPAY"];
            this.moneyError = _data["moneyError"];
            this.cash_count = _data["cash_count"];
            this.transaction_count = _data["transaction_count"];
            this.rfid_count = _data["rfid_count"];
            this.promo_count = _data["promo_count"];
            this.momo_count = _data["momo_count"];
            this.vnpay_count = _data["vnpay_count"];
            this.error_count = _data["error_count"];
        }
    }

    static fromJS(data: any): StatisticBillingOfMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["nameMachine"] = this.nameMachine;
        data["machineCode"] = this.machineCode;
        data["groupMachineName"] = this.groupMachineName;
        data["us_id_operator"] = this.us_id_operator;
        data["totalQuantity"] = this.totalQuantity;
        data["totalMoney"] = this.totalMoney;
        data["totalMoneyProduct"] = this.totalMoneyProduct;
        data["totalMoneyRefund"] = this.totalMoneyRefund;
        data["totalMoneySwallow"] = this.totalMoneySwallow;
        data["moneyTransaction"] = this.moneyTransaction;
        data["moneyRFID"] = this.moneyRFID;
        data["moneyCash"] = this.moneyCash;
        data["moneyPromo"] = this.moneyPromo;
        data["moneyMomo"] = this.moneyMomo;
        data["moneyVNPAY"] = this.moneyVNPAY;
        data["moneyError"] = this.moneyError;
        data["cash_count"] = this.cash_count;
        data["transaction_count"] = this.transaction_count;
        data["rfid_count"] = this.rfid_count;
        data["promo_count"] = this.promo_count;
        data["momo_count"] = this.momo_count;
        data["vnpay_count"] = this.vnpay_count;
        data["error_count"] = this.error_count;
        return data;
    }

    clone(): StatisticBillingOfMachineDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfMachineDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfMachineDto {
    key: string | undefined;
    nameMachine: string | undefined;
    machineCode: string | undefined;
    groupMachineName: string | undefined;
    us_id_operator: number;
    totalQuantity: number;
    totalMoney: number;
    totalMoneyProduct: number;
    totalMoneyRefund: number;
    totalMoneySwallow: number;
    moneyTransaction: number;
    moneyRFID: number;
    moneyCash: number;
    moneyPromo: number;
    moneyMomo: number;
    moneyVNPAY: number;
    moneyError: number;
    cash_count: number;
    transaction_count: number;
    rfid_count: number;
    promo_count: number;
    momo_count: number;
    vnpay_count: number;
    error_count: number;
}

export class StatisticBillingOfMachineDtoPagedResultDto implements IStatisticBillingOfMachineDtoPagedResultDto {
    items!: StatisticBillingOfMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IStatisticBillingOfMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBillingOfMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StatisticBillingOfMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StatisticBillingOfMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfMachineDtoPagedResultDto {
    items: StatisticBillingOfMachineDto[] | undefined;
    totalCount: number;
}

export class StatisticBillingOfPaymentDto implements IStatisticBillingOfPaymentDto {
    paymentType!: BillMethod;
    name!: string | undefined;
    quantity!: number;
    total_value!: number;

    constructor(data?: IStatisticBillingOfPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentType = _data["paymentType"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.total_value = _data["total_value"];
        }
    }

    static fromJS(data: any): StatisticBillingOfPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentType"] = this.paymentType;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["total_value"] = this.total_value;
        return data;
    }

    clone(): StatisticBillingOfPaymentDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfPaymentDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfPaymentDto {
    paymentType: BillMethod;
    name: string | undefined;
    quantity: number;
    total_value: number;
}

export class StatisticBillingOfProductDto implements IStatisticBillingOfProductDto {
    key!: string | undefined;
    productname!: string | undefined;
    productprice!: number;
    moneyQr!: number;
    moneyRFID!: number;
    moneyPromo!: number;
    moneyMomo!: number;
    moneyVNPAY!: number;
    moneyError!: number;
    cash!: number;
    promo_quantity!: number;
    momo_quantity!: number;
    vnpay_quantity!: number;
    error_quantity!: number;
    cash_quantity!: number;
    qr_quantity!: number;
    rfid_quantity!: number;
    totalQuantity!: number;
    totalMoney!: number;

    constructor(data?: IStatisticBillingOfProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.productname = _data["productname"];
            this.productprice = _data["productprice"];
            this.moneyQr = _data["moneyQr"];
            this.moneyRFID = _data["moneyRFID"];
            this.moneyPromo = _data["moneyPromo"];
            this.moneyMomo = _data["moneyMomo"];
            this.moneyVNPAY = _data["moneyVNPAY"];
            this.moneyError = _data["moneyError"];
            this.cash = _data["cash"];
            this.promo_quantity = _data["promo_quantity"];
            this.momo_quantity = _data["momo_quantity"];
            this.vnpay_quantity = _data["vnpay_quantity"];
            this.error_quantity = _data["error_quantity"];
            this.cash_quantity = _data["cash_quantity"];
            this.qr_quantity = _data["qr_quantity"];
            this.rfid_quantity = _data["rfid_quantity"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalMoney = _data["totalMoney"];
        }
    }

    static fromJS(data: any): StatisticBillingOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["productname"] = this.productname;
        data["productprice"] = this.productprice;
        data["moneyQr"] = this.moneyQr;
        data["moneyRFID"] = this.moneyRFID;
        data["moneyPromo"] = this.moneyPromo;
        data["moneyMomo"] = this.moneyMomo;
        data["moneyVNPAY"] = this.moneyVNPAY;
        data["moneyError"] = this.moneyError;
        data["cash"] = this.cash;
        data["promo_quantity"] = this.promo_quantity;
        data["momo_quantity"] = this.momo_quantity;
        data["vnpay_quantity"] = this.vnpay_quantity;
        data["error_quantity"] = this.error_quantity;
        data["cash_quantity"] = this.cash_quantity;
        data["qr_quantity"] = this.qr_quantity;
        data["rfid_quantity"] = this.rfid_quantity;
        data["totalQuantity"] = this.totalQuantity;
        data["totalMoney"] = this.totalMoney;
        return data;
    }

    clone(): StatisticBillingOfProductDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfProductDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfProductDto {
    key: string | undefined;
    productname: string | undefined;
    productprice: number;
    moneyQr: number;
    moneyRFID: number;
    moneyPromo: number;
    moneyMomo: number;
    moneyVNPAY: number;
    moneyError: number;
    cash: number;
    promo_quantity: number;
    momo_quantity: number;
    vnpay_quantity: number;
    error_quantity: number;
    cash_quantity: number;
    qr_quantity: number;
    rfid_quantity: number;
    totalQuantity: number;
    totalMoney: number;
}

export class StatisticBillingOfProductDtoPagedResultDto implements IStatisticBillingOfProductDtoPagedResultDto {
    items!: StatisticBillingOfProductDto[] | undefined;
    totalCount!: number;

    constructor(data?: IStatisticBillingOfProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBillingOfProductDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StatisticBillingOfProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StatisticBillingOfProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfProductDtoPagedResultDto {
    items: StatisticBillingOfProductDto[] | undefined;
    totalCount: number;
}

export class StatisticBillingOfProductWithMachineDto implements IStatisticBillingOfProductWithMachineDto {
    key!: string | undefined;
    groupMachineName!: string | undefined;
    machineName!: string | undefined;
    machineCode!: string | undefined;
    us_id_owner!: number;
    productname!: string | undefined;
    moneyQr!: number;
    moneyRFID!: number;
    cash!: number;
    cash_count!: number;
    qr_count!: number;
    rfid_count!: number;
    totalQuantity!: number;
    totalMoney!: number;

    constructor(data?: IStatisticBillingOfProductWithMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.groupMachineName = _data["groupMachineName"];
            this.machineName = _data["machineName"];
            this.machineCode = _data["machineCode"];
            this.us_id_owner = _data["us_id_owner"];
            this.productname = _data["productname"];
            this.moneyQr = _data["moneyQr"];
            this.moneyRFID = _data["moneyRFID"];
            this.cash = _data["cash"];
            this.cash_count = _data["cash_count"];
            this.qr_count = _data["qr_count"];
            this.rfid_count = _data["rfid_count"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalMoney = _data["totalMoney"];
        }
    }

    static fromJS(data: any): StatisticBillingOfProductWithMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfProductWithMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["groupMachineName"] = this.groupMachineName;
        data["machineName"] = this.machineName;
        data["machineCode"] = this.machineCode;
        data["us_id_owner"] = this.us_id_owner;
        data["productname"] = this.productname;
        data["moneyQr"] = this.moneyQr;
        data["moneyRFID"] = this.moneyRFID;
        data["cash"] = this.cash;
        data["cash_count"] = this.cash_count;
        data["qr_count"] = this.qr_count;
        data["rfid_count"] = this.rfid_count;
        data["totalQuantity"] = this.totalQuantity;
        data["totalMoney"] = this.totalMoney;
        return data;
    }

    clone(): StatisticBillingOfProductWithMachineDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfProductWithMachineDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfProductWithMachineDto {
    key: string | undefined;
    groupMachineName: string | undefined;
    machineName: string | undefined;
    machineCode: string | undefined;
    us_id_owner: number;
    productname: string | undefined;
    moneyQr: number;
    moneyRFID: number;
    cash: number;
    cash_count: number;
    qr_count: number;
    rfid_count: number;
    totalQuantity: number;
    totalMoney: number;
}

export class StatisticBillingOfProductWithMachineDtoPagedResultDto implements IStatisticBillingOfProductWithMachineDtoPagedResultDto {
    items!: StatisticBillingOfProductWithMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IStatisticBillingOfProductWithMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBillingOfProductWithMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StatisticBillingOfProductWithMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBillingOfProductWithMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StatisticBillingOfProductWithMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StatisticBillingOfProductWithMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBillingOfProductWithMachineDtoPagedResultDto {
    items: StatisticBillingOfProductWithMachineDto[] | undefined;
    totalCount: number;
}

export class StatisticImportOfMachineDto implements IStatisticImportOfMachineDto {
    key!: string | undefined;
    nameMachine!: string | undefined;
    quantityDrink!: number;
    quantityFreshDrink!: number;

    constructor(data?: IStatisticImportOfMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.nameMachine = _data["nameMachine"];
            this.quantityDrink = _data["quantityDrink"];
            this.quantityFreshDrink = _data["quantityFreshDrink"];
        }
    }

    static fromJS(data: any): StatisticImportOfMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticImportOfMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["nameMachine"] = this.nameMachine;
        data["quantityDrink"] = this.quantityDrink;
        data["quantityFreshDrink"] = this.quantityFreshDrink;
        return data;
    }

    clone(): StatisticImportOfMachineDto {
        const json = this.toJSON();
        let result = new StatisticImportOfMachineDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticImportOfMachineDto {
    key: string | undefined;
    nameMachine: string | undefined;
    quantityDrink: number;
    quantityFreshDrink: number;
}

export class StatisticImportOfMachineDtoPagedResultDto implements IStatisticImportOfMachineDtoPagedResultDto {
    items!: StatisticImportOfMachineDto[] | undefined;
    totalCount!: number;

    constructor(data?: IStatisticImportOfMachineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticImportOfMachineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StatisticImportOfMachineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticImportOfMachineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StatisticImportOfMachineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StatisticImportOfMachineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticImportOfMachineDtoPagedResultDto {
    items: StatisticImportOfMachineDto[] | undefined;
    totalCount: number;
}

export class StatusPaidProduct implements IStatusPaidProduct {
    error!: string | undefined;
    lastTimeProcess!: string | undefined;
    status!: string | undefined;

    constructor(data?: IStatusPaidProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.lastTimeProcess = _data["lastTimeProcess"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): StatusPaidProduct {
        data = typeof data === 'object' ? data : {};
        let result = new StatusPaidProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["lastTimeProcess"] = this.lastTimeProcess;
        data["status"] = this.status;
        return data;
    }

    clone(): StatusPaidProduct {
        const json = this.toJSON();
        let result = new StatusPaidProduct();
        result.init(json);
        return result;
    }
}

export interface IStatusPaidProduct {
    error: string | undefined;
    lastTimeProcess: string | undefined;
    status: string | undefined;
}

export class Stream implements IStream {
    readonly canRead!: boolean;
    readonly canWrite!: boolean;
    readonly canSeek!: boolean;
    readonly canTimeout!: boolean;
    readonly length!: number;
    position!: number;
    readTimeout!: number;
    writeTimeout!: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canTimeout = _data["canTimeout"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data;
    }

    clone(): Stream {
        const json = this.toJSON();
        let result = new Stream();
        result.init(json);
        return result;
    }
}

export interface IStream {
    canRead: boolean;
    canWrite: boolean;
    canSeek: boolean;
    canTimeout: boolean;
    length: number;
    position: number;
    readTimeout: number;
    writeTimeout: number;
}

export class StringStringKeyValuePair implements IStringStringKeyValuePair {
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IStringStringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringStringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): StringStringKeyValuePair {
        const json = this.toJSON();
        let result = new StringStringKeyValuePair();
        result.init(json);
        return result;
    }
}

export interface IStringStringKeyValuePair {
    key: string | undefined;
    value: string | undefined;
}

export class StringStringValuesKeyValuePair implements IStringStringValuesKeyValuePair {
    key!: string | undefined;
    value!: string[];

    constructor(data?: IStringStringValuesKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): StringStringValuesKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringValuesKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }

    clone(): StringStringValuesKeyValuePair {
        const json = this.toJSON();
        let result = new StringStringValuesKeyValuePair();
        result.init(json);
        return result;
    }
}

export interface IStringStringValuesKeyValuePair {
    key: string | undefined;
    value: string[];
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    readonly typeId!: any | undefined;
    value!: LayoutKind;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["typeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data;
    }

    clone(): StructLayoutAttribute {
        const json = this.toJSON();
        let result = new StructLayoutAttribute();
        result.init(json);
        return result;
    }
}

export interface IStructLayoutAttribute {
    typeId: any | undefined;
    value: LayoutKind;
}

export class SupplierAbstractDto implements ISupplierAbstractDto {
    su_id!: number;
    su_name!: string | undefined;
    su_desc!: string | undefined;
    su_is_active!: boolean;
    su_is_deleted!: boolean;

    constructor(data?: ISupplierAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_name = _data["su_name"];
            this.su_desc = _data["su_desc"];
            this.su_is_active = _data["su_is_active"];
            this.su_is_deleted = _data["su_is_deleted"];
        }
    }

    static fromJS(data: any): SupplierAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_name"] = this.su_name;
        data["su_desc"] = this.su_desc;
        data["su_is_active"] = this.su_is_active;
        data["su_is_deleted"] = this.su_is_deleted;
        return data;
    }

    clone(): SupplierAbstractDto {
        const json = this.toJSON();
        let result = new SupplierAbstractDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierAbstractDto {
    su_id: number;
    su_name: string | undefined;
    su_desc: string | undefined;
    su_is_active: boolean;
    su_is_deleted: boolean;
}

export class SupplierDto implements ISupplierDto {
    su_id!: number;
    su_name!: string | undefined;
    su_code!: string | undefined;
    su_email!: string | undefined;
    su_phone!: string | undefined;
    su_address!: string | undefined;
    su_contact_person!: string | undefined;
    su_note!: string | undefined;
    su_debt!: number;
    su_total_money_import!: number;
    su_is_active!: boolean;
    su_is_deleted!: boolean;
    su_created_at!: Date;
    su_updated_at!: Date;
    su_deleted_at!: Date | undefined;
    supplierPaymentLogs!: SupplierPaymentLogs[] | undefined;

    constructor(data?: ISupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_name = _data["su_name"];
            this.su_code = _data["su_code"];
            this.su_email = _data["su_email"];
            this.su_phone = _data["su_phone"];
            this.su_address = _data["su_address"];
            this.su_contact_person = _data["su_contact_person"];
            this.su_note = _data["su_note"];
            this.su_debt = _data["su_debt"];
            this.su_total_money_import = _data["su_total_money_import"];
            this.su_is_active = _data["su_is_active"];
            this.su_is_deleted = _data["su_is_deleted"];
            this.su_created_at = _data["su_created_at"] ? new Date(_data["su_created_at"].toString()) : <any>undefined;
            this.su_updated_at = _data["su_updated_at"] ? new Date(_data["su_updated_at"].toString()) : <any>undefined;
            this.su_deleted_at = _data["su_deleted_at"] ? new Date(_data["su_deleted_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["supplierPaymentLogs"])) {
                this.supplierPaymentLogs = [] as any;
                for (let item of _data["supplierPaymentLogs"])
                    this.supplierPaymentLogs!.push(SupplierPaymentLogs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_name"] = this.su_name;
        data["su_code"] = this.su_code;
        data["su_email"] = this.su_email;
        data["su_phone"] = this.su_phone;
        data["su_address"] = this.su_address;
        data["su_contact_person"] = this.su_contact_person;
        data["su_note"] = this.su_note;
        data["su_debt"] = this.su_debt;
        data["su_total_money_import"] = this.su_total_money_import;
        data["su_is_active"] = this.su_is_active;
        data["su_is_deleted"] = this.su_is_deleted;
        data["su_created_at"] = this.su_created_at ? this.su_created_at.toISOString() : <any>undefined;
        data["su_updated_at"] = this.su_updated_at ? this.su_updated_at.toISOString() : <any>undefined;
        data["su_deleted_at"] = this.su_deleted_at ? this.su_deleted_at.toISOString() : <any>undefined;
        if (Array.isArray(this.supplierPaymentLogs)) {
            data["supplierPaymentLogs"] = [];
            for (let item of this.supplierPaymentLogs)
                data["supplierPaymentLogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): SupplierDto {
        const json = this.toJSON();
        let result = new SupplierDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDto {
    su_id: number;
    su_name: string | undefined;
    su_code: string | undefined;
    su_email: string | undefined;
    su_phone: string | undefined;
    su_address: string | undefined;
    su_contact_person: string | undefined;
    su_note: string | undefined;
    su_debt: number;
    su_total_money_import: number;
    su_is_active: boolean;
    su_is_deleted: boolean;
    su_created_at: Date;
    su_updated_at: Date;
    su_deleted_at: Date | undefined;
    supplierPaymentLogs: SupplierPaymentLogs[] | undefined;
}

export class SupplierDtoPagedResultDto implements ISupplierDtoPagedResultDto {
    items!: SupplierDto[] | undefined;
    totalCount!: number;

    constructor(data?: ISupplierDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SupplierDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SupplierDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SupplierDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDtoPagedResultDto {
    items: SupplierDto[] | undefined;
    totalCount: number;
}

export class SupplierPaymentLogs implements ISupplierPaymentLogs {
    id!: number;
    readonly su_pa_lo_id!: number;
    su_id!: number;
    su_pa_lo_status!: ESupplierPaymentStatus;
    su_pa_lo_paid!: number;
    payment_method!: BillMethod;
    su_pa_lo_note!: string | undefined;
    su_pa_lo_created_at!: Date;
    tenantId!: number;

    constructor(data?: ISupplierPaymentLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).su_pa_lo_id = _data["su_pa_lo_id"];
            this.su_id = _data["su_id"];
            this.su_pa_lo_status = _data["su_pa_lo_status"];
            this.su_pa_lo_paid = _data["su_pa_lo_paid"];
            this.payment_method = _data["payment_method"];
            this.su_pa_lo_note = _data["su_pa_lo_note"];
            this.su_pa_lo_created_at = _data["su_pa_lo_created_at"] ? new Date(_data["su_pa_lo_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): SupplierPaymentLogs {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierPaymentLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["su_pa_lo_id"] = this.su_pa_lo_id;
        data["su_id"] = this.su_id;
        data["su_pa_lo_status"] = this.su_pa_lo_status;
        data["su_pa_lo_paid"] = this.su_pa_lo_paid;
        data["payment_method"] = this.payment_method;
        data["su_pa_lo_note"] = this.su_pa_lo_note;
        data["su_pa_lo_created_at"] = this.su_pa_lo_created_at ? this.su_pa_lo_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): SupplierPaymentLogs {
        const json = this.toJSON();
        let result = new SupplierPaymentLogs();
        result.init(json);
        return result;
    }
}

export interface ISupplierPaymentLogs {
    id: number;
    su_pa_lo_id: number;
    su_id: number;
    su_pa_lo_status: ESupplierPaymentStatus;
    su_pa_lo_paid: number;
    payment_method: BillMethod;
    su_pa_lo_note: string | undefined;
    su_pa_lo_created_at: Date;
    tenantId: number;
}

export class SwallowCashMachine implements ISwallowCashMachine {
    id!: number;
    readonly sw_id!: number;
    sw_code!: string | undefined;
    ma_id!: number;
    sw_money!: number;
    sw_created_at!: Date;
    machine!: Machine;
    tenantId!: number;

    constructor(data?: ISwallowCashMachine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).sw_id = _data["sw_id"];
            this.sw_code = _data["sw_code"];
            this.ma_id = _data["ma_id"];
            this.sw_money = _data["sw_money"];
            this.sw_created_at = _data["sw_created_at"] ? new Date(_data["sw_created_at"].toString()) : <any>undefined;
            this.machine = _data["machine"] ? Machine.fromJS(_data["machine"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): SwallowCashMachine {
        data = typeof data === 'object' ? data : {};
        let result = new SwallowCashMachine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sw_id"] = this.sw_id;
        data["sw_code"] = this.sw_code;
        data["ma_id"] = this.ma_id;
        data["sw_money"] = this.sw_money;
        data["sw_created_at"] = this.sw_created_at ? this.sw_created_at.toISOString() : <any>undefined;
        data["machine"] = this.machine ? this.machine.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): SwallowCashMachine {
        const json = this.toJSON();
        let result = new SwallowCashMachine();
        result.init(json);
        return result;
    }
}

export interface ISwallowCashMachine {
    id: number;
    sw_id: number;
    sw_code: string | undefined;
    ma_id: number;
    sw_money: number;
    sw_created_at: Date;
    machine: Machine;
    tenantId: number;
}

export class TenantAbstractDto implements ITenantAbstractDto {
    tenantId!: number;
    tenantName!: string | undefined;
    isDeleted!: boolean;

    constructor(data?: ITenantAbstractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): TenantAbstractDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAbstractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["isDeleted"] = this.isDeleted;
        return data;
    }

    clone(): TenantAbstractDto {
        const json = this.toJSON();
        let result = new TenantAbstractDto();
        result.init(json);
        return result;
    }
}

export interface ITenantAbstractDto {
    tenantId: number;
    tenantName: string | undefined;
    isDeleted: boolean;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id!: number;
    tenancyName!: string;
    vCBInformationPayment!: VCBInformationPayment;
    mOMOInformationPayment!: MoMoInformationPayment;
    vnPayInformationPayment!: VNPayInformationPayment;
    maxNumberOfMachine!: number;
    name!: string;
    isActive!: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.vCBInformationPayment = _data["vCBInformationPayment"] ? VCBInformationPayment.fromJS(_data["vCBInformationPayment"]) : <any>undefined;
            this.mOMOInformationPayment = _data["mOMOInformationPayment"] ? MoMoInformationPayment.fromJS(_data["mOMOInformationPayment"]) : <any>undefined;
            this.vnPayInformationPayment = _data["vnPayInformationPayment"] ? VNPayInformationPayment.fromJS(_data["vnPayInformationPayment"]) : <any>undefined;
            this.maxNumberOfMachine = _data["maxNumberOfMachine"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["vCBInformationPayment"] = this.vCBInformationPayment ? this.vCBInformationPayment.toJSON() : <any>undefined;
        data["mOMOInformationPayment"] = this.mOMOInformationPayment ? this.mOMOInformationPayment.toJSON() : <any>undefined;
        data["vnPayInformationPayment"] = this.vnPayInformationPayment ? this.vnPayInformationPayment.toJSON() : <any>undefined;
        data["maxNumberOfMachine"] = this.maxNumberOfMachine;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    vCBInformationPayment: VCBInformationPayment;
    mOMOInformationPayment: MoMoInformationPayment;
    vnPayInformationPayment: VNPayInformationPayment;
    maxNumberOfMachine: number;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items!: TenantDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    id!: string;
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: Type;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: Date;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"] ? Type.fromJS(_data["entityType"]) : <any>undefined;
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType ? this.entityType.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    id: string;
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: Type;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: Date;
}

export class ThongKeHangHoa1MayDto implements IThongKeHangHoa1MayDto {
    key!: string | undefined;
    tenSanPham!: string | undefined;
    giaBan!: number;
    hangNhapMay!: number;
    soLuongBan_MOMO!: number;
    soLuongBan_CASH!: number;
    soLuongBan_QR!: number;
    soLuongBan_VNPay!: number;
    soLuongBan_RFID!: number;
    soLuongBan_PROMO!: number;
    soLuongBan_Error!: number;
    thanhTien_MOMO!: number;
    thanhTien_CASH!: number;
    thanhTien_QR!: number;
    thanhTien_VNPay!: number;
    thanhTien_RFID!: number;

    constructor(data?: IThongKeHangHoa1MayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenSanPham = _data["tenSanPham"];
            this.giaBan = _data["giaBan"];
            this.hangNhapMay = _data["hangNhapMay"];
            this.soLuongBan_MOMO = _data["soLuongBan_MOMO"];
            this.soLuongBan_CASH = _data["soLuongBan_CASH"];
            this.soLuongBan_QR = _data["soLuongBan_QR"];
            this.soLuongBan_VNPay = _data["soLuongBan_VNPay"];
            this.soLuongBan_RFID = _data["soLuongBan_RFID"];
            this.soLuongBan_PROMO = _data["soLuongBan_PROMO"];
            this.soLuongBan_Error = _data["soLuongBan_Error"];
            this.thanhTien_MOMO = _data["thanhTien_MOMO"];
            this.thanhTien_CASH = _data["thanhTien_CASH"];
            this.thanhTien_QR = _data["thanhTien_QR"];
            this.thanhTien_VNPay = _data["thanhTien_VNPay"];
            this.thanhTien_RFID = _data["thanhTien_RFID"];
        }
    }

    static fromJS(data: any): ThongKeHangHoa1MayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeHangHoa1MayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenSanPham"] = this.tenSanPham;
        data["giaBan"] = this.giaBan;
        data["hangNhapMay"] = this.hangNhapMay;
        data["soLuongBan_MOMO"] = this.soLuongBan_MOMO;
        data["soLuongBan_CASH"] = this.soLuongBan_CASH;
        data["soLuongBan_QR"] = this.soLuongBan_QR;
        data["soLuongBan_VNPay"] = this.soLuongBan_VNPay;
        data["soLuongBan_RFID"] = this.soLuongBan_RFID;
        data["soLuongBan_PROMO"] = this.soLuongBan_PROMO;
        data["soLuongBan_Error"] = this.soLuongBan_Error;
        data["thanhTien_MOMO"] = this.thanhTien_MOMO;
        data["thanhTien_CASH"] = this.thanhTien_CASH;
        data["thanhTien_QR"] = this.thanhTien_QR;
        data["thanhTien_VNPay"] = this.thanhTien_VNPay;
        data["thanhTien_RFID"] = this.thanhTien_RFID;
        return data;
    }

    clone(): ThongKeHangHoa1MayDto {
        const json = this.toJSON();
        let result = new ThongKeHangHoa1MayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeHangHoa1MayDto {
    key: string | undefined;
    tenSanPham: string | undefined;
    giaBan: number;
    hangNhapMay: number;
    soLuongBan_MOMO: number;
    soLuongBan_CASH: number;
    soLuongBan_QR: number;
    soLuongBan_VNPay: number;
    soLuongBan_RFID: number;
    soLuongBan_PROMO: number;
    soLuongBan_Error: number;
    thanhTien_MOMO: number;
    thanhTien_CASH: number;
    thanhTien_QR: number;
    thanhTien_VNPay: number;
    thanhTien_RFID: number;
}

export class ThongKeHangHoaKho1MayDto implements IThongKeHangHoaKho1MayDto {
    key!: string | undefined;
    tenSanPham!: string | undefined;
    giaBan!: number;
    hangNhapKho!: number;
    soLuongBan_MOMO!: number;
    soLuongBan_CASH!: number;
    soLuongBan_QR!: number;
    soLuongBan_VNPay!: number;
    soLuongBan_RFID!: number;
    soLuongBan_PROMO!: number;
    soLuongBan_Error!: number;
    thanhTien_MOMO!: number;
    thanhTien_CASH!: number;
    thanhTien_QR!: number;
    thanhTien_VNPay!: number;
    thanhTien_RFID!: number;
    hangTonTrongMay!: number;
    hangTonTrongKho!: number;

    constructor(data?: IThongKeHangHoaKho1MayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenSanPham = _data["tenSanPham"];
            this.giaBan = _data["giaBan"];
            this.hangNhapKho = _data["hangNhapKho"];
            this.soLuongBan_MOMO = _data["soLuongBan_MOMO"];
            this.soLuongBan_CASH = _data["soLuongBan_CASH"];
            this.soLuongBan_QR = _data["soLuongBan_QR"];
            this.soLuongBan_VNPay = _data["soLuongBan_VNPay"];
            this.soLuongBan_RFID = _data["soLuongBan_RFID"];
            this.soLuongBan_PROMO = _data["soLuongBan_PROMO"];
            this.soLuongBan_Error = _data["soLuongBan_Error"];
            this.thanhTien_MOMO = _data["thanhTien_MOMO"];
            this.thanhTien_CASH = _data["thanhTien_CASH"];
            this.thanhTien_QR = _data["thanhTien_QR"];
            this.thanhTien_VNPay = _data["thanhTien_VNPay"];
            this.thanhTien_RFID = _data["thanhTien_RFID"];
            this.hangTonTrongMay = _data["hangTonTrongMay"];
            this.hangTonTrongKho = _data["hangTonTrongKho"];
        }
    }

    static fromJS(data: any): ThongKeHangHoaKho1MayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeHangHoaKho1MayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenSanPham"] = this.tenSanPham;
        data["giaBan"] = this.giaBan;
        data["hangNhapKho"] = this.hangNhapKho;
        data["soLuongBan_MOMO"] = this.soLuongBan_MOMO;
        data["soLuongBan_CASH"] = this.soLuongBan_CASH;
        data["soLuongBan_QR"] = this.soLuongBan_QR;
        data["soLuongBan_VNPay"] = this.soLuongBan_VNPay;
        data["soLuongBan_RFID"] = this.soLuongBan_RFID;
        data["soLuongBan_PROMO"] = this.soLuongBan_PROMO;
        data["soLuongBan_Error"] = this.soLuongBan_Error;
        data["thanhTien_MOMO"] = this.thanhTien_MOMO;
        data["thanhTien_CASH"] = this.thanhTien_CASH;
        data["thanhTien_QR"] = this.thanhTien_QR;
        data["thanhTien_VNPay"] = this.thanhTien_VNPay;
        data["thanhTien_RFID"] = this.thanhTien_RFID;
        data["hangTonTrongMay"] = this.hangTonTrongMay;
        data["hangTonTrongKho"] = this.hangTonTrongKho;
        return data;
    }

    clone(): ThongKeHangHoaKho1MayDto {
        const json = this.toJSON();
        let result = new ThongKeHangHoaKho1MayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeHangHoaKho1MayDto {
    key: string | undefined;
    tenSanPham: string | undefined;
    giaBan: number;
    hangNhapKho: number;
    soLuongBan_MOMO: number;
    soLuongBan_CASH: number;
    soLuongBan_QR: number;
    soLuongBan_VNPay: number;
    soLuongBan_RFID: number;
    soLuongBan_PROMO: number;
    soLuongBan_Error: number;
    thanhTien_MOMO: number;
    thanhTien_CASH: number;
    thanhTien_QR: number;
    thanhTien_VNPay: number;
    thanhTien_RFID: number;
    hangTonTrongMay: number;
    hangTonTrongKho: number;
}

export class ThongKeHangHoaKho1MayDtoPagedResultDto implements IThongKeHangHoaKho1MayDtoPagedResultDto {
    items!: ThongKeHangHoaKho1MayDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeHangHoaKho1MayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeHangHoaKho1MayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeHangHoaKho1MayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeHangHoaKho1MayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeHangHoaKho1MayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeHangHoaKho1MayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeHangHoaKho1MayDtoPagedResultDto {
    items: ThongKeHangHoaKho1MayDto[] | undefined;
    totalCount: number;
}

export class ThongKeHangHoaKhoNhieuMayDto implements IThongKeHangHoaKhoNhieuMayDto {
    key!: string | undefined;
    tenSanPham!: string | undefined;
    giaBan!: number;
    hangNhapKho!: number;
    listSoLuongXuatTheoMay!: SoLuongXuatTheoMay[] | undefined;
    hangTonTrongKho!: number;

    constructor(data?: IThongKeHangHoaKhoNhieuMayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenSanPham = _data["tenSanPham"];
            this.giaBan = _data["giaBan"];
            this.hangNhapKho = _data["hangNhapKho"];
            if (Array.isArray(_data["listSoLuongXuatTheoMay"])) {
                this.listSoLuongXuatTheoMay = [] as any;
                for (let item of _data["listSoLuongXuatTheoMay"])
                    this.listSoLuongXuatTheoMay!.push(SoLuongXuatTheoMay.fromJS(item));
            }
            this.hangTonTrongKho = _data["hangTonTrongKho"];
        }
    }

    static fromJS(data: any): ThongKeHangHoaKhoNhieuMayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeHangHoaKhoNhieuMayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenSanPham"] = this.tenSanPham;
        data["giaBan"] = this.giaBan;
        data["hangNhapKho"] = this.hangNhapKho;
        if (Array.isArray(this.listSoLuongXuatTheoMay)) {
            data["listSoLuongXuatTheoMay"] = [];
            for (let item of this.listSoLuongXuatTheoMay)
                data["listSoLuongXuatTheoMay"].push(item.toJSON());
        }
        data["hangTonTrongKho"] = this.hangTonTrongKho;
        return data;
    }

    clone(): ThongKeHangHoaKhoNhieuMayDto {
        const json = this.toJSON();
        let result = new ThongKeHangHoaKhoNhieuMayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeHangHoaKhoNhieuMayDto {
    key: string | undefined;
    tenSanPham: string | undefined;
    giaBan: number;
    hangNhapKho: number;
    listSoLuongXuatTheoMay: SoLuongXuatTheoMay[] | undefined;
    hangTonTrongKho: number;
}

export class ThongKeKhoNhieuMayDto implements IThongKeKhoNhieuMayDto {
    thongKeHangHoaKhoNhieuMayDto!: ThongKeHangHoaKhoNhieuMayDto[] | undefined;
    dicThongKeHangHoa1MayDto!: { [key: string]: ThongKeHangHoa1MayDto[]; } | undefined;
    dicMachinesName!: { [key: string]: string; } | undefined;

    constructor(data?: IThongKeKhoNhieuMayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["thongKeHangHoaKhoNhieuMayDto"])) {
                this.thongKeHangHoaKhoNhieuMayDto = [] as any;
                for (let item of _data["thongKeHangHoaKhoNhieuMayDto"])
                    this.thongKeHangHoaKhoNhieuMayDto!.push(ThongKeHangHoaKhoNhieuMayDto.fromJS(item));
            }
            if (_data["dicThongKeHangHoa1MayDto"]) {
                this.dicThongKeHangHoa1MayDto = {} as any;
                for (let key in _data["dicThongKeHangHoa1MayDto"]) {
                    if (_data["dicThongKeHangHoa1MayDto"].hasOwnProperty(key))
                        (<any>this.dicThongKeHangHoa1MayDto)![key] = _data["dicThongKeHangHoa1MayDto"][key] ? _data["dicThongKeHangHoa1MayDto"][key].map((i: any) => ThongKeHangHoa1MayDto.fromJS(i)) : <any>undefined;
                }
            }
            if (_data["dicMachinesName"]) {
                this.dicMachinesName = {} as any;
                for (let key in _data["dicMachinesName"]) {
                    if (_data["dicMachinesName"].hasOwnProperty(key))
                        (<any>this.dicMachinesName)![key] = _data["dicMachinesName"][key];
                }
            }
        }
    }

    static fromJS(data: any): ThongKeKhoNhieuMayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeKhoNhieuMayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.thongKeHangHoaKhoNhieuMayDto)) {
            data["thongKeHangHoaKhoNhieuMayDto"] = [];
            for (let item of this.thongKeHangHoaKhoNhieuMayDto)
                data["thongKeHangHoaKhoNhieuMayDto"].push(item.toJSON());
        }
        if (this.dicThongKeHangHoa1MayDto) {
            data["dicThongKeHangHoa1MayDto"] = {};
            for (let key in this.dicThongKeHangHoa1MayDto) {
                if (this.dicThongKeHangHoa1MayDto.hasOwnProperty(key))
                    (<any>data["dicThongKeHangHoa1MayDto"])[key] = (<any>this.dicThongKeHangHoa1MayDto)[key];
            }
        }
        if (this.dicMachinesName) {
            data["dicMachinesName"] = {};
            for (let key in this.dicMachinesName) {
                if (this.dicMachinesName.hasOwnProperty(key))
                    (<any>data["dicMachinesName"])[key] = (<any>this.dicMachinesName)[key];
            }
        }
        return data;
    }

    clone(): ThongKeKhoNhieuMayDto {
        const json = this.toJSON();
        let result = new ThongKeKhoNhieuMayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeKhoNhieuMayDto {
    thongKeHangHoaKhoNhieuMayDto: ThongKeHangHoaKhoNhieuMayDto[] | undefined;
    dicThongKeHangHoa1MayDto: { [key: string]: ThongKeHangHoa1MayDto[]; } | undefined;
    dicMachinesName: { [key: string]: string; } | undefined;
}

export class ThongKeNuotTienDto implements IThongKeNuotTienDto {
    key!: number;
    tenMay!: string | undefined;
    children!: ThongKeNuotTienDto[] | undefined;
    soTienNuot!: number;

    constructor(data?: IThongKeNuotTienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenMay = _data["tenMay"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ThongKeNuotTienDto.fromJS(item));
            }
            this.soTienNuot = _data["soTienNuot"];
        }
    }

    static fromJS(data: any): ThongKeNuotTienDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeNuotTienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenMay"] = this.tenMay;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["soTienNuot"] = this.soTienNuot;
        return data;
    }

    clone(): ThongKeNuotTienDto {
        const json = this.toJSON();
        let result = new ThongKeNuotTienDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeNuotTienDto {
    key: number;
    tenMay: string | undefined;
    children: ThongKeNuotTienDto[] | undefined;
    soTienNuot: number;
}

export class ThongKeNuotTienDtoPagedResultDto implements IThongKeNuotTienDtoPagedResultDto {
    items!: ThongKeNuotTienDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeNuotTienDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeNuotTienDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeNuotTienDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeNuotTienDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeNuotTienDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeNuotTienDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeNuotTienDtoPagedResultDto {
    items: ThongKeNuotTienDto[] | undefined;
    totalCount: number;
}

export class ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto implements IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto {
    key!: number;
    loaiHinhThanhToan!: BillMethod;
    tongTienSanPham!: number;
    tongTienNhanDuoc!: number;
    tongTienHoan!: number;
    soLuongDonHang!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.loaiHinhThanhToan = _data["loaiHinhThanhToan"];
            this.tongTienSanPham = _data["tongTienSanPham"];
            this.tongTienNhanDuoc = _data["tongTienNhanDuoc"];
            this.tongTienHoan = _data["tongTienHoan"];
            this.soLuongDonHang = _data["soLuongDonHang"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["loaiHinhThanhToan"] = this.loaiHinhThanhToan;
        data["tongTienSanPham"] = this.tongTienSanPham;
        data["tongTienNhanDuoc"] = this.tongTienNhanDuoc;
        data["tongTienHoan"] = this.tongTienHoan;
        data["soLuongDonHang"] = this.soLuongDonHang;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto {
    key: number;
    loaiHinhThanhToan: BillMethod;
    tongTienSanPham: number;
    tongTienNhanDuoc: number;
    tongTienHoan: number;
    soLuongDonHang: number;
}

export class ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto implements IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto {
    items!: ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDtoPagedResultDto {
    items: ThongKeTongQuanDoanhSoTheoLoaiHinhThanhToanDto[] | undefined;
    totalCount: number;
}

export class ThongKeTongQuanDoanhSoTheoMayDto implements IThongKeTongQuanDoanhSoTheoMayDto {
    key!: number;
    tenMay!: string | undefined;
    tenNhomMay!: string | undefined;
    soLuongDonHang!: number;
    soLuongSanPham!: number;
    tongTienNhanDuoc!: number;
    tongTienSanPham!: number;
    tienHoan!: number;
    tienNuot!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoMayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenMay = _data["tenMay"];
            this.tenNhomMay = _data["tenNhomMay"];
            this.soLuongDonHang = _data["soLuongDonHang"];
            this.soLuongSanPham = _data["soLuongSanPham"];
            this.tongTienNhanDuoc = _data["tongTienNhanDuoc"];
            this.tongTienSanPham = _data["tongTienSanPham"];
            this.tienHoan = _data["tienHoan"];
            this.tienNuot = _data["tienNuot"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoMayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoMayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenMay"] = this.tenMay;
        data["tenNhomMay"] = this.tenNhomMay;
        data["soLuongDonHang"] = this.soLuongDonHang;
        data["soLuongSanPham"] = this.soLuongSanPham;
        data["tongTienNhanDuoc"] = this.tongTienNhanDuoc;
        data["tongTienSanPham"] = this.tongTienSanPham;
        data["tienHoan"] = this.tienHoan;
        data["tienNuot"] = this.tienNuot;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoMayDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoMayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoMayDto {
    key: number;
    tenMay: string | undefined;
    tenNhomMay: string | undefined;
    soLuongDonHang: number;
    soLuongSanPham: number;
    tongTienNhanDuoc: number;
    tongTienSanPham: number;
    tienHoan: number;
    tienNuot: number;
}

export class ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto implements IThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto {
    items!: ThongKeTongQuanDoanhSoTheoMayDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeTongQuanDoanhSoTheoMayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoMayDtoPagedResultDto {
    items: ThongKeTongQuanDoanhSoTheoMayDto[] | undefined;
    totalCount: number;
}

export class ThongKeTongQuanDoanhSoTheoNhomMayDto implements IThongKeTongQuanDoanhSoTheoNhomMayDto {
    key!: number;
    tenNhomMayHoacMay!: string | undefined;
    children!: ThongKeTongQuanDoanhSoTheoNhomMayDto[] | undefined;
    soLuongDonHang!: number;
    soLuongSanPham!: number;
    tongTienNhanDuoc!: number;
    tongTienSanPham!: number;
    tienHoan!: number;
    tienNuot!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoNhomMayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.tenNhomMayHoacMay = _data["tenNhomMayHoacMay"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ThongKeTongQuanDoanhSoTheoNhomMayDto.fromJS(item));
            }
            this.soLuongDonHang = _data["soLuongDonHang"];
            this.soLuongSanPham = _data["soLuongSanPham"];
            this.tongTienNhanDuoc = _data["tongTienNhanDuoc"];
            this.tongTienSanPham = _data["tongTienSanPham"];
            this.tienHoan = _data["tienHoan"];
            this.tienNuot = _data["tienNuot"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoNhomMayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoNhomMayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["tenNhomMayHoacMay"] = this.tenNhomMayHoacMay;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["soLuongDonHang"] = this.soLuongDonHang;
        data["soLuongSanPham"] = this.soLuongSanPham;
        data["tongTienNhanDuoc"] = this.tongTienNhanDuoc;
        data["tongTienSanPham"] = this.tongTienSanPham;
        data["tienHoan"] = this.tienHoan;
        data["tienNuot"] = this.tienNuot;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoNhomMayDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoNhomMayDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoNhomMayDto {
    key: number;
    tenNhomMayHoacMay: string | undefined;
    children: ThongKeTongQuanDoanhSoTheoNhomMayDto[] | undefined;
    soLuongDonHang: number;
    soLuongSanPham: number;
    tongTienNhanDuoc: number;
    tongTienSanPham: number;
    tienHoan: number;
    tienNuot: number;
}

export class ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto implements IThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto {
    items!: ThongKeTongQuanDoanhSoTheoNhomMayDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeTongQuanDoanhSoTheoNhomMayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoNhomMayDtoPagedResultDto {
    items: ThongKeTongQuanDoanhSoTheoNhomMayDto[] | undefined;
    totalCount: number;
}

export class ThongKeTongQuanDoanhSoTheoSanPhamDto implements IThongKeTongQuanDoanhSoTheoSanPhamDto {
    key!: number;
    anhSanPham!: string | undefined;
    maSanPham!: string | undefined;
    tenSanPham!: string | undefined;
    soLuongSanPham!: number;
    doanhThu!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoSanPhamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.anhSanPham = _data["anhSanPham"];
            this.maSanPham = _data["maSanPham"];
            this.tenSanPham = _data["tenSanPham"];
            this.soLuongSanPham = _data["soLuongSanPham"];
            this.doanhThu = _data["doanhThu"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoSanPhamDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoSanPhamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["anhSanPham"] = this.anhSanPham;
        data["maSanPham"] = this.maSanPham;
        data["tenSanPham"] = this.tenSanPham;
        data["soLuongSanPham"] = this.soLuongSanPham;
        data["doanhThu"] = this.doanhThu;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoSanPhamDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoSanPhamDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoSanPhamDto {
    key: number;
    anhSanPham: string | undefined;
    maSanPham: string | undefined;
    tenSanPham: string | undefined;
    soLuongSanPham: number;
    doanhThu: number;
}

export class ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto implements IThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto {
    items!: ThongKeTongQuanDoanhSoTheoSanPhamDto[] | undefined;
    totalCount!: number;

    constructor(data?: IThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongKeTongQuanDoanhSoTheoSanPhamDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeTongQuanDoanhSoTheoSanPhamDtoPagedResultDto {
    items: ThongKeTongQuanDoanhSoTheoSanPhamDto[] | undefined;
    totalCount: number;
}

export class TranferRepository implements ITranferRepository {
    id!: number;
    readonly tr_re_id!: number;
    tr_re_code!: string | undefined;
    re_id_transfer!: number;
    re_id_receiver!: number;
    us_id_transfer!: number;
    tr_re_total_quantity!: number;
    tr_re_total_money!: number;
    tr_re_note!: string | undefined;
    tr_re_reason!: string | undefined;
    tr_re_status!: ETranferRepositoryStatus;
    tr_re_is_deleted!: boolean;
    tr_re_created_at!: Date;
    tr_re_updated_at!: Date;
    tr_re_deleted_at!: Date | undefined;
    tenantId!: number;
    listProductTranfer!: string | undefined;
    repositoryTransfer!: Repository;
    repositoryReceiver!: Repository;
    fi_id_list!: string | undefined;

    constructor(data?: ITranferRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).tr_re_id = _data["tr_re_id"];
            this.tr_re_code = _data["tr_re_code"];
            this.re_id_transfer = _data["re_id_transfer"];
            this.re_id_receiver = _data["re_id_receiver"];
            this.us_id_transfer = _data["us_id_transfer"];
            this.tr_re_total_quantity = _data["tr_re_total_quantity"];
            this.tr_re_total_money = _data["tr_re_total_money"];
            this.tr_re_note = _data["tr_re_note"];
            this.tr_re_reason = _data["tr_re_reason"];
            this.tr_re_status = _data["tr_re_status"];
            this.tr_re_is_deleted = _data["tr_re_is_deleted"];
            this.tr_re_created_at = _data["tr_re_created_at"] ? new Date(_data["tr_re_created_at"].toString()) : <any>undefined;
            this.tr_re_updated_at = _data["tr_re_updated_at"] ? new Date(_data["tr_re_updated_at"].toString()) : <any>undefined;
            this.tr_re_deleted_at = _data["tr_re_deleted_at"] ? new Date(_data["tr_re_deleted_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.listProductTranfer = _data["listProductTranfer"];
            this.repositoryTransfer = _data["repositoryTransfer"] ? Repository.fromJS(_data["repositoryTransfer"]) : <any>undefined;
            this.repositoryReceiver = _data["repositoryReceiver"] ? Repository.fromJS(_data["repositoryReceiver"]) : <any>undefined;
            this.fi_id_list = _data["fi_id_list"];
        }
    }

    static fromJS(data: any): TranferRepository {
        data = typeof data === 'object' ? data : {};
        let result = new TranferRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tr_re_id"] = this.tr_re_id;
        data["tr_re_code"] = this.tr_re_code;
        data["re_id_transfer"] = this.re_id_transfer;
        data["re_id_receiver"] = this.re_id_receiver;
        data["us_id_transfer"] = this.us_id_transfer;
        data["tr_re_total_quantity"] = this.tr_re_total_quantity;
        data["tr_re_total_money"] = this.tr_re_total_money;
        data["tr_re_note"] = this.tr_re_note;
        data["tr_re_reason"] = this.tr_re_reason;
        data["tr_re_status"] = this.tr_re_status;
        data["tr_re_is_deleted"] = this.tr_re_is_deleted;
        data["tr_re_created_at"] = this.tr_re_created_at ? this.tr_re_created_at.toISOString() : <any>undefined;
        data["tr_re_updated_at"] = this.tr_re_updated_at ? this.tr_re_updated_at.toISOString() : <any>undefined;
        data["tr_re_deleted_at"] = this.tr_re_deleted_at ? this.tr_re_deleted_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["listProductTranfer"] = this.listProductTranfer;
        data["repositoryTransfer"] = this.repositoryTransfer ? this.repositoryTransfer.toJSON() : <any>undefined;
        data["repositoryReceiver"] = this.repositoryReceiver ? this.repositoryReceiver.toJSON() : <any>undefined;
        data["fi_id_list"] = this.fi_id_list;
        return data;
    }

    clone(): TranferRepository {
        const json = this.toJSON();
        let result = new TranferRepository();
        result.init(json);
        return result;
    }
}

export interface ITranferRepository {
    id: number;
    tr_re_id: number;
    tr_re_code: string | undefined;
    re_id_transfer: number;
    re_id_receiver: number;
    us_id_transfer: number;
    tr_re_total_quantity: number;
    tr_re_total_money: number;
    tr_re_note: string | undefined;
    tr_re_reason: string | undefined;
    tr_re_status: ETranferRepositoryStatus;
    tr_re_is_deleted: boolean;
    tr_re_created_at: Date;
    tr_re_updated_at: Date;
    tr_re_deleted_at: Date | undefined;
    tenantId: number;
    listProductTranfer: string | undefined;
    repositoryTransfer: Repository;
    repositoryReceiver: Repository;
    fi_id_list: string | undefined;
}

export class TranferRepositoryDto implements ITranferRepositoryDto {
    tr_re_id!: number;
    tr_re_code!: string | undefined;
    re_id_transfer!: number;
    re_id_receiver!: number;
    us_id_transfer!: number;
    tr_re_total_quantity!: number;
    tr_re_total_money!: number;
    tr_re_note!: string | undefined;
    tr_re_reason!: string | undefined;
    tr_re_status!: ETranferRepositoryStatus;
    tr_re_created_at!: Date;
    listProductTranfer!: ProductTranferDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    repositoryReceiverDto!: RepositoryAbstractDto;
    repositoryTransferDto!: RepositoryAbstractDto;

    constructor(data?: ITranferRepositoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_re_id = _data["tr_re_id"];
            this.tr_re_code = _data["tr_re_code"];
            this.re_id_transfer = _data["re_id_transfer"];
            this.re_id_receiver = _data["re_id_receiver"];
            this.us_id_transfer = _data["us_id_transfer"];
            this.tr_re_total_quantity = _data["tr_re_total_quantity"];
            this.tr_re_total_money = _data["tr_re_total_money"];
            this.tr_re_note = _data["tr_re_note"];
            this.tr_re_reason = _data["tr_re_reason"];
            this.tr_re_status = _data["tr_re_status"];
            this.tr_re_created_at = _data["tr_re_created_at"] ? new Date(_data["tr_re_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listProductTranfer"])) {
                this.listProductTranfer = [] as any;
                for (let item of _data["listProductTranfer"])
                    this.listProductTranfer!.push(ProductTranferDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.repositoryReceiverDto = _data["repositoryReceiverDto"] ? RepositoryAbstractDto.fromJS(_data["repositoryReceiverDto"]) : <any>undefined;
            this.repositoryTransferDto = _data["repositoryTransferDto"] ? RepositoryAbstractDto.fromJS(_data["repositoryTransferDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TranferRepositoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranferRepositoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_re_id"] = this.tr_re_id;
        data["tr_re_code"] = this.tr_re_code;
        data["re_id_transfer"] = this.re_id_transfer;
        data["re_id_receiver"] = this.re_id_receiver;
        data["us_id_transfer"] = this.us_id_transfer;
        data["tr_re_total_quantity"] = this.tr_re_total_quantity;
        data["tr_re_total_money"] = this.tr_re_total_money;
        data["tr_re_note"] = this.tr_re_note;
        data["tr_re_reason"] = this.tr_re_reason;
        data["tr_re_status"] = this.tr_re_status;
        data["tr_re_created_at"] = this.tr_re_created_at ? this.tr_re_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listProductTranfer)) {
            data["listProductTranfer"] = [];
            for (let item of this.listProductTranfer)
                data["listProductTranfer"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["repositoryReceiverDto"] = this.repositoryReceiverDto ? this.repositoryReceiverDto.toJSON() : <any>undefined;
        data["repositoryTransferDto"] = this.repositoryTransferDto ? this.repositoryTransferDto.toJSON() : <any>undefined;
        return data;
    }

    clone(): TranferRepositoryDto {
        const json = this.toJSON();
        let result = new TranferRepositoryDto();
        result.init(json);
        return result;
    }
}

export interface ITranferRepositoryDto {
    tr_re_id: number;
    tr_re_code: string | undefined;
    re_id_transfer: number;
    re_id_receiver: number;
    us_id_transfer: number;
    tr_re_total_quantity: number;
    tr_re_total_money: number;
    tr_re_note: string | undefined;
    tr_re_reason: string | undefined;
    tr_re_status: ETranferRepositoryStatus;
    tr_re_created_at: Date;
    listProductTranfer: ProductTranferDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    repositoryReceiverDto: RepositoryAbstractDto;
    repositoryTransferDto: RepositoryAbstractDto;
}

export class TranferRepositoryDtoPagedResultDto implements ITranferRepositoryDtoPagedResultDto {
    items!: TranferRepositoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITranferRepositoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TranferRepositoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TranferRepositoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranferRepositoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TranferRepositoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TranferRepositoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITranferRepositoryDtoPagedResultDto {
    items: TranferRepositoryDto[] | undefined;
    totalCount: number;
}

export class TrashBin implements ITrashBin {
    id!: number;
    readonly tr_id!: number;
    tr_name!: string | undefined;
    tr_note!: string | undefined;
    deviceMAC!: string | undefined;
    tr_urlMap!: string | undefined;
    tr_lat!: number;
    tr_lng!: number;
    us_id_operator!: number;
    gr_tr_id!: number;
    tr_total_trash!: number;
    tr_tien_quy_doi_theo_rac!: number;
    tr_type!: ETrashType;
    tr_dev_type!: ETrashDeviceType;
    tr_is_deleted!: boolean;
    tr_created_at!: Date;
    tr_updated_at!: Date;
    tr_deleted_at!: Date | undefined;
    tenantId!: number;
    trashBinLogs!: TrashBinLogs[] | undefined;

    constructor(data?: ITrashBin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).tr_id = _data["tr_id"];
            this.tr_name = _data["tr_name"];
            this.tr_note = _data["tr_note"];
            this.deviceMAC = _data["deviceMAC"];
            this.tr_urlMap = _data["tr_urlMap"];
            this.tr_lat = _data["tr_lat"];
            this.tr_lng = _data["tr_lng"];
            this.us_id_operator = _data["us_id_operator"];
            this.gr_tr_id = _data["gr_tr_id"];
            this.tr_total_trash = _data["tr_total_trash"];
            this.tr_tien_quy_doi_theo_rac = _data["tr_tien_quy_doi_theo_rac"];
            this.tr_type = _data["tr_type"];
            this.tr_dev_type = _data["tr_dev_type"];
            this.tr_is_deleted = _data["tr_is_deleted"];
            this.tr_created_at = _data["tr_created_at"] ? new Date(_data["tr_created_at"].toString()) : <any>undefined;
            this.tr_updated_at = _data["tr_updated_at"] ? new Date(_data["tr_updated_at"].toString()) : <any>undefined;
            this.tr_deleted_at = _data["tr_deleted_at"] ? new Date(_data["tr_deleted_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["trashBinLogs"])) {
                this.trashBinLogs = [] as any;
                for (let item of _data["trashBinLogs"])
                    this.trashBinLogs!.push(TrashBinLogs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrashBin {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tr_id"] = this.tr_id;
        data["tr_name"] = this.tr_name;
        data["tr_note"] = this.tr_note;
        data["deviceMAC"] = this.deviceMAC;
        data["tr_urlMap"] = this.tr_urlMap;
        data["tr_lat"] = this.tr_lat;
        data["tr_lng"] = this.tr_lng;
        data["us_id_operator"] = this.us_id_operator;
        data["gr_tr_id"] = this.gr_tr_id;
        data["tr_total_trash"] = this.tr_total_trash;
        data["tr_tien_quy_doi_theo_rac"] = this.tr_tien_quy_doi_theo_rac;
        data["tr_type"] = this.tr_type;
        data["tr_dev_type"] = this.tr_dev_type;
        data["tr_is_deleted"] = this.tr_is_deleted;
        data["tr_created_at"] = this.tr_created_at ? this.tr_created_at.toISOString() : <any>undefined;
        data["tr_updated_at"] = this.tr_updated_at ? this.tr_updated_at.toISOString() : <any>undefined;
        data["tr_deleted_at"] = this.tr_deleted_at ? this.tr_deleted_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.trashBinLogs)) {
            data["trashBinLogs"] = [];
            for (let item of this.trashBinLogs)
                data["trashBinLogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): TrashBin {
        const json = this.toJSON();
        let result = new TrashBin();
        result.init(json);
        return result;
    }
}

export interface ITrashBin {
    id: number;
    tr_id: number;
    tr_name: string | undefined;
    tr_note: string | undefined;
    deviceMAC: string | undefined;
    tr_urlMap: string | undefined;
    tr_lat: number;
    tr_lng: number;
    us_id_operator: number;
    gr_tr_id: number;
    tr_total_trash: number;
    tr_tien_quy_doi_theo_rac: number;
    tr_type: ETrashType;
    tr_dev_type: ETrashDeviceType;
    tr_is_deleted: boolean;
    tr_created_at: Date;
    tr_updated_at: Date;
    tr_deleted_at: Date | undefined;
    tenantId: number;
    trashBinLogs: TrashBinLogs[] | undefined;
}

export class TrashBinDashBoardDto implements ITrashBinDashBoardDto {
    totalTrashToday!: number;
    totalTrashYesterday!: number;
    totalTrashWeek!: number;
    totalTrashMonth!: number;
    totalTrashLastMonth!: number;
    totalCarbonCredit!: number;
    totalPlasticCredit!: number;

    constructor(data?: ITrashBinDashBoardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalTrashToday = _data["totalTrashToday"];
            this.totalTrashYesterday = _data["totalTrashYesterday"];
            this.totalTrashWeek = _data["totalTrashWeek"];
            this.totalTrashMonth = _data["totalTrashMonth"];
            this.totalTrashLastMonth = _data["totalTrashLastMonth"];
            this.totalCarbonCredit = _data["totalCarbonCredit"];
            this.totalPlasticCredit = _data["totalPlasticCredit"];
        }
    }

    static fromJS(data: any): TrashBinDashBoardDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinDashBoardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalTrashToday"] = this.totalTrashToday;
        data["totalTrashYesterday"] = this.totalTrashYesterday;
        data["totalTrashWeek"] = this.totalTrashWeek;
        data["totalTrashMonth"] = this.totalTrashMonth;
        data["totalTrashLastMonth"] = this.totalTrashLastMonth;
        data["totalCarbonCredit"] = this.totalCarbonCredit;
        data["totalPlasticCredit"] = this.totalPlasticCredit;
        return data;
    }

    clone(): TrashBinDashBoardDto {
        const json = this.toJSON();
        let result = new TrashBinDashBoardDto();
        result.init(json);
        return result;
    }
}

export interface ITrashBinDashBoardDto {
    totalTrashToday: number;
    totalTrashYesterday: number;
    totalTrashWeek: number;
    totalTrashMonth: number;
    totalTrashLastMonth: number;
    totalCarbonCredit: number;
    totalPlasticCredit: number;
}

export class TrashBinDto implements ITrashBinDto {
    tr_id!: number;
    tr_name!: string | undefined;
    tr_note!: string | undefined;
    deviceMAC!: string | undefined;
    us_id_operator!: number;
    gr_tr_id!: number;
    tr_total_trash!: number;
    tr_tien_quy_doi_theo_rac!: number;
    tr_type!: ETrashType;
    tr_created_at!: Date;
    tr_lat!: number;
    tr_lng!: number;
    tr_urlMap!: string | undefined;
    trashBinLogsDto!: TrashBinLogsDto[] | undefined;
    trashBinLogs!: TrashBinLogs[] | undefined;
    tr_tong_tien_quy_doi_theo_rac!: number;

    constructor(data?: ITrashBinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_id = _data["tr_id"];
            this.tr_name = _data["tr_name"];
            this.tr_note = _data["tr_note"];
            this.deviceMAC = _data["deviceMAC"];
            this.us_id_operator = _data["us_id_operator"];
            this.gr_tr_id = _data["gr_tr_id"];
            this.tr_total_trash = _data["tr_total_trash"];
            this.tr_tien_quy_doi_theo_rac = _data["tr_tien_quy_doi_theo_rac"];
            this.tr_type = _data["tr_type"];
            this.tr_created_at = _data["tr_created_at"] ? new Date(_data["tr_created_at"].toString()) : <any>undefined;
            this.tr_lat = _data["tr_lat"];
            this.tr_lng = _data["tr_lng"];
            this.tr_urlMap = _data["tr_urlMap"];
            if (Array.isArray(_data["trashBinLogsDto"])) {
                this.trashBinLogsDto = [] as any;
                for (let item of _data["trashBinLogsDto"])
                    this.trashBinLogsDto!.push(TrashBinLogsDto.fromJS(item));
            }
            if (Array.isArray(_data["trashBinLogs"])) {
                this.trashBinLogs = [] as any;
                for (let item of _data["trashBinLogs"])
                    this.trashBinLogs!.push(TrashBinLogs.fromJS(item));
            }
            this.tr_tong_tien_quy_doi_theo_rac = _data["tr_tong_tien_quy_doi_theo_rac"];
        }
    }

    static fromJS(data: any): TrashBinDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_id"] = this.tr_id;
        data["tr_name"] = this.tr_name;
        data["tr_note"] = this.tr_note;
        data["deviceMAC"] = this.deviceMAC;
        data["us_id_operator"] = this.us_id_operator;
        data["gr_tr_id"] = this.gr_tr_id;
        data["tr_total_trash"] = this.tr_total_trash;
        data["tr_tien_quy_doi_theo_rac"] = this.tr_tien_quy_doi_theo_rac;
        data["tr_type"] = this.tr_type;
        data["tr_created_at"] = this.tr_created_at ? this.tr_created_at.toISOString() : <any>undefined;
        data["tr_lat"] = this.tr_lat;
        data["tr_lng"] = this.tr_lng;
        data["tr_urlMap"] = this.tr_urlMap;
        if (Array.isArray(this.trashBinLogsDto)) {
            data["trashBinLogsDto"] = [];
            for (let item of this.trashBinLogsDto)
                data["trashBinLogsDto"].push(item.toJSON());
        }
        if (Array.isArray(this.trashBinLogs)) {
            data["trashBinLogs"] = [];
            for (let item of this.trashBinLogs)
                data["trashBinLogs"].push(item.toJSON());
        }
        data["tr_tong_tien_quy_doi_theo_rac"] = this.tr_tong_tien_quy_doi_theo_rac;
        return data;
    }

    clone(): TrashBinDto {
        const json = this.toJSON();
        let result = new TrashBinDto();
        result.init(json);
        return result;
    }
}

export interface ITrashBinDto {
    tr_id: number;
    tr_name: string | undefined;
    tr_note: string | undefined;
    deviceMAC: string | undefined;
    us_id_operator: number;
    gr_tr_id: number;
    tr_total_trash: number;
    tr_tien_quy_doi_theo_rac: number;
    tr_type: ETrashType;
    tr_created_at: Date;
    tr_lat: number;
    tr_lng: number;
    tr_urlMap: string | undefined;
    trashBinLogsDto: TrashBinLogsDto[] | undefined;
    trashBinLogs: TrashBinLogs[] | undefined;
    tr_tong_tien_quy_doi_theo_rac: number;
}

export class TrashBinDtoPagedResultDto implements ITrashBinDtoPagedResultDto {
    items!: TrashBinDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITrashBinDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrashBinDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrashBinDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TrashBinDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TrashBinDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITrashBinDtoPagedResultDto {
    items: TrashBinDto[] | undefined;
    totalCount: number;
}

export class TrashBinLogs implements ITrashBinLogs {
    id!: number;
    readonly tr_lo_id!: number;
    tr_id!: number;
    tr_lo_trashWeight!: number;
    tr_lo_tien_quy_doi!: number;
    tr_lo_created_at!: Date;
    tenantId!: number;

    constructor(data?: ITrashBinLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).tr_lo_id = _data["tr_lo_id"];
            this.tr_id = _data["tr_id"];
            this.tr_lo_trashWeight = _data["tr_lo_trashWeight"];
            this.tr_lo_tien_quy_doi = _data["tr_lo_tien_quy_doi"];
            this.tr_lo_created_at = _data["tr_lo_created_at"] ? new Date(_data["tr_lo_created_at"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): TrashBinLogs {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tr_lo_id"] = this.tr_lo_id;
        data["tr_id"] = this.tr_id;
        data["tr_lo_trashWeight"] = this.tr_lo_trashWeight;
        data["tr_lo_tien_quy_doi"] = this.tr_lo_tien_quy_doi;
        data["tr_lo_created_at"] = this.tr_lo_created_at ? this.tr_lo_created_at.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): TrashBinLogs {
        const json = this.toJSON();
        let result = new TrashBinLogs();
        result.init(json);
        return result;
    }
}

export interface ITrashBinLogs {
    id: number;
    tr_lo_id: number;
    tr_id: number;
    tr_lo_trashWeight: number;
    tr_lo_tien_quy_doi: number;
    tr_lo_created_at: Date;
    tenantId: number;
}

export class TrashBinLogsDto implements ITrashBinLogsDto {
    tr_created_at!: string | undefined;
    total_trash_a_day!: number;
    tien_quy_doi!: number;
    total_count!: number;

    constructor(data?: ITrashBinLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_created_at = _data["tr_created_at"];
            this.total_trash_a_day = _data["total_trash_a_day"];
            this.tien_quy_doi = _data["tien_quy_doi"];
            this.total_count = _data["total_count"];
        }
    }

    static fromJS(data: any): TrashBinLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_created_at"] = this.tr_created_at;
        data["total_trash_a_day"] = this.total_trash_a_day;
        data["tien_quy_doi"] = this.tien_quy_doi;
        data["total_count"] = this.total_count;
        return data;
    }

    clone(): TrashBinLogsDto {
        const json = this.toJSON();
        let result = new TrashBinLogsDto();
        result.init(json);
        return result;
    }
}

export interface ITrashBinLogsDto {
    tr_created_at: string | undefined;
    total_trash_a_day: number;
    tien_quy_doi: number;
    total_count: number;
}

export class TrashBinLogsDtoPagedResultDto implements ITrashBinLogsDtoPagedResultDto {
    items!: TrashBinLogsDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITrashBinLogsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrashBinLogsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrashBinLogsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrashBinLogsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TrashBinLogsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TrashBinLogsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITrashBinLogsDtoPagedResultDto {
    items: TrashBinLogsDto[] | undefined;
    totalCount: number;
}

export class Type implements IType {
    readonly name!: string | undefined;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    readonly isInterface!: boolean;
    memberType!: MemberTypes;
    readonly namespace!: string | undefined;
    readonly assemblyQualifiedName!: string | undefined;
    readonly fullName!: string | undefined;
    assembly!: Assembly;
    module!: Module;
    readonly isNested!: boolean;
    declaringType!: Type;
    declaringMethod!: MethodBase;
    reflectedType!: Type;
    underlyingSystemType!: Type;
    readonly isTypeDefinition!: boolean;
    readonly isArray!: boolean;
    readonly isByRef!: boolean;
    readonly isPointer!: boolean;
    readonly isConstructedGenericType!: boolean;
    readonly isGenericParameter!: boolean;
    readonly isGenericTypeParameter!: boolean;
    readonly isGenericMethodParameter!: boolean;
    readonly isGenericType!: boolean;
    readonly isGenericTypeDefinition!: boolean;
    readonly isSZArray!: boolean;
    readonly isVariableBoundArray!: boolean;
    readonly isByRefLike!: boolean;
    readonly hasElementType!: boolean;
    readonly genericTypeArguments!: Type[] | undefined;
    readonly genericParameterPosition!: number;
    genericParameterAttributes!: GenericParameterAttributes;
    attributes!: TypeAttributes;
    readonly isAbstract!: boolean;
    readonly isImport!: boolean;
    readonly isSealed!: boolean;
    readonly isSpecialName!: boolean;
    readonly isClass!: boolean;
    readonly isNestedAssembly!: boolean;
    readonly isNestedFamANDAssem!: boolean;
    readonly isNestedFamily!: boolean;
    readonly isNestedFamORAssem!: boolean;
    readonly isNestedPrivate!: boolean;
    readonly isNestedPublic!: boolean;
    readonly isNotPublic!: boolean;
    readonly isPublic!: boolean;
    readonly isAutoLayout!: boolean;
    readonly isExplicitLayout!: boolean;
    readonly isLayoutSequential!: boolean;
    readonly isAnsiClass!: boolean;
    readonly isAutoClass!: boolean;
    readonly isUnicodeClass!: boolean;
    readonly isCOMObject!: boolean;
    readonly isContextful!: boolean;
    readonly isEnum!: boolean;
    readonly isMarshalByRef!: boolean;
    readonly isPrimitive!: boolean;
    readonly isValueType!: boolean;
    readonly isSignatureType!: boolean;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    structLayoutAttribute!: StructLayoutAttribute;
    typeInitializer!: ConstructorInfo;
    typeHandle!: RuntimeTypeHandle;
    readonly guid!: string;
    baseType!: Type;
    readonly isSerializable!: boolean;
    readonly containsGenericParameters!: boolean;
    readonly isVisible!: boolean;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        return data;
    }

    clone(): Type {
        const json = this.toJSON();
        let result = new Type();
        result.init(json);
        return result;
    }
}

export interface IType {
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export class TypeInfo implements ITypeInfo {
    readonly name!: string | undefined;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;
    readonly isInterface!: boolean;
    memberType!: MemberTypes;
    readonly namespace!: string | undefined;
    readonly assemblyQualifiedName!: string | undefined;
    readonly fullName!: string | undefined;
    assembly!: Assembly;
    module!: Module;
    readonly isNested!: boolean;
    declaringType!: Type;
    declaringMethod!: MethodBase;
    reflectedType!: Type;
    underlyingSystemType!: Type;
    readonly isTypeDefinition!: boolean;
    readonly isArray!: boolean;
    readonly isByRef!: boolean;
    readonly isPointer!: boolean;
    readonly isConstructedGenericType!: boolean;
    readonly isGenericParameter!: boolean;
    readonly isGenericTypeParameter!: boolean;
    readonly isGenericMethodParameter!: boolean;
    readonly isGenericType!: boolean;
    readonly isGenericTypeDefinition!: boolean;
    readonly isSZArray!: boolean;
    readonly isVariableBoundArray!: boolean;
    readonly isByRefLike!: boolean;
    readonly hasElementType!: boolean;
    readonly genericTypeArguments!: Type[] | undefined;
    readonly genericParameterPosition!: number;
    genericParameterAttributes!: GenericParameterAttributes;
    attributes!: TypeAttributes;
    readonly isAbstract!: boolean;
    readonly isImport!: boolean;
    readonly isSealed!: boolean;
    readonly isSpecialName!: boolean;
    readonly isClass!: boolean;
    readonly isNestedAssembly!: boolean;
    readonly isNestedFamANDAssem!: boolean;
    readonly isNestedFamily!: boolean;
    readonly isNestedFamORAssem!: boolean;
    readonly isNestedPrivate!: boolean;
    readonly isNestedPublic!: boolean;
    readonly isNotPublic!: boolean;
    readonly isPublic!: boolean;
    readonly isAutoLayout!: boolean;
    readonly isExplicitLayout!: boolean;
    readonly isLayoutSequential!: boolean;
    readonly isAnsiClass!: boolean;
    readonly isAutoClass!: boolean;
    readonly isUnicodeClass!: boolean;
    readonly isCOMObject!: boolean;
    readonly isContextful!: boolean;
    readonly isEnum!: boolean;
    readonly isMarshalByRef!: boolean;
    readonly isPrimitive!: boolean;
    readonly isValueType!: boolean;
    readonly isSignatureType!: boolean;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    structLayoutAttribute!: StructLayoutAttribute;
    typeInitializer!: ConstructorInfo;
    typeHandle!: RuntimeTypeHandle;
    readonly guid!: string;
    baseType!: Type;
    readonly isSerializable!: boolean;
    readonly containsGenericParameters!: boolean;
    readonly isVisible!: boolean;
    readonly genericTypeParameters!: Type[] | undefined;
    readonly declaredConstructors!: ConstructorInfo[] | undefined;
    readonly declaredEvents!: EventInfo[] | undefined;
    readonly declaredFields!: FieldInfo[] | undefined;
    readonly declaredMembers!: MemberInfo[] | undefined;
    readonly declaredMethods!: MethodInfo[] | undefined;
    readonly declaredNestedTypes!: TypeInfo[] | undefined;
    readonly declaredProperties!: PropertyInfo[] | undefined;
    readonly implementedInterfaces!: Type[] | undefined;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        return data;
    }

    clone(): TypeInfo {
        const json = this.toJSON();
        let result = new TypeInfo();
        result.init(json);
        return result;
    }
}

export interface ITypeInfo {
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
    genericTypeParameters: Type[] | undefined;
    declaredConstructors: ConstructorInfo[] | undefined;
    declaredEvents: EventInfo[] | undefined;
    declaredFields: FieldInfo[] | undefined;
    declaredMembers: MemberInfo[] | undefined;
    declaredMethods: MethodInfo[] | undefined;
    declaredNestedTypes: TypeInfo[] | undefined;
    declaredProperties: PropertyInfo[] | undefined;
    implementedInterfaces: Type[] | undefined;
}

export class TypeObjectKeyValuePair implements ITypeObjectKeyValuePair {
    key!: Type;
    value!: any | undefined;

    constructor(data?: ITypeObjectKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] ? Type.fromJS(_data["key"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TypeObjectKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new TypeObjectKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }

    clone(): TypeObjectKeyValuePair {
        const json = this.toJSON();
        let result = new TypeObjectKeyValuePair();
        result.init(json);
        return result;
    }
}

export interface ITypeObjectKeyValuePair {
    key: Type;
    value: any | undefined;
}

export class UpdateApplicationExtInput implements IUpdateApplicationExtInput {
    ap_id!: number;
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: IUpdateApplicationExtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_id = _data["ap_id"];
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): UpdateApplicationExtInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationExtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_id"] = this.ap_id;
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): UpdateApplicationExtInput {
        const json = this.toJSON();
        let result = new UpdateApplicationExtInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateApplicationExtInput {
    ap_id: number;
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class UpdateAuthorizationMachineInput implements IUpdateAuthorizationMachineInput {
    au_ma_id!: number;
    ma_id!: number;
    us_id_is_authorized!: number;
    au_ma_type!: EAuthorizationMachineType;

    constructor(data?: IUpdateAuthorizationMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_ma_id = _data["au_ma_id"];
            this.ma_id = _data["ma_id"];
            this.us_id_is_authorized = _data["us_id_is_authorized"];
            this.au_ma_type = _data["au_ma_type"];
        }
    }

    static fromJS(data: any): UpdateAuthorizationMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorizationMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_ma_id"] = this.au_ma_id;
        data["ma_id"] = this.ma_id;
        data["us_id_is_authorized"] = this.us_id_is_authorized;
        data["au_ma_type"] = this.au_ma_type;
        return data;
    }

    clone(): UpdateAuthorizationMachineInput {
        const json = this.toJSON();
        let result = new UpdateAuthorizationMachineInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateAuthorizationMachineInput {
    au_ma_id: number;
    ma_id: number;
    us_id_is_authorized: number;
    au_ma_type: EAuthorizationMachineType;
}

export class UpdateAvataInput implements IUpdateAvataInput {
    id!: number;
    us_avatar!: number;

    constructor(data?: IUpdateAvataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.us_avatar = _data["us_avatar"];
        }
    }

    static fromJS(data: any): UpdateAvataInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAvataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["us_avatar"] = this.us_avatar;
        return data;
    }

    clone(): UpdateAvataInput {
        const json = this.toJSON();
        let result = new UpdateAvataInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateAvataInput {
    id: number;
    us_avatar: number;
}

export class UpdateDiscountCodeInput implements IUpdateDiscountCodeInput {
    di_id!: number;
    di_code!: string | undefined;
    di_desc!: string | undefined;
    di_price!: number;
    di_quantity_max!: number;
    di_start_at!: Date | undefined;
    di_end_at!: Date | undefined;
    di_active!: boolean;
    ma_id_list!: number[] | undefined;

    constructor(data?: IUpdateDiscountCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.di_id = _data["di_id"];
            this.di_code = _data["di_code"];
            this.di_desc = _data["di_desc"];
            this.di_price = _data["di_price"];
            this.di_quantity_max = _data["di_quantity_max"];
            this.di_start_at = _data["di_start_at"] ? new Date(_data["di_start_at"].toString()) : <any>undefined;
            this.di_end_at = _data["di_end_at"] ? new Date(_data["di_end_at"].toString()) : <any>undefined;
            this.di_active = _data["di_active"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateDiscountCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDiscountCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["di_id"] = this.di_id;
        data["di_code"] = this.di_code;
        data["di_desc"] = this.di_desc;
        data["di_price"] = this.di_price;
        data["di_quantity_max"] = this.di_quantity_max;
        data["di_start_at"] = this.di_start_at ? this.di_start_at.toISOString() : <any>undefined;
        data["di_end_at"] = this.di_end_at ? this.di_end_at.toISOString() : <any>undefined;
        data["di_active"] = this.di_active;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        return data;
    }

    clone(): UpdateDiscountCodeInput {
        const json = this.toJSON();
        let result = new UpdateDiscountCodeInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDiscountCodeInput {
    di_id: number;
    di_code: string | undefined;
    di_desc: string | undefined;
    di_price: number;
    di_quantity_max: number;
    di_start_at: Date | undefined;
    di_end_at: Date | undefined;
    di_active: boolean;
    ma_id_list: number[] | undefined;
}

export class UpdateDrinkInput implements IUpdateDrinkInput {
    dr_id!: number;
    dr_code!: string | undefined;
    dr_name!: string | undefined;
    dr_image!: AttachmentItem;
    dr_desc!: string | undefined;
    su_id!: number;
    dr_price!: number;

    constructor(data?: IUpdateDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dr_id = _data["dr_id"];
            this.dr_code = _data["dr_code"];
            this.dr_name = _data["dr_name"];
            this.dr_image = _data["dr_image"] ? AttachmentItem.fromJS(_data["dr_image"]) : <any>undefined;
            this.dr_desc = _data["dr_desc"];
            this.su_id = _data["su_id"];
            this.dr_price = _data["dr_price"];
        }
    }

    static fromJS(data: any): UpdateDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dr_id"] = this.dr_id;
        data["dr_code"] = this.dr_code;
        data["dr_name"] = this.dr_name;
        data["dr_image"] = this.dr_image ? this.dr_image.toJSON() : <any>undefined;
        data["dr_desc"] = this.dr_desc;
        data["su_id"] = this.su_id;
        data["dr_price"] = this.dr_price;
        return data;
    }

    clone(): UpdateDrinkInput {
        const json = this.toJSON();
        let result = new UpdateDrinkInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDrinkInput {
    dr_id: number;
    dr_code: string | undefined;
    dr_name: string | undefined;
    dr_image: AttachmentItem;
    dr_desc: string | undefined;
    su_id: number;
    dr_price: number;
}

export class UpdateFreshDrinkInput implements IUpdateFreshDrinkInput {
    fr_dr_id!: number;
    fr_dr_code!: string | undefined;
    fr_dr_name!: string | undefined;
    fr_dr_image!: AttachmentItem;
    fr_dr_capacity!: number;
    fr_dr_price!: number;
    su_id!: number;

    constructor(data?: IUpdateFreshDrinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fr_dr_id = _data["fr_dr_id"];
            this.fr_dr_code = _data["fr_dr_code"];
            this.fr_dr_name = _data["fr_dr_name"];
            this.fr_dr_image = _data["fr_dr_image"] ? AttachmentItem.fromJS(_data["fr_dr_image"]) : <any>undefined;
            this.fr_dr_capacity = _data["fr_dr_capacity"];
            this.fr_dr_price = _data["fr_dr_price"];
            this.su_id = _data["su_id"];
        }
    }

    static fromJS(data: any): UpdateFreshDrinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFreshDrinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fr_dr_id"] = this.fr_dr_id;
        data["fr_dr_code"] = this.fr_dr_code;
        data["fr_dr_name"] = this.fr_dr_name;
        data["fr_dr_image"] = this.fr_dr_image ? this.fr_dr_image.toJSON() : <any>undefined;
        data["fr_dr_capacity"] = this.fr_dr_capacity;
        data["fr_dr_price"] = this.fr_dr_price;
        data["su_id"] = this.su_id;
        return data;
    }

    clone(): UpdateFreshDrinkInput {
        const json = this.toJSON();
        let result = new UpdateFreshDrinkInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFreshDrinkInput {
    fr_dr_id: number;
    fr_dr_code: string | undefined;
    fr_dr_name: string | undefined;
    fr_dr_image: AttachmentItem;
    fr_dr_capacity: number;
    fr_dr_price: number;
    su_id: number;
}

export class UpdateGroupMachineInput implements IUpdateGroupMachineInput {
    gr_ma_id!: number;
    gr_ma_area!: string | undefined;
    gr_ma_desc!: string | undefined;

    constructor(data?: IUpdateGroupMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_ma_id = _data["gr_ma_id"];
            this.gr_ma_area = _data["gr_ma_area"];
            this.gr_ma_desc = _data["gr_ma_desc"];
        }
    }

    static fromJS(data: any): UpdateGroupMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_ma_id"] = this.gr_ma_id;
        data["gr_ma_area"] = this.gr_ma_area;
        data["gr_ma_desc"] = this.gr_ma_desc;
        return data;
    }

    clone(): UpdateGroupMachineInput {
        const json = this.toJSON();
        let result = new UpdateGroupMachineInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGroupMachineInput {
    gr_ma_id: number;
    gr_ma_area: string | undefined;
    gr_ma_desc: string | undefined;
}

export class UpdateGroupTrashbinInput implements IUpdateGroupTrashbinInput {
    gr_tr_id!: number;
    gr_tr_name!: string | undefined;
    gr_tr_desc!: string | undefined;

    constructor(data?: IUpdateGroupTrashbinInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gr_tr_id = _data["gr_tr_id"];
            this.gr_tr_name = _data["gr_tr_name"];
            this.gr_tr_desc = _data["gr_tr_desc"];
        }
    }

    static fromJS(data: any): UpdateGroupTrashbinInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupTrashbinInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gr_tr_id"] = this.gr_tr_id;
        data["gr_tr_name"] = this.gr_tr_name;
        data["gr_tr_desc"] = this.gr_tr_desc;
        return data;
    }

    clone(): UpdateGroupTrashbinInput {
        const json = this.toJSON();
        let result = new UpdateGroupTrashbinInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGroupTrashbinInput {
    gr_tr_id: number;
    gr_tr_name: string | undefined;
    gr_tr_desc: string | undefined;
}

export class UpdateHandoverInput implements IUpdateHandoverInput {
    handover_user!: number;
    receive_user!: number;
    ha_status!: EHandoverStatus;
    ha_type!: EHandoverType;
    ha_note!: string | undefined;
    ma_id_list!: number[] | undefined;
    productHandoverInputs!: ProductHandoverInput[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    ha_id!: number;

    constructor(data?: IUpdateHandoverInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handover_user = _data["handover_user"];
            this.receive_user = _data["receive_user"];
            this.ha_status = _data["ha_status"];
            this.ha_type = _data["ha_type"];
            this.ha_note = _data["ha_note"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            if (Array.isArray(_data["productHandoverInputs"])) {
                this.productHandoverInputs = [] as any;
                for (let item of _data["productHandoverInputs"])
                    this.productHandoverInputs!.push(ProductHandoverInput.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.ha_id = _data["ha_id"];
        }
    }

    static fromJS(data: any): UpdateHandoverInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHandoverInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["handover_user"] = this.handover_user;
        data["receive_user"] = this.receive_user;
        data["ha_status"] = this.ha_status;
        data["ha_type"] = this.ha_type;
        data["ha_note"] = this.ha_note;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        if (Array.isArray(this.productHandoverInputs)) {
            data["productHandoverInputs"] = [];
            for (let item of this.productHandoverInputs)
                data["productHandoverInputs"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["ha_id"] = this.ha_id;
        return data;
    }

    clone(): UpdateHandoverInput {
        const json = this.toJSON();
        let result = new UpdateHandoverInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateHandoverInput {
    handover_user: number;
    receive_user: number;
    ha_status: EHandoverStatus;
    ha_type: EHandoverType;
    ha_note: string | undefined;
    ma_id_list: number[] | undefined;
    productHandoverInputs: ProductHandoverInput[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    ha_id: number;
}

export class UpdateImportRepositoryInput implements IUpdateImportRepositoryInput {
    im_re_id!: number;
    im_re_code!: string | undefined;
    su_id!: number;
    re_id!: number;
    im_re_total_money!: number;
    im_re_debt!: number;
    im_re_note!: string | undefined;
    im_re_status!: EImportRepositoryStatus;
    im_re_imported_at!: Date;
    listProductImport!: ProductImportDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateImportRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_re_id = _data["im_re_id"];
            this.im_re_code = _data["im_re_code"];
            this.su_id = _data["su_id"];
            this.re_id = _data["re_id"];
            this.im_re_total_money = _data["im_re_total_money"];
            this.im_re_debt = _data["im_re_debt"];
            this.im_re_note = _data["im_re_note"];
            this.im_re_status = _data["im_re_status"];
            this.im_re_imported_at = _data["im_re_imported_at"] ? new Date(_data["im_re_imported_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["listProductImport"])) {
                this.listProductImport = [] as any;
                for (let item of _data["listProductImport"])
                    this.listProductImport!.push(ProductImportDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateImportRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateImportRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_re_id"] = this.im_re_id;
        data["im_re_code"] = this.im_re_code;
        data["su_id"] = this.su_id;
        data["re_id"] = this.re_id;
        data["im_re_total_money"] = this.im_re_total_money;
        data["im_re_debt"] = this.im_re_debt;
        data["im_re_note"] = this.im_re_note;
        data["im_re_status"] = this.im_re_status;
        data["im_re_imported_at"] = this.im_re_imported_at ? this.im_re_imported_at.toISOString() : <any>undefined;
        if (Array.isArray(this.listProductImport)) {
            data["listProductImport"] = [];
            for (let item of this.listProductImport)
                data["listProductImport"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateImportRepositoryInput {
        const json = this.toJSON();
        let result = new UpdateImportRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateImportRepositoryInput {
    im_re_id: number;
    im_re_code: string | undefined;
    su_id: number;
    re_id: number;
    im_re_total_money: number;
    im_re_debt: number;
    im_re_note: string | undefined;
    im_re_status: EImportRepositoryStatus;
    im_re_imported_at: Date;
    listProductImport: ProductImportDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class UpdateImportingInput implements IUpdateImportingInput {
    im_id!: number;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateImportingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.im_id = _data["im_id"];
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateImportingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateImportingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["im_id"] = this.im_id;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateImportingInput {
        const json = this.toJSON();
        let result = new UpdateImportingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateImportingInput {
    im_id: number;
    fi_id_list: AttachmentItem[] | undefined;
}

export class UpdateLayoutInput implements IUpdateLayoutInput {
    la_id!: number;
    la_name!: string | undefined;
    la_type!: string | undefined;
    la_desc!: string | undefined;
    layoutSlotDtos!: LayoutSlotDto[] | undefined;

    constructor(data?: IUpdateLayoutInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_id = _data["la_id"];
            this.la_name = _data["la_name"];
            this.la_type = _data["la_type"];
            this.la_desc = _data["la_desc"];
            if (Array.isArray(_data["layoutSlotDtos"])) {
                this.layoutSlotDtos = [] as any;
                for (let item of _data["layoutSlotDtos"])
                    this.layoutSlotDtos!.push(LayoutSlotDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateLayoutInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLayoutInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_id"] = this.la_id;
        data["la_name"] = this.la_name;
        data["la_type"] = this.la_type;
        data["la_desc"] = this.la_desc;
        if (Array.isArray(this.layoutSlotDtos)) {
            data["layoutSlotDtos"] = [];
            for (let item of this.layoutSlotDtos)
                data["layoutSlotDtos"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateLayoutInput {
        const json = this.toJSON();
        let result = new UpdateLayoutInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLayoutInput {
    la_id: number;
    la_name: string | undefined;
    la_type: string | undefined;
    la_desc: string | undefined;
    layoutSlotDtos: LayoutSlotDto[] | undefined;
}

export class UpdateListMachineDetailInput implements IUpdateListMachineDetailInput {
    ma_id!: number;
    layout!: string | undefined;
    listMachineDetail!: UpdateMachineDetailInput[] | undefined;

    constructor(data?: IUpdateListMachineDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.layout = _data["layout"];
            if (Array.isArray(_data["listMachineDetail"])) {
                this.listMachineDetail = [] as any;
                for (let item of _data["listMachineDetail"])
                    this.listMachineDetail!.push(UpdateMachineDetailInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateListMachineDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateListMachineDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["layout"] = this.layout;
        if (Array.isArray(this.listMachineDetail)) {
            data["listMachineDetail"] = [];
            for (let item of this.listMachineDetail)
                data["listMachineDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateListMachineDetailInput {
        const json = this.toJSON();
        let result = new UpdateListMachineDetailInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateListMachineDetailInput {
    ma_id: number;
    layout: string | undefined;
    listMachineDetail: UpdateMachineDetailInput[] | undefined;
}

export class UpdateLossRepositoryInput implements IUpdateLossRepositoryInput {
    lo_re_id!: number;
    lo_re_code!: string | undefined;
    lo_re_reason!: string | undefined;
    lo_re_status!: ELossRepositoryStatus;
    listProductLoss!: ProductLossDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateLossRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lo_re_id = _data["lo_re_id"];
            this.lo_re_code = _data["lo_re_code"];
            this.lo_re_reason = _data["lo_re_reason"];
            this.lo_re_status = _data["lo_re_status"];
            if (Array.isArray(_data["listProductLoss"])) {
                this.listProductLoss = [] as any;
                for (let item of _data["listProductLoss"])
                    this.listProductLoss!.push(ProductLossDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateLossRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLossRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lo_re_id"] = this.lo_re_id;
        data["lo_re_code"] = this.lo_re_code;
        data["lo_re_reason"] = this.lo_re_reason;
        data["lo_re_status"] = this.lo_re_status;
        if (Array.isArray(this.listProductLoss)) {
            data["listProductLoss"] = [];
            for (let item of this.listProductLoss)
                data["listProductLoss"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateLossRepositoryInput {
        const json = this.toJSON();
        let result = new UpdateLossRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLossRepositoryInput {
    lo_re_id: number;
    lo_re_code: string | undefined;
    lo_re_reason: string | undefined;
    lo_re_status: ELossRepositoryStatus;
    listProductLoss: ProductLossDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
}

export class UpdateMachineDetailInput implements IUpdateMachineDetailInput {
    ma_de_id!: number;
    pr_id!: number;
    gia_ban_san_pham!: number;
    so_luong_max!: number;
    isError!: boolean;

    constructor(data?: IUpdateMachineDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_de_id = _data["ma_de_id"];
            this.pr_id = _data["pr_id"];
            this.gia_ban_san_pham = _data["gia_ban_san_pham"];
            this.so_luong_max = _data["so_luong_max"];
            this.isError = _data["isError"];
        }
    }

    static fromJS(data: any): UpdateMachineDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMachineDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_de_id"] = this.ma_de_id;
        data["pr_id"] = this.pr_id;
        data["gia_ban_san_pham"] = this.gia_ban_san_pham;
        data["so_luong_max"] = this.so_luong_max;
        data["isError"] = this.isError;
        return data;
    }

    clone(): UpdateMachineDetailInput {
        const json = this.toJSON();
        let result = new UpdateMachineDetailInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMachineDetailInput {
    ma_de_id: number;
    pr_id: number;
    gia_ban_san_pham: number;
    so_luong_max: number;
    isError: boolean;
}

export class UpdateMachineDetailSetting implements IUpdateMachineDetailSetting {

    constructor(data?: IUpdateMachineDetailSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UpdateMachineDetailSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMachineDetailSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): UpdateMachineDetailSetting {
        const json = this.toJSON();
        let result = new UpdateMachineDetailSetting();
        result.init(json);
        return result;
    }
}

export interface IUpdateMachineDetailSetting {
}

export class UpdateMachineInput implements IUpdateMachineInput {
    ma_id!: number;
    gr_ma_id!: number;
    ma_passcode_admin!: string | undefined;
    ma_passcode_replenish!: string | undefined;
    ma_display_name!: string | undefined;
    ma_is_debug!: boolean;
    ma_cameraUrl!: string | undefined;
    ma_cameraUserName!: string | undefined;
    ma_cameraPassword!: string | undefined;
    ma_mapUrl!: string | undefined;
    ma_mapName!: string | undefined;
    ma_activeQrCodePayment!: boolean;
    ma_activeRifdPayment!: boolean;
    ma_activeMomoPayment!: boolean;
    ma_activeMIGPayment!: boolean;
    ma_activeVNPayment!: boolean;
    ma_activeCashPayment!: boolean;
    ma_last_withdraw_at!: Date | undefined;

    constructor(data?: IUpdateMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_id = _data["ma_id"];
            this.gr_ma_id = _data["gr_ma_id"];
            this.ma_passcode_admin = _data["ma_passcode_admin"];
            this.ma_passcode_replenish = _data["ma_passcode_replenish"];
            this.ma_display_name = _data["ma_display_name"];
            this.ma_is_debug = _data["ma_is_debug"];
            this.ma_cameraUrl = _data["ma_cameraUrl"];
            this.ma_cameraUserName = _data["ma_cameraUserName"];
            this.ma_cameraPassword = _data["ma_cameraPassword"];
            this.ma_mapUrl = _data["ma_mapUrl"];
            this.ma_mapName = _data["ma_mapName"];
            this.ma_activeQrCodePayment = _data["ma_activeQrCodePayment"];
            this.ma_activeRifdPayment = _data["ma_activeRifdPayment"];
            this.ma_activeMomoPayment = _data["ma_activeMomoPayment"];
            this.ma_activeMIGPayment = _data["ma_activeMIGPayment"];
            this.ma_activeVNPayment = _data["ma_activeVNPayment"];
            this.ma_activeCashPayment = _data["ma_activeCashPayment"];
            this.ma_last_withdraw_at = _data["ma_last_withdraw_at"] ? new Date(_data["ma_last_withdraw_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_id"] = this.ma_id;
        data["gr_ma_id"] = this.gr_ma_id;
        data["ma_passcode_admin"] = this.ma_passcode_admin;
        data["ma_passcode_replenish"] = this.ma_passcode_replenish;
        data["ma_display_name"] = this.ma_display_name;
        data["ma_is_debug"] = this.ma_is_debug;
        data["ma_cameraUrl"] = this.ma_cameraUrl;
        data["ma_cameraUserName"] = this.ma_cameraUserName;
        data["ma_cameraPassword"] = this.ma_cameraPassword;
        data["ma_mapUrl"] = this.ma_mapUrl;
        data["ma_mapName"] = this.ma_mapName;
        data["ma_activeQrCodePayment"] = this.ma_activeQrCodePayment;
        data["ma_activeRifdPayment"] = this.ma_activeRifdPayment;
        data["ma_activeMomoPayment"] = this.ma_activeMomoPayment;
        data["ma_activeMIGPayment"] = this.ma_activeMIGPayment;
        data["ma_activeVNPayment"] = this.ma_activeVNPayment;
        data["ma_activeCashPayment"] = this.ma_activeCashPayment;
        data["ma_last_withdraw_at"] = this.ma_last_withdraw_at ? this.ma_last_withdraw_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdateMachineInput {
        const json = this.toJSON();
        let result = new UpdateMachineInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMachineInput {
    ma_id: number;
    gr_ma_id: number;
    ma_passcode_admin: string | undefined;
    ma_passcode_replenish: string | undefined;
    ma_display_name: string | undefined;
    ma_is_debug: boolean;
    ma_cameraUrl: string | undefined;
    ma_cameraUserName: string | undefined;
    ma_cameraPassword: string | undefined;
    ma_mapUrl: string | undefined;
    ma_mapName: string | undefined;
    ma_activeQrCodePayment: boolean;
    ma_activeRifdPayment: boolean;
    ma_activeMomoPayment: boolean;
    ma_activeMIGPayment: boolean;
    ma_activeVNPayment: boolean;
    ma_activeCashPayment: boolean;
    ma_last_withdraw_at: Date | undefined;
}

export class UpdateMachineSoftInput implements IUpdateMachineSoftInput {
    ma_so_version_name!: string | undefined;
    ma_so_version_code!: number;
    ma_id_list!: number[] | undefined;
    fi_id!: AttachmentItem;
    tenantId!: number | undefined;
    ma_so_id!: number;

    constructor(data?: IUpdateMachineSoftInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_so_version_name = _data["ma_so_version_name"];
            this.ma_so_version_code = _data["ma_so_version_code"];
            if (Array.isArray(_data["ma_id_list"])) {
                this.ma_id_list = [] as any;
                for (let item of _data["ma_id_list"])
                    this.ma_id_list!.push(item);
            }
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.ma_so_id = _data["ma_so_id"];
        }
    }

    static fromJS(data: any): UpdateMachineSoftInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMachineSoftInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_so_version_name"] = this.ma_so_version_name;
        data["ma_so_version_code"] = this.ma_so_version_code;
        if (Array.isArray(this.ma_id_list)) {
            data["ma_id_list"] = [];
            for (let item of this.ma_id_list)
                data["ma_id_list"].push(item);
        }
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["ma_so_id"] = this.ma_so_id;
        return data;
    }

    clone(): UpdateMachineSoftInput {
        const json = this.toJSON();
        let result = new UpdateMachineSoftInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMachineSoftInput {
    ma_so_version_name: string | undefined;
    ma_so_version_code: number;
    ma_id_list: number[] | undefined;
    fi_id: AttachmentItem;
    tenantId: number | undefined;
    ma_so_id: number;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdatePassword2Input implements IUpdatePassword2Input {
    id!: number;
    password!: string | undefined;

    constructor(data?: IUpdatePassword2Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UpdatePassword2Input {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePassword2Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        return data;
    }

    clone(): UpdatePassword2Input {
        const json = this.toJSON();
        let result = new UpdatePassword2Input();
        result.init(json);
        return result;
    }
}

export interface IUpdatePassword2Input {
    id: number;
    password: string | undefined;
}

export class UpdatePaymentBankInput implements IUpdatePaymentBankInput {
    bi_code!: string | undefined;
    deviceId!: string | undefined;

    constructor(data?: IUpdatePaymentBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): UpdatePaymentBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["deviceId"] = this.deviceId;
        return data;
    }

    clone(): UpdatePaymentBankInput {
        const json = this.toJSON();
        let result = new UpdatePaymentBankInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentBankInput {
    bi_code: string | undefined;
    deviceId: string | undefined;
}

export class UpdateProductInput implements IUpdateProductInput {
    pr_id!: number;
    pr_name!: string | undefined;
    pr_unit!: string | undefined;
    pr_price!: number;
    pr_type!: EDrinkType;
    pr_desc!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pr_id = _data["pr_id"];
            this.pr_name = _data["pr_name"];
            this.pr_unit = _data["pr_unit"];
            this.pr_price = _data["pr_price"];
            this.pr_type = _data["pr_type"];
            this.pr_desc = _data["pr_desc"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pr_id"] = this.pr_id;
        data["pr_name"] = this.pr_name;
        data["pr_unit"] = this.pr_unit;
        data["pr_price"] = this.pr_price;
        data["pr_type"] = this.pr_type;
        data["pr_desc"] = this.pr_desc;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateProductInput {
        const json = this.toJSON();
        let result = new UpdateProductInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProductInput {
    pr_id: number;
    pr_name: string | undefined;
    pr_unit: string | undefined;
    pr_price: number;
    pr_type: EDrinkType;
    pr_desc: string | undefined;
    fi_id: AttachmentItem;
}

export class UpdateReconcileInput implements IUpdateReconcileInput {
    rec_id!: number;
    rec_money_reality!: number;

    constructor(data?: IUpdateReconcileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.rec_money_reality = _data["rec_money_reality"];
        }
    }

    static fromJS(data: any): UpdateReconcileInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReconcileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["rec_money_reality"] = this.rec_money_reality;
        return data;
    }

    clone(): UpdateReconcileInput {
        const json = this.toJSON();
        let result = new UpdateReconcileInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateReconcileInput {
    rec_id: number;
    rec_money_reality: number;
}

export class UpdateRefundInput implements IUpdateRefundInput {
    ref_id!: number;
    ref_reason!: string | undefined;
    ref_namebank!: string | undefined;
    ref_codebank!: string | undefined;
    ref_nameAccountBank!: string | undefined;
    ref_reason_type!: ERefundReasonType;
    ref_status!: ERefundStatus;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateRefundInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ref_id = _data["ref_id"];
            this.ref_reason = _data["ref_reason"];
            this.ref_namebank = _data["ref_namebank"];
            this.ref_codebank = _data["ref_codebank"];
            this.ref_nameAccountBank = _data["ref_nameAccountBank"];
            this.ref_reason_type = _data["ref_reason_type"];
            this.ref_status = _data["ref_status"];
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateRefundInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRefundInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ref_id"] = this.ref_id;
        data["ref_reason"] = this.ref_reason;
        data["ref_namebank"] = this.ref_namebank;
        data["ref_codebank"] = this.ref_codebank;
        data["ref_nameAccountBank"] = this.ref_nameAccountBank;
        data["ref_reason_type"] = this.ref_reason_type;
        data["ref_status"] = this.ref_status;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateRefundInput {
        const json = this.toJSON();
        let result = new UpdateRefundInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateRefundInput {
    ref_id: number;
    ref_reason: string | undefined;
    ref_namebank: string | undefined;
    ref_codebank: string | undefined;
    ref_nameAccountBank: string | undefined;
    ref_reason_type: ERefundReasonType;
    ref_status: ERefundStatus;
    fi_id_list: AttachmentItem[] | undefined;
}

export class UpdateReportOfMachineInput implements IUpdateReportOfMachineInput {
    re_id!: number;
    re_status!: ReportStatus;
    re_note!: string | undefined;

    constructor(data?: IUpdateReportOfMachineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_status = _data["re_status"];
            this.re_note = _data["re_note"];
        }
    }

    static fromJS(data: any): UpdateReportOfMachineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReportOfMachineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_status"] = this.re_status;
        data["re_note"] = this.re_note;
        return data;
    }

    clone(): UpdateReportOfMachineInput {
        const json = this.toJSON();
        let result = new UpdateReportOfMachineInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateReportOfMachineInput {
    re_id: number;
    re_status: ReportStatus;
    re_note: string | undefined;
}

export class UpdateRepositoryInput implements IUpdateRepositoryInput {
    us_id_operator!: number;
    re_name!: string | undefined;
    re_desc!: string | undefined;
    re_parent_id!: number;
    re_type!: ERepositoryType;
    ma_id_arr!: number[] | undefined;
    re_id!: number;

    constructor(data?: IUpdateRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.us_id_operator = _data["us_id_operator"];
            this.re_name = _data["re_name"];
            this.re_desc = _data["re_desc"];
            this.re_parent_id = _data["re_parent_id"];
            this.re_type = _data["re_type"];
            if (Array.isArray(_data["ma_id_arr"])) {
                this.ma_id_arr = [] as any;
                for (let item of _data["ma_id_arr"])
                    this.ma_id_arr!.push(item);
            }
            this.re_id = _data["re_id"];
        }
    }

    static fromJS(data: any): UpdateRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["us_id_operator"] = this.us_id_operator;
        data["re_name"] = this.re_name;
        data["re_desc"] = this.re_desc;
        data["re_parent_id"] = this.re_parent_id;
        data["re_type"] = this.re_type;
        if (Array.isArray(this.ma_id_arr)) {
            data["ma_id_arr"] = [];
            for (let item of this.ma_id_arr)
                data["ma_id_arr"].push(item);
        }
        data["re_id"] = this.re_id;
        return data;
    }

    clone(): UpdateRepositoryInput {
        const json = this.toJSON();
        let result = new UpdateRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateRepositoryInput {
    us_id_operator: number;
    re_name: string | undefined;
    re_desc: string | undefined;
    re_parent_id: number;
    re_type: ERepositoryType;
    ma_id_arr: number[] | undefined;
    re_id: number;
}

export class UpdateStateNotificationInput implements IUpdateStateNotificationInput {
    notificationId!: string | undefined;
    state!: UserNotificationState;

    constructor(data?: IUpdateStateNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): UpdateStateNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStateNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["state"] = this.state;
        return data;
    }

    clone(): UpdateStateNotificationInput {
        const json = this.toJSON();
        let result = new UpdateStateNotificationInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateStateNotificationInput {
    notificationId: string | undefined;
    state: UserNotificationState;
}

export class UpdateStatusRfidInput implements IUpdateStatusRfidInput {
    rf_id!: number;
    rf_is_active!: boolean;

    constructor(data?: IUpdateStatusRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rf_id = _data["rf_id"];
            this.rf_is_active = _data["rf_is_active"];
        }
    }

    static fromJS(data: any): UpdateStatusRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatusRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rf_id"] = this.rf_id;
        data["rf_is_active"] = this.rf_is_active;
        return data;
    }

    clone(): UpdateStatusRfidInput {
        const json = this.toJSON();
        let result = new UpdateStatusRfidInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateStatusRfidInput {
    rf_id: number;
    rf_is_active: boolean;
}

export class UpdateSupplierInput implements IUpdateSupplierInput {
    su_id!: number;
    su_name!: string | undefined;
    su_phone!: string | undefined;
    su_address!: string | undefined;
    su_email!: string | undefined;
    su_contact_person!: string | undefined;
    su_note!: string | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUpdateSupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_name = _data["su_name"];
            this.su_phone = _data["su_phone"];
            this.su_address = _data["su_address"];
            this.su_email = _data["su_email"];
            this.su_contact_person = _data["su_contact_person"];
            this.su_note = _data["su_note"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UpdateSupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_name"] = this.su_name;
        data["su_phone"] = this.su_phone;
        data["su_address"] = this.su_address;
        data["su_email"] = this.su_email;
        data["su_contact_person"] = this.su_contact_person;
        data["su_note"] = this.su_note;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): UpdateSupplierInput {
        const json = this.toJSON();
        let result = new UpdateSupplierInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateSupplierInput {
    su_id: number;
    su_name: string | undefined;
    su_phone: string | undefined;
    su_address: string | undefined;
    su_email: string | undefined;
    su_contact_person: string | undefined;
    su_note: string | undefined;
    tenantId: number | undefined;
}

export class UpdateTranferRepositoryInput implements IUpdateTranferRepositoryInput {
    re_id_transfer!: number;
    re_id_receiver!: number;
    tr_re_total_money!: number;
    tr_re_note!: string | undefined;
    tr_re_status!: ETranferRepositoryStatus;
    listProductTranfer!: ProductTranferDto[] | undefined;
    fi_id_list!: AttachmentItem[] | undefined;
    tr_re_id!: number;

    constructor(data?: IUpdateTranferRepositoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id_transfer = _data["re_id_transfer"];
            this.re_id_receiver = _data["re_id_receiver"];
            this.tr_re_total_money = _data["tr_re_total_money"];
            this.tr_re_note = _data["tr_re_note"];
            this.tr_re_status = _data["tr_re_status"];
            if (Array.isArray(_data["listProductTranfer"])) {
                this.listProductTranfer = [] as any;
                for (let item of _data["listProductTranfer"])
                    this.listProductTranfer!.push(ProductTranferDto.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
            this.tr_re_id = _data["tr_re_id"];
        }
    }

    static fromJS(data: any): UpdateTranferRepositoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTranferRepositoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id_transfer"] = this.re_id_transfer;
        data["re_id_receiver"] = this.re_id_receiver;
        data["tr_re_total_money"] = this.tr_re_total_money;
        data["tr_re_note"] = this.tr_re_note;
        data["tr_re_status"] = this.tr_re_status;
        if (Array.isArray(this.listProductTranfer)) {
            data["listProductTranfer"] = [];
            for (let item of this.listProductTranfer)
                data["listProductTranfer"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        data["tr_re_id"] = this.tr_re_id;
        return data;
    }

    clone(): UpdateTranferRepositoryInput {
        const json = this.toJSON();
        let result = new UpdateTranferRepositoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTranferRepositoryInput {
    re_id_transfer: number;
    re_id_receiver: number;
    tr_re_total_money: number;
    tr_re_note: string | undefined;
    tr_re_status: ETranferRepositoryStatus;
    listProductTranfer: ProductTranferDto[] | undefined;
    fi_id_list: AttachmentItem[] | undefined;
    tr_re_id: number;
}

export class UpdateTrashBinInput implements IUpdateTrashBinInput {
    tr_name!: string | undefined;
    deviceMAC!: string | undefined;
    tr_urlMap!: string | undefined;
    tr_tien_quy_doi_theo_rac!: number;
    gr_tr_id!: number;
    tr_type!: ETrashType;
    tr_note!: string | undefined;
    tenantId!: number | undefined;
    tr_id!: number;

    constructor(data?: IUpdateTrashBinInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tr_name = _data["tr_name"];
            this.deviceMAC = _data["deviceMAC"];
            this.tr_urlMap = _data["tr_urlMap"];
            this.tr_tien_quy_doi_theo_rac = _data["tr_tien_quy_doi_theo_rac"];
            this.gr_tr_id = _data["gr_tr_id"];
            this.tr_type = _data["tr_type"];
            this.tr_note = _data["tr_note"];
            this.tenantId = _data["tenantId"];
            this.tr_id = _data["tr_id"];
        }
    }

    static fromJS(data: any): UpdateTrashBinInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrashBinInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tr_name"] = this.tr_name;
        data["deviceMAC"] = this.deviceMAC;
        data["tr_urlMap"] = this.tr_urlMap;
        data["tr_tien_quy_doi_theo_rac"] = this.tr_tien_quy_doi_theo_rac;
        data["gr_tr_id"] = this.gr_tr_id;
        data["tr_type"] = this.tr_type;
        data["tr_note"] = this.tr_note;
        data["tenantId"] = this.tenantId;
        data["tr_id"] = this.tr_id;
        return data;
    }

    clone(): UpdateTrashBinInput {
        const json = this.toJSON();
        let result = new UpdateTrashBinInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTrashBinInput {
    tr_name: string | undefined;
    deviceMAC: string | undefined;
    tr_urlMap: string | undefined;
    tr_tien_quy_doi_theo_rac: number;
    gr_tr_id: number;
    tr_type: ETrashType;
    tr_note: string | undefined;
    tenantId: number | undefined;
    tr_id: number;
}

export class UpdateUserInput implements IUpdateUserInput {
    id!: number;
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    roleNames!: string[] | undefined;
    us_address!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    us_cmt_locked_default!: boolean;

    constructor(data?: IUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.us_address = _data["us_address"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
        }
    }

    static fromJS(data: any): UpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["us_address"] = this.us_address;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        return data;
    }

    clone(): UpdateUserInput {
        const json = this.toJSON();
        let result = new UpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserInput {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    us_address: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    us_cmt_locked_default: boolean;
}

export class UserDto implements IUserDto {
    id!: number;
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    fullName!: string | undefined;
    lastLoginTime!: Date | undefined;
    creationTime!: Date;
    roleNames!: string[] | undefined;
    us_address!: string | undefined;
    tenantName!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    us_avatar!: number;
    us_cmt_locked_default!: boolean;
    us_updated_at!: Date;
    us_created_at!: Date;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.us_address = _data["us_address"];
            this.tenantName = _data["tenantName"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.us_avatar = _data["us_avatar"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
            this.us_updated_at = _data["us_updated_at"] ? new Date(_data["us_updated_at"].toString()) : <any>undefined;
            this.us_created_at = _data["us_created_at"] ? new Date(_data["us_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["us_address"] = this.us_address;
        data["tenantName"] = this.tenantName;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["us_avatar"] = this.us_avatar;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        data["us_updated_at"] = this.us_updated_at ? this.us_updated_at.toISOString() : <any>undefined;
        data["us_created_at"] = this.us_created_at ? this.us_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: Date | undefined;
    creationTime: Date;
    roleNames: string[] | undefined;
    us_address: string | undefined;
    tenantName: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    us_avatar: number;
    us_cmt_locked_default: boolean;
    us_updated_at: Date;
    us_created_at: Date;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items!: UserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    us_avatar!: number;
    us_address!: string | undefined;
    hasPassword2!: boolean;
    us_dob!: Date | undefined;
    us_gender!: GENDER;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.us_avatar = _data["us_avatar"];
            this.us_address = _data["us_address"];
            this.hasPassword2 = _data["hasPassword2"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["us_avatar"] = this.us_avatar;
        data["us_address"] = this.us_address;
        data["hasPassword2"] = this.hasPassword2;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    us_avatar: number;
    us_address: string | undefined;
    hasPassword2: boolean;
    us_dob: Date | undefined;
    us_gender: GENDER;
}

export class UserNotification implements IUserNotification {
    id!: string;
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    targetNotifiers!: string | undefined;
    readonly targetNotifiersList!: string[] | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.targetNotifiers = _data["targetNotifiers"];
            if (Array.isArray(_data["targetNotifiersList"])) {
                (<any>this).targetNotifiersList = [] as any;
                for (let item of _data["targetNotifiersList"])
                    (<any>this).targetNotifiersList!.push(item);
            }
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["targetNotifiers"] = this.targetNotifiers;
        if (Array.isArray(this.targetNotifiersList)) {
            data["targetNotifiersList"] = [];
            for (let item of this.targetNotifiersList)
                data["targetNotifiersList"].push(item);
        }
        return data;
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    id: string;
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    targetNotifiers: string | undefined;
    targetNotifiersList: string[] | undefined;
}

export enum UserNotificationState {
    _0 = 0,
    _1 = 1,
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class VCBInformationPayment implements IVCBInformationPayment {
    merchant_site_code!: string | undefined;
    buyer_fullname!: string | undefined;
    buyer_email!: string | undefined;
    buyer_mobile!: string | undefined;

    constructor(data?: IVCBInformationPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchant_site_code = _data["merchant_site_code"];
            this.buyer_fullname = _data["buyer_fullname"];
            this.buyer_email = _data["buyer_email"];
            this.buyer_mobile = _data["buyer_mobile"];
        }
    }

    static fromJS(data: any): VCBInformationPayment {
        data = typeof data === 'object' ? data : {};
        let result = new VCBInformationPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchant_site_code"] = this.merchant_site_code;
        data["buyer_fullname"] = this.buyer_fullname;
        data["buyer_email"] = this.buyer_email;
        data["buyer_mobile"] = this.buyer_mobile;
        return data;
    }

    clone(): VCBInformationPayment {
        const json = this.toJSON();
        let result = new VCBInformationPayment();
        result.init(json);
        return result;
    }
}

export interface IVCBInformationPayment {
    merchant_site_code: string | undefined;
    buyer_fullname: string | undefined;
    buyer_email: string | undefined;
    buyer_mobile: string | undefined;
}

export class VNPayInformationPayment implements IVNPayInformationPayment {
    appId!: string | undefined;
    secretKey!: string | undefined;
    secretKeyCheckout!: string | undefined;
    secretKeyIPN!: string | undefined;

    constructor(data?: IVNPayInformationPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.secretKey = _data["secretKey"];
            this.secretKeyCheckout = _data["secretKeyCheckout"];
            this.secretKeyIPN = _data["secretKeyIPN"];
        }
    }

    static fromJS(data: any): VNPayInformationPayment {
        data = typeof data === 'object' ? data : {};
        let result = new VNPayInformationPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["secretKey"] = this.secretKey;
        data["secretKeyCheckout"] = this.secretKeyCheckout;
        data["secretKeyIPN"] = this.secretKeyIPN;
        return data;
    }

    clone(): VNPayInformationPayment {
        const json = this.toJSON();
        let result = new VNPayInformationPayment();
        result.init(json);
        return result;
    }
}

export interface IVNPayInformationPayment {
    appId: string | undefined;
    secretKey: string | undefined;
    secretKeyCheckout: string | undefined;
    secretKeyIPN: string | undefined;
}

export class VNPayPaymentInput implements IVNPayPaymentInput {
    code!: string | undefined;
    message!: string | undefined;
    msgType!: string | undefined;
    txnId!: string | undefined;
    qrTrace!: string | undefined;
    bankCode!: string | undefined;
    mobile!: string | undefined;
    accountNo!: string | undefined;
    amount!: string | undefined;
    payDate!: string | undefined;
    masterMerCode!: string | undefined;
    merchantCode!: string | undefined;
    terminalId!: string | undefined;
    addData!: AddDataItem[] | undefined;
    checksum!: string | undefined;
    ccy!: string | undefined;
    address!: string | undefined;
    secretKey!: string | undefined;
    calcChecksum!: string | undefined;

    constructor(data?: IVNPayPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.msgType = _data["msgType"];
            this.txnId = _data["txnId"];
            this.qrTrace = _data["qrTrace"];
            this.bankCode = _data["bankCode"];
            this.mobile = _data["mobile"];
            this.accountNo = _data["accountNo"];
            this.amount = _data["amount"];
            this.payDate = _data["payDate"];
            this.masterMerCode = _data["masterMerCode"];
            this.merchantCode = _data["merchantCode"];
            this.terminalId = _data["terminalId"];
            if (Array.isArray(_data["addData"])) {
                this.addData = [] as any;
                for (let item of _data["addData"])
                    this.addData!.push(AddDataItem.fromJS(item));
            }
            this.checksum = _data["checksum"];
            this.ccy = _data["ccy"];
            this.address = _data["address"];
            this.secretKey = _data["secretKey"];
            this.calcChecksum = _data["calcChecksum"];
        }
    }

    static fromJS(data: any): VNPayPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new VNPayPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["msgType"] = this.msgType;
        data["txnId"] = this.txnId;
        data["qrTrace"] = this.qrTrace;
        data["bankCode"] = this.bankCode;
        data["mobile"] = this.mobile;
        data["accountNo"] = this.accountNo;
        data["amount"] = this.amount;
        data["payDate"] = this.payDate;
        data["masterMerCode"] = this.masterMerCode;
        data["merchantCode"] = this.merchantCode;
        data["terminalId"] = this.terminalId;
        if (Array.isArray(this.addData)) {
            data["addData"] = [];
            for (let item of this.addData)
                data["addData"].push(item.toJSON());
        }
        data["checksum"] = this.checksum;
        data["ccy"] = this.ccy;
        data["address"] = this.address;
        data["secretKey"] = this.secretKey;
        data["calcChecksum"] = this.calcChecksum;
        return data;
    }

    clone(): VNPayPaymentInput {
        const json = this.toJSON();
        let result = new VNPayPaymentInput();
        result.init(json);
        return result;
    }
}

export interface IVNPayPaymentInput {
    code: string | undefined;
    message: string | undefined;
    msgType: string | undefined;
    txnId: string | undefined;
    qrTrace: string | undefined;
    bankCode: string | undefined;
    mobile: string | undefined;
    accountNo: string | undefined;
    amount: string | undefined;
    payDate: string | undefined;
    masterMerCode: string | undefined;
    merchantCode: string | undefined;
    terminalId: string | undefined;
    addData: AddDataItem[] | undefined;
    checksum: string | undefined;
    ccy: string | undefined;
    address: string | undefined;
    secretKey: string | undefined;
    calcChecksum: string | undefined;
}

export class WaitHandle implements IWaitHandle {
    handle!: IntPtr;
    safeWaitHandle!: SafeWaitHandle;

    constructor(data?: IWaitHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handle = _data["handle"] ? IntPtr.fromJS(_data["handle"]) : <any>undefined;
            this.safeWaitHandle = _data["safeWaitHandle"] ? SafeWaitHandle.fromJS(_data["safeWaitHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WaitHandle {
        data = typeof data === 'object' ? data : {};
        let result = new WaitHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["handle"] = this.handle ? this.handle.toJSON() : <any>undefined;
        data["safeWaitHandle"] = this.safeWaitHandle ? this.safeWaitHandle.toJSON() : <any>undefined;
        return data;
    }

    clone(): WaitHandle {
        const json = this.toJSON();
        let result = new WaitHandle();
        result.init(json);
        return result;
    }
}

export interface IWaitHandle {
    handle: IntPtr;
    safeWaitHandle: SafeWaitHandle;
}

export class WebSocketManager implements IWebSocketManager {
    readonly isWebSocketRequest!: boolean;
    readonly webSocketRequestedProtocols!: string[] | undefined;

    constructor(data?: IWebSocketManager) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isWebSocketRequest = _data["isWebSocketRequest"];
            if (Array.isArray(_data["webSocketRequestedProtocols"])) {
                (<any>this).webSocketRequestedProtocols = [] as any;
                for (let item of _data["webSocketRequestedProtocols"])
                    (<any>this).webSocketRequestedProtocols!.push(item);
            }
        }
    }

    static fromJS(data: any): WebSocketManager {
        data = typeof data === 'object' ? data : {};
        let result = new WebSocketManager();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isWebSocketRequest"] = this.isWebSocketRequest;
        if (Array.isArray(this.webSocketRequestedProtocols)) {
            data["webSocketRequestedProtocols"] = [];
            for (let item of this.webSocketRequestedProtocols)
                data["webSocketRequestedProtocols"].push(item);
        }
        return data;
    }

    clone(): WebSocketManager {
        const json = this.toJSON();
        let result = new WebSocketManager();
        result.init(json);
        return result;
    }
}

export interface IWebSocketManager {
    isWebSocketRequest: boolean;
    webSocketRequestedProtocols: string[] | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    id!: string;
    webhookName!: string;
    data!: string | undefined;
    creationTime!: Date;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: Date | undefined;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): WebhookEvent {
        const json = this.toJSON();
        let result = new WebhookEvent();
        result.init(json);
        return result;
    }
}

export interface IWebhookEvent {
    id: string;
    webhookName: string;
    data: string | undefined;
    creationTime: Date;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: Date | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
    id!: string;
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        return data;
    }

    clone(): WebhookSubscription {
        const json = this.toJSON();
        let result = new WebhookSubscription();
        result.init(json);
        return result;
    }
}

export interface IWebhookSubscription {
    id: string;
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
}

export class WithdrawDto implements IWithdrawDto {
    wi_id!: number;
    wi_total_money_reality!: number;
    ma_id!: number;
    us_id_operator!: number;
    wi_payment_type!: BillMethod;
    wi_note!: string | undefined;
    wi_start_date!: Date | undefined;
    wi_end_date!: Date | undefined;
    wi_created_at!: Date;
    fi_id_list!: AttachmentItem[] | undefined;

    constructor(data?: IWithdrawDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wi_id = _data["wi_id"];
            this.wi_total_money_reality = _data["wi_total_money_reality"];
            this.ma_id = _data["ma_id"];
            this.us_id_operator = _data["us_id_operator"];
            this.wi_payment_type = _data["wi_payment_type"];
            this.wi_note = _data["wi_note"];
            this.wi_start_date = _data["wi_start_date"] ? new Date(_data["wi_start_date"].toString()) : <any>undefined;
            this.wi_end_date = _data["wi_end_date"] ? new Date(_data["wi_end_date"].toString()) : <any>undefined;
            this.wi_created_at = _data["wi_created_at"] ? new Date(_data["wi_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_list"])) {
                this.fi_id_list = [] as any;
                for (let item of _data["fi_id_list"])
                    this.fi_id_list!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WithdrawDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wi_id"] = this.wi_id;
        data["wi_total_money_reality"] = this.wi_total_money_reality;
        data["ma_id"] = this.ma_id;
        data["us_id_operator"] = this.us_id_operator;
        data["wi_payment_type"] = this.wi_payment_type;
        data["wi_note"] = this.wi_note;
        data["wi_start_date"] = this.wi_start_date ? this.wi_start_date.toISOString() : <any>undefined;
        data["wi_end_date"] = this.wi_end_date ? this.wi_end_date.toISOString() : <any>undefined;
        data["wi_created_at"] = this.wi_created_at ? this.wi_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_list)) {
            data["fi_id_list"] = [];
            for (let item of this.fi_id_list)
                data["fi_id_list"].push(item.toJSON());
        }
        return data;
    }

    clone(): WithdrawDto {
        const json = this.toJSON();
        let result = new WithdrawDto();
        result.init(json);
        return result;
    }
}

export interface IWithdrawDto {
    wi_id: number;
    wi_total_money_reality: number;
    ma_id: number;
    us_id_operator: number;
    wi_payment_type: BillMethod;
    wi_note: string | undefined;
    wi_start_date: Date | undefined;
    wi_end_date: Date | undefined;
    wi_created_at: Date;
    fi_id_list: AttachmentItem[] | undefined;
}

export class WithdrawDtoPagedResultDto implements IWithdrawDtoPagedResultDto {
    items!: WithdrawDto[] | undefined;
    totalCount!: number;

    constructor(data?: IWithdrawDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WithdrawDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): WithdrawDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): WithdrawDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WithdrawDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWithdrawDtoPagedResultDto {
    items: WithdrawDto[] | undefined;
    totalCount: number;
}

export class X500DistinguishedName implements IX500DistinguishedName {
    oid!: Oid;
    rawData!: string | undefined;
    readonly name!: string | undefined;

    constructor(data?: IX500DistinguishedName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"] ? Oid.fromJS(_data["oid"]) : <any>undefined;
            this.rawData = _data["rawData"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): X500DistinguishedName {
        data = typeof data === 'object' ? data : {};
        let result = new X500DistinguishedName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        data["rawData"] = this.rawData;
        data["name"] = this.name;
        return data;
    }

    clone(): X500DistinguishedName {
        const json = this.toJSON();
        let result = new X500DistinguishedName();
        result.init(json);
        return result;
    }
}

export interface IX500DistinguishedName {
    oid: Oid;
    rawData: string | undefined;
    name: string | undefined;
}

export class X509Certificate2 implements IX509Certificate2 {
    handle!: IntPtr;
    readonly issuer!: string | undefined;
    readonly subject!: string | undefined;
    serialNumberBytes!: ByteReadOnlyMemory;
    archived!: boolean;
    readonly extensions!: X509Extension[] | undefined;
    friendlyName!: string | undefined;
    readonly hasPrivateKey!: boolean;
    privateKey!: AsymmetricAlgorithm;
    issuerName!: X500DistinguishedName;
    readonly notAfter!: Date;
    readonly notBefore!: Date;
    publicKey!: PublicKey;
    readonly rawData!: string | undefined;
    rawDataMemory!: ByteReadOnlyMemory;
    readonly serialNumber!: string | undefined;
    signatureAlgorithm!: Oid;
    subjectName!: X500DistinguishedName;
    readonly thumbprint!: string | undefined;
    readonly version!: number;

    constructor(data?: IX509Certificate2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handle = _data["handle"] ? IntPtr.fromJS(_data["handle"]) : <any>undefined;
            (<any>this).issuer = _data["issuer"];
            (<any>this).subject = _data["subject"];
            this.serialNumberBytes = _data["serialNumberBytes"] ? ByteReadOnlyMemory.fromJS(_data["serialNumberBytes"]) : <any>undefined;
            this.archived = _data["archived"];
            if (Array.isArray(_data["extensions"])) {
                (<any>this).extensions = [] as any;
                for (let item of _data["extensions"])
                    (<any>this).extensions!.push(X509Extension.fromJS(item));
            }
            this.friendlyName = _data["friendlyName"];
            (<any>this).hasPrivateKey = _data["hasPrivateKey"];
            this.privateKey = _data["privateKey"] ? AsymmetricAlgorithm.fromJS(_data["privateKey"]) : <any>undefined;
            this.issuerName = _data["issuerName"] ? X500DistinguishedName.fromJS(_data["issuerName"]) : <any>undefined;
            (<any>this).notAfter = _data["notAfter"] ? new Date(_data["notAfter"].toString()) : <any>undefined;
            (<any>this).notBefore = _data["notBefore"] ? new Date(_data["notBefore"].toString()) : <any>undefined;
            this.publicKey = _data["publicKey"] ? PublicKey.fromJS(_data["publicKey"]) : <any>undefined;
            (<any>this).rawData = _data["rawData"];
            this.rawDataMemory = _data["rawDataMemory"] ? ByteReadOnlyMemory.fromJS(_data["rawDataMemory"]) : <any>undefined;
            (<any>this).serialNumber = _data["serialNumber"];
            this.signatureAlgorithm = _data["signatureAlgorithm"] ? Oid.fromJS(_data["signatureAlgorithm"]) : <any>undefined;
            this.subjectName = _data["subjectName"] ? X500DistinguishedName.fromJS(_data["subjectName"]) : <any>undefined;
            (<any>this).thumbprint = _data["thumbprint"];
            (<any>this).version = _data["version"];
        }
    }

    static fromJS(data: any): X509Certificate2 {
        data = typeof data === 'object' ? data : {};
        let result = new X509Certificate2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["handle"] = this.handle ? this.handle.toJSON() : <any>undefined;
        data["issuer"] = this.issuer;
        data["subject"] = this.subject;
        data["serialNumberBytes"] = this.serialNumberBytes ? this.serialNumberBytes.toJSON() : <any>undefined;
        data["archived"] = this.archived;
        if (Array.isArray(this.extensions)) {
            data["extensions"] = [];
            for (let item of this.extensions)
                data["extensions"].push(item.toJSON());
        }
        data["friendlyName"] = this.friendlyName;
        data["hasPrivateKey"] = this.hasPrivateKey;
        data["privateKey"] = this.privateKey ? this.privateKey.toJSON() : <any>undefined;
        data["issuerName"] = this.issuerName ? this.issuerName.toJSON() : <any>undefined;
        data["notAfter"] = this.notAfter ? this.notAfter.toISOString() : <any>undefined;
        data["notBefore"] = this.notBefore ? this.notBefore.toISOString() : <any>undefined;
        data["publicKey"] = this.publicKey ? this.publicKey.toJSON() : <any>undefined;
        data["rawData"] = this.rawData;
        data["rawDataMemory"] = this.rawDataMemory ? this.rawDataMemory.toJSON() : <any>undefined;
        data["serialNumber"] = this.serialNumber;
        data["signatureAlgorithm"] = this.signatureAlgorithm ? this.signatureAlgorithm.toJSON() : <any>undefined;
        data["subjectName"] = this.subjectName ? this.subjectName.toJSON() : <any>undefined;
        data["thumbprint"] = this.thumbprint;
        data["version"] = this.version;
        return data;
    }

    clone(): X509Certificate2 {
        const json = this.toJSON();
        let result = new X509Certificate2();
        result.init(json);
        return result;
    }
}

export interface IX509Certificate2 {
    handle: IntPtr;
    issuer: string | undefined;
    subject: string | undefined;
    serialNumberBytes: ByteReadOnlyMemory;
    archived: boolean;
    extensions: X509Extension[] | undefined;
    friendlyName: string | undefined;
    hasPrivateKey: boolean;
    privateKey: AsymmetricAlgorithm;
    issuerName: X500DistinguishedName;
    notAfter: Date;
    notBefore: Date;
    publicKey: PublicKey;
    rawData: string | undefined;
    rawDataMemory: ByteReadOnlyMemory;
    serialNumber: string | undefined;
    signatureAlgorithm: Oid;
    subjectName: X500DistinguishedName;
    thumbprint: string | undefined;
    version: number;
}

export class X509Extension implements IX509Extension {
    oid!: Oid;
    rawData!: string | undefined;
    critical!: boolean;

    constructor(data?: IX509Extension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"] ? Oid.fromJS(_data["oid"]) : <any>undefined;
            this.rawData = _data["rawData"];
            this.critical = _data["critical"];
        }
    }

    static fromJS(data: any): X509Extension {
        data = typeof data === 'object' ? data : {};
        let result = new X509Extension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        data["rawData"] = this.rawData;
        data["critical"] = this.critical;
        return data;
    }

    clone(): X509Extension {
        const json = this.toJSON();
        let result = new X509Extension();
        result.init(json);
        return result;
    }
}

export interface IX509Extension {
    oid: Oid;
    rawData: string | undefined;
    critical: boolean;
}

export enum EAuthorizationMachineType {
    _0 = 0,
    _1 = 1,
}

export enum EBank {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum EBillReconcileStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EBillRequiredFund {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum EBillStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum EBillingProductStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EComponentUpload {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EDrinkType {
    _0 = 0,
    _1 = 1,
}

export enum EHandoverStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum EHandoverType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EImportDetailType {
    _0 = 0,
    _1 = 1,
}

export enum EImportRepositoryStatus {
    _0 = 0,
    _1 = 1,
}

export enum ELossRepositoryStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EMachineSoftLogsStatus {
    _0 = 0,
    _1 = 1,
}

export enum EMainBoard {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum EPaidStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum EPaymentFor {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum EPaymentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ERIFDAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum EReconcileStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum EReconcileType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ERefundReasonType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ERefundStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ERepositoryLogAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ERepositoryProductStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ERepositoryType {
    _1 = 1,
    _2 = 2,
}

export enum ESupplierPaymentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ETranferRepositoryStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ETranferStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ETrashDeviceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ETrashType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export enum ETypeFileMedia {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
